// DO NOT EDIT. Generated by tensorflow-op-codegen/src/main.rs.
#![allow(
    non_snake_case,
    trivial_casts,
    unused_parens,
    unused_qualifications
)]

/// Builder for the `Abort` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Abort {
    error_msg: ::std::option::Option<::std::string::String>,
    exit_without_error: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Abort {
    /// Creates a new `Abort`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `error_msg` attribute.
    pub fn error_msg<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.error_msg = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `exit_without_error` attribute.
    pub fn exit_without_error<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.exit_without_error = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Abort` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Abort", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.error_msg {
                nd.set_attr_string("error_msg", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.exit_without_error {
                nd.set_attr_bool("exit_without_error", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Abort::new().build(scope)`.
pub fn abort(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Abort::new().build(scope)
}
/// Builder for the `Abs` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Abs {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Abs {
    /// Creates a new `Abs`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Abs` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Abs", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Abs::new().build(x, scope)`.
pub fn abs<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Abs::new().build(x, scope)
}
/// Builder for the `AccumulateNV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulateNV2 {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AccumulateNV2 {
    /// Creates a new `AccumulateNV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AccumulateNV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AccumulateNV2", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AccumulateNV2::new().build(inputs, scope)`.
pub fn accumulate_nv2<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AccumulateNV2::new().build(inputs, scope)
}
/// Builder for the `AccumulatorApplyGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulatorApplyGradient {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AccumulatorApplyGradient {
    /// Creates a new `AccumulatorApplyGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AccumulatorApplyGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        local_step: O1,
        gradient: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), local_step.into(), gradient.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        local_step: crate::Output,
        gradient: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AccumulatorApplyGradient", |nd| {
            nd.add_input(handle);
            nd.add_input(local_step);
            nd.add_input(gradient);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AccumulatorApplyGradient::new().build(handle, local_step, gradient, scope)`.
pub fn accumulator_apply_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    local_step: O1,
    gradient: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AccumulatorApplyGradient::new().build(handle, local_step, gradient, scope)
}
/// Builder for the `AccumulatorNumAccumulated` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulatorNumAccumulated {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AccumulatorNumAccumulated {
    /// Creates a new `AccumulatorNumAccumulated`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AccumulatorNumAccumulated` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AccumulatorNumAccumulated", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AccumulatorNumAccumulated::new().build(handle, scope)`.
pub fn accumulator_num_accumulated<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AccumulatorNumAccumulated::new().build(handle, scope)
}
/// Builder for the `AccumulatorSetGlobalStep` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulatorSetGlobalStep {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AccumulatorSetGlobalStep {
    /// Creates a new `AccumulatorSetGlobalStep`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AccumulatorSetGlobalStep` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        new_global_step: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), new_global_step.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        new_global_step: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AccumulatorSetGlobalStep", |nd| {
            nd.add_input(handle);
            nd.add_input(new_global_step);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AccumulatorSetGlobalStep::new().build(handle, new_global_step, scope)`.
pub fn accumulator_set_global_step<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    new_global_step: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AccumulatorSetGlobalStep::new().build(handle, new_global_step, scope)
}
/// Builder for the `AccumulatorTakeGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AccumulatorTakeGradient {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AccumulatorTakeGradient {
    /// Creates a new `AccumulatorTakeGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AccumulatorTakeGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        num_required: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), num_required.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        num_required: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AccumulatorTakeGradient", |nd| {
            nd.add_input(handle);
            nd.add_input(num_required);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AccumulatorTakeGradient::new().build(handle, num_required, scope)`.
pub fn accumulator_take_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    num_required: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AccumulatorTakeGradient::new().build(handle, num_required, scope)
}
/// Builder for the `Acos` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Acos {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Acos {
    /// Creates a new `Acos`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Acos` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Acos", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Acos::new().build(x, scope)`.
pub fn acos<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Acos::new().build(x, scope)
}
/// Builder for the `Acosh` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Acosh {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Acosh {
    /// Creates a new `Acosh`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Acosh` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Acosh", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Acosh::new().build(x, scope)`.
pub fn acosh<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Acosh::new().build(x, scope)
}
/// Builder for the `Add` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Add {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Add {
    /// Creates a new `Add`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Add` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Add", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Add::new().build(x, y, scope)`.
pub fn add<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Add::new().build(x, y, scope)
}
/// Builder for the `AddManySparseToTensorsMap` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AddManySparseToTensorsMap {
    T: ::std::option::Option<crate::DataType>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AddManySparseToTensorsMap {
    /// Creates a new `AddManySparseToTensorsMap`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AddManySparseToTensorsMap` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sparse_indices: O0,
        sparse_values: O1,
        sparse_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sparse_indices.into(),
            sparse_values.into(),
            sparse_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sparse_indices: crate::Output,
        sparse_values: crate::Output,
        sparse_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AddManySparseToTensorsMap", |nd| {
            nd.add_input(sparse_indices);
            nd.add_input(sparse_values);
            nd.add_input(sparse_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AddManySparseToTensorsMap::new().build(sparse_indices, sparse_values, sparse_shape, scope)`.
pub fn add_many_sparse_to_tensors_map<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    sparse_indices: O0,
    sparse_values: O1,
    sparse_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AddManySparseToTensorsMap::new().build(sparse_indices, sparse_values, sparse_shape, scope)
}
/// Builder for the `AddN` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AddN {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AddN {
    /// Creates a new `AddN`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AddN` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AddN", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AddN::new().build(inputs, scope)`.
pub fn add_n<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AddN::new().build(inputs, scope)
}
/// Builder for the `AddSparseToTensorsMap` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AddSparseToTensorsMap {
    T: ::std::option::Option<crate::DataType>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AddSparseToTensorsMap {
    /// Creates a new `AddSparseToTensorsMap`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AddSparseToTensorsMap` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sparse_indices: O0,
        sparse_values: O1,
        sparse_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sparse_indices.into(),
            sparse_values.into(),
            sparse_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sparse_indices: crate::Output,
        sparse_values: crate::Output,
        sparse_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AddSparseToTensorsMap", |nd| {
            nd.add_input(sparse_indices);
            nd.add_input(sparse_values);
            nd.add_input(sparse_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AddSparseToTensorsMap::new().build(sparse_indices, sparse_values, sparse_shape, scope)`.
pub fn add_sparse_to_tensors_map<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    sparse_indices: O0,
    sparse_values: O1,
    sparse_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AddSparseToTensorsMap::new().build(sparse_indices, sparse_values, sparse_shape, scope)
}
/// Builder for the `AddV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AddV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AddV2 {
    /// Creates a new `AddV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AddV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AddV2", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AddV2::new().build(x, y, scope)`.
pub fn add_v2<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AddV2::new().build(x, y, scope)
}
/// Builder for the `AdjustContrast` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AdjustContrast {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AdjustContrast {
    /// Creates a new `AdjustContrast`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AdjustContrast` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        contrast_factor: O1,
        min_value: O2,
        max_value: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            images.into(),
            contrast_factor.into(),
            min_value.into(),
            max_value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        images: crate::Output,
        contrast_factor: crate::Output,
        min_value: crate::Output,
        max_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AdjustContrast", |nd| {
            nd.add_input(images);
            nd.add_input(contrast_factor);
            nd.add_input(min_value);
            nd.add_input(max_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AdjustContrast::new().build(images, contrast_factor, min_value, max_value, scope)`.
pub fn adjust_contrast<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    contrast_factor: O1,
    min_value: O2,
    max_value: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AdjustContrast::new().build(images, contrast_factor, min_value, max_value, scope)
}
/// Builder for the `AdjustContrastv2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AdjustContrastv2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AdjustContrastv2 {
    /// Creates a new `AdjustContrastv2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AdjustContrastv2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        contrast_factor: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), contrast_factor.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        contrast_factor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AdjustContrastv2", |nd| {
            nd.add_input(images);
            nd.add_input(contrast_factor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AdjustContrastv2::new().build(images, contrast_factor, scope)`.
pub fn adjust_contrastv2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    contrast_factor: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AdjustContrastv2::new().build(images, contrast_factor, scope)
}
/// Builder for the `AdjustHue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AdjustHue {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AdjustHue {
    /// Creates a new `AdjustHue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AdjustHue` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        delta: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), delta.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        delta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AdjustHue", |nd| {
            nd.add_input(images);
            nd.add_input(delta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AdjustHue::new().build(images, delta, scope)`.
pub fn adjust_hue<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    delta: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AdjustHue::new().build(images, delta, scope)
}
/// Builder for the `AdjustSaturation` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AdjustSaturation {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AdjustSaturation {
    /// Creates a new `AdjustSaturation`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AdjustSaturation` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        scale: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), scale.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        scale: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AdjustSaturation", |nd| {
            nd.add_input(images);
            nd.add_input(scale);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AdjustSaturation::new().build(images, scale, scope)`.
pub fn adjust_saturation<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    scale: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AdjustSaturation::new().build(images, scale, scope)
}
/// Builder for the `All` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct All {
    keep_dims: ::std::option::Option<bool>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl All {
    /// Creates a new `All`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `All` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("All", |nd| {
            nd.add_input(input);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `All::new().build(input, reduction_indices, scope)`.
pub fn all<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    All::new().build(input, reduction_indices, scope)
}
/// Builder for the `AllCandidateSampler` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AllCandidateSampler {
    num_true: ::std::option::Option<i64>,
    num_sampled: ::std::option::Option<i64>,
    unique: ::std::option::Option<bool>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AllCandidateSampler {
    /// Creates a new `AllCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_true` attribute.
    pub fn num_true<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_true = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sampled` attribute.
    pub fn num_sampled<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_sampled = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `unique` attribute.
    pub fn unique<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.unique = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AllCandidateSampler` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        true_classes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(true_classes.into(), scope)
    }

    fn build_impl(
        &self,
        true_classes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AllCandidateSampler", |nd| {
            nd.add_input(true_classes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_true {
                nd.set_attr_int("num_true", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sampled {
                nd.set_attr_int("num_sampled", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.unique {
                nd.set_attr_bool("unique", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AllCandidateSampler::new().build(true_classes, scope)`.
pub fn all_candidate_sampler<O0: ::std::convert::Into<crate::Output>>(
    true_classes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AllCandidateSampler::new().build(true_classes, scope)
}
/// Builder for the `AllToAll` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AllToAll {
    T: ::std::option::Option<crate::DataType>,
    concat_dimension: ::std::option::Option<i64>,
    split_dimension: ::std::option::Option<i64>,
    split_count: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AllToAll {
    /// Creates a new `AllToAll`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `concat_dimension` attribute.
    pub fn concat_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.concat_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `split_dimension` attribute.
    pub fn split_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.split_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `split_count` attribute.
    pub fn split_count<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.split_count = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AllToAll` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        group_assignment: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), group_assignment.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        group_assignment: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AllToAll", |nd| {
            nd.add_input(input);
            nd.add_input(group_assignment);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.concat_dimension {
                nd.set_attr_int("concat_dimension", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.split_dimension {
                nd.set_attr_int("split_dimension", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.split_count {
                nd.set_attr_int("split_count", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AllToAll::new().build(input, group_assignment, scope)`.
pub fn all_to_all<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    group_assignment: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AllToAll::new().build(input, group_assignment, scope)
}
/// Builder for the `Angle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Angle {
    T: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Angle {
    /// Creates a new `Angle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Angle` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Angle", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Angle::new().build(input, scope)`.
pub fn angle<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Angle::new().build(input, scope)
}
/// Builder for the `AnonymousIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousIterator {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AnonymousIterator {
    /// Creates a new `AnonymousIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AnonymousIterator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("AnonymousIterator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AnonymousIterator::new().build(scope)`.
pub fn anonymous_iterator(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    AnonymousIterator::new().build(scope)
}
/// Builder for the `AnonymousIteratorV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousIteratorV2 {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AnonymousIteratorV2 {
    /// Creates a new `AnonymousIteratorV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AnonymousIteratorV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("AnonymousIteratorV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AnonymousIteratorV2::new().build(scope)`.
pub fn anonymous_iterator_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    AnonymousIteratorV2::new().build(scope)
}
/// Builder for the `AnonymousMemoryCache` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousMemoryCache {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AnonymousMemoryCache {
    /// Creates a new `AnonymousMemoryCache`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AnonymousMemoryCache` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("AnonymousMemoryCache", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AnonymousMemoryCache::new().build(scope)`.
pub fn anonymous_memory_cache(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    AnonymousMemoryCache::new().build(scope)
}
/// Builder for the `AnonymousMultiDeviceIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousMultiDeviceIterator {
    devices: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AnonymousMultiDeviceIterator {
    /// Creates a new `AnonymousMultiDeviceIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `devices` attribute.
    pub fn devices<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.devices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AnonymousMultiDeviceIterator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("AnonymousMultiDeviceIterator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.devices {
                nd.set_attr_string_list("devices", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AnonymousMultiDeviceIterator::new().build(scope)`.
pub fn anonymous_multi_device_iterator(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AnonymousMultiDeviceIterator::new().build(scope)
}
/// Builder for the `AnonymousRandomSeedGenerator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousRandomSeedGenerator {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AnonymousRandomSeedGenerator {
    /// Creates a new `AnonymousRandomSeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AnonymousRandomSeedGenerator` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        seed: O0,
        seed2: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(seed.into(), seed2.into(), scope)
    }

    fn build_impl(
        &self,
        seed: crate::Output,
        seed2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AnonymousRandomSeedGenerator", |nd| {
            nd.add_input(seed);
            nd.add_input(seed2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AnonymousRandomSeedGenerator::new().build(seed, seed2, scope)`.
pub fn anonymous_random_seed_generator<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    seed: O0,
    seed2: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AnonymousRandomSeedGenerator::new().build(seed, seed2, scope)
}
/// Builder for the `AnonymousSeedGenerator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AnonymousSeedGenerator {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AnonymousSeedGenerator {
    /// Creates a new `AnonymousSeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AnonymousSeedGenerator` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        seed: O0,
        seed2: O1,
        reshuffle: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(seed.into(), seed2.into(), reshuffle.into(), scope)
    }

    fn build_impl(
        &self,
        seed: crate::Output,
        seed2: crate::Output,
        reshuffle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AnonymousSeedGenerator", |nd| {
            nd.add_input(seed);
            nd.add_input(seed2);
            nd.add_input(reshuffle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AnonymousSeedGenerator::new().build(seed, seed2, reshuffle, scope)`.
pub fn anonymous_seed_generator<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    seed: O0,
    seed2: O1,
    reshuffle: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AnonymousSeedGenerator::new().build(seed, seed2, reshuffle, scope)
}
/// Builder for the `Any` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Any {
    keep_dims: ::std::option::Option<bool>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Any {
    /// Creates a new `Any`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Any` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Any", |nd| {
            nd.add_input(input);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Any::new().build(input, reduction_indices, scope)`.
pub fn any<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Any::new().build(input, reduction_indices, scope)
}
/// Builder for the `ApplyAdaMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdaMax {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyAdaMax {
    /// Creates a new `ApplyAdaMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyAdaMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        v: O2,
        beta1_power: O3,
        lr: O4,
        beta1: O5,
        beta2: O6,
        epsilon: O7,
        grad: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            v.into(),
            beta1_power.into(),
            lr.into(),
            beta1.into(),
            beta2.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        v: crate::Output,
        beta1_power: crate::Output,
        lr: crate::Output,
        beta1: crate::Output,
        beta2: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyAdaMax", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(v);
            nd.add_input(beta1_power);
            nd.add_input(lr);
            nd.add_input(beta1);
            nd.add_input(beta2);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyAdaMax::new().build(var, m, v, beta1_power, lr, beta1, beta2, epsilon, grad, scope)`.
pub fn apply_ada_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    v: O2,
    beta1_power: O3,
    lr: O4,
    beta1: O5,
    beta2: O6,
    epsilon: O7,
    grad: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyAdaMax::new().build(
        var,
        m,
        v,
        beta1_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        scope,
    )
}
/// Builder for the `ApplyAdadelta` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdadelta {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyAdadelta {
    /// Creates a new `ApplyAdadelta`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyAdadelta` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        accum_update: O2,
        lr: O3,
        rho: O4,
        epsilon: O5,
        grad: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            accum_update.into(),
            lr.into(),
            rho.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        accum_update: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyAdadelta", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(accum_update);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyAdadelta::new().build(var, accum, accum_update, lr, rho, epsilon, grad, scope)`.
pub fn apply_adadelta<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    accum_update: O2,
    lr: O3,
    rho: O4,
    epsilon: O5,
    grad: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyAdadelta::new().build(var, accum, accum_update, lr, rho, epsilon, grad, scope)
}
/// Builder for the `ApplyAdagrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdagrad {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    update_slots: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyAdagrad {
    /// Creates a new `ApplyAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `update_slots` attribute.
    pub fn update_slots<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.update_slots = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyAdagrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(var.into(), accum.into(), lr.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyAdagrad", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.update_slots {
                nd.set_attr_bool("update_slots", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyAdagrad::new().build(var, accum, lr, grad, scope)`.
pub fn apply_adagrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyAdagrad::new().build(var, accum, lr, grad, scope)
}
/// Builder for the `ApplyAdagradDA` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdagradDA {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyAdagradDA {
    /// Creates a new `ApplyAdagradDA`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyAdagradDA` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        gradient_accumulator: O1,
        gradient_squared_accumulator: O2,
        grad: O3,
        lr: O4,
        l1: O5,
        l2: O6,
        global_step: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            gradient_accumulator.into(),
            gradient_squared_accumulator.into(),
            grad.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            global_step.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        gradient_accumulator: crate::Output,
        gradient_squared_accumulator: crate::Output,
        grad: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        global_step: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyAdagradDA", |nd| {
            nd.add_input(var);
            nd.add_input(gradient_accumulator);
            nd.add_input(gradient_squared_accumulator);
            nd.add_input(grad);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(global_step);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyAdagradDA::new().build(var, gradient_accumulator, gradient_squared_accumulator, grad, lr, l1, l2, global_step, scope)`.
pub fn apply_adagrad_da<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    gradient_accumulator: O1,
    gradient_squared_accumulator: O2,
    grad: O3,
    lr: O4,
    l1: O5,
    l2: O6,
    global_step: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyAdagradDA::new().build(
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        lr,
        l1,
        l2,
        global_step,
        scope,
    )
}
/// Builder for the `ApplyAdagradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdagradV2 {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    update_slots: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyAdagradV2 {
    /// Creates a new `ApplyAdagradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `update_slots` attribute.
    pub fn update_slots<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.update_slots = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyAdagradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        epsilon: O3,
        grad: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyAdagradV2", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.update_slots {
                nd.set_attr_bool("update_slots", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyAdagradV2::new().build(var, accum, lr, epsilon, grad, scope)`.
pub fn apply_adagrad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    epsilon: O3,
    grad: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyAdagradV2::new().build(var, accum, lr, epsilon, grad, scope)
}
/// Builder for the `ApplyAdam` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAdam {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    use_nesterov: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyAdam {
    /// Creates a new `ApplyAdam`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_nesterov` attribute.
    pub fn use_nesterov<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_nesterov = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyAdam` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        v: O2,
        beta1_power: O3,
        beta2_power: O4,
        lr: O5,
        beta1: O6,
        beta2: O7,
        epsilon: O8,
        grad: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            v.into(),
            beta1_power.into(),
            beta2_power.into(),
            lr.into(),
            beta1.into(),
            beta2.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        v: crate::Output,
        beta1_power: crate::Output,
        beta2_power: crate::Output,
        lr: crate::Output,
        beta1: crate::Output,
        beta2: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyAdam", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(v);
            nd.add_input(beta1_power);
            nd.add_input(beta2_power);
            nd.add_input(lr);
            nd.add_input(beta1);
            nd.add_input(beta2);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_nesterov {
                nd.set_attr_bool("use_nesterov", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyAdam::new().build(var, m, v, beta1_power, beta2_power, lr, beta1, beta2, epsilon, grad, scope)`.
pub fn apply_adam<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    v: O2,
    beta1_power: O3,
    beta2_power: O4,
    lr: O5,
    beta1: O6,
    beta2: O7,
    epsilon: O8,
    grad: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyAdam::new().build(
        var,
        m,
        v,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        scope,
    )
}
/// Builder for the `ApplyAddSign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyAddSign {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyAddSign {
    /// Creates a new `ApplyAddSign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyAddSign` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        lr: O2,
        alpha: O3,
        sign_decay: O4,
        beta: O5,
        grad: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            lr.into(),
            alpha.into(),
            sign_decay.into(),
            beta.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        lr: crate::Output,
        alpha: crate::Output,
        sign_decay: crate::Output,
        beta: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyAddSign", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(lr);
            nd.add_input(alpha);
            nd.add_input(sign_decay);
            nd.add_input(beta);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyAddSign::new().build(var, m, lr, alpha, sign_decay, beta, grad, scope)`.
pub fn apply_add_sign<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    lr: O2,
    alpha: O3,
    sign_decay: O4,
    beta: O5,
    grad: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyAddSign::new().build(var, m, lr, alpha, sign_decay, beta, grad, scope)
}
/// Builder for the `ApplyCenteredRMSProp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyCenteredRMSProp {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyCenteredRMSProp {
    /// Creates a new `ApplyCenteredRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyCenteredRMSProp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        mg: O1,
        ms: O2,
        mom: O3,
        lr: O4,
        rho: O5,
        momentum: O6,
        epsilon: O7,
        grad: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            mg.into(),
            ms.into(),
            mom.into(),
            lr.into(),
            rho.into(),
            momentum.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        mg: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        momentum: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyCenteredRMSProp", |nd| {
            nd.add_input(var);
            nd.add_input(mg);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(momentum);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyCenteredRMSProp::new().build(var, mg, ms, mom, lr, rho, momentum, epsilon, grad, scope)`.
pub fn apply_centered_rmsprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    mg: O1,
    ms: O2,
    mom: O3,
    lr: O4,
    rho: O5,
    momentum: O6,
    epsilon: O7,
    grad: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyCenteredRMSProp::new().build(var, mg, ms, mom, lr, rho, momentum, epsilon, grad, scope)
}
/// Builder for the `ApplyFtrl` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyFtrl {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    multiply_linear_by_lr: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyFtrl {
    /// Creates a new `ApplyFtrl`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `multiply_linear_by_lr` attribute.
    pub fn multiply_linear_by_lr<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.multiply_linear_by_lr = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyFtrl` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        linear: O2,
        grad: O3,
        lr: O4,
        l1: O5,
        l2: O6,
        lr_power: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            linear.into(),
            grad.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            lr_power.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        linear: crate::Output,
        grad: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        lr_power: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyFtrl", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(linear);
            nd.add_input(grad);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(lr_power);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.multiply_linear_by_lr {
                nd.set_attr_bool("multiply_linear_by_lr", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyFtrl::new().build(var, accum, linear, grad, lr, l1, l2, lr_power, scope)`.
pub fn apply_ftrl<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    linear: O2,
    grad: O3,
    lr: O4,
    l1: O5,
    l2: O6,
    lr_power: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyFtrl::new().build(var, accum, linear, grad, lr, l1, l2, lr_power, scope)
}
/// Builder for the `ApplyFtrlV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyFtrlV2 {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    multiply_linear_by_lr: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyFtrlV2 {
    /// Creates a new `ApplyFtrlV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `multiply_linear_by_lr` attribute.
    pub fn multiply_linear_by_lr<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.multiply_linear_by_lr = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyFtrlV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        linear: O2,
        grad: O3,
        lr: O4,
        l1: O5,
        l2: O6,
        l2_shrinkage: O7,
        lr_power: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            linear.into(),
            grad.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            l2_shrinkage.into(),
            lr_power.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        linear: crate::Output,
        grad: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        l2_shrinkage: crate::Output,
        lr_power: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyFtrlV2", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(linear);
            nd.add_input(grad);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(l2_shrinkage);
            nd.add_input(lr_power);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.multiply_linear_by_lr {
                nd.set_attr_bool("multiply_linear_by_lr", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyFtrlV2::new().build(var, accum, linear, grad, lr, l1, l2, l2_shrinkage, lr_power, scope)`.
pub fn apply_ftrl_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    linear: O2,
    grad: O3,
    lr: O4,
    l1: O5,
    l2: O6,
    l2_shrinkage: O7,
    lr_power: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyFtrlV2::new().build(
        var,
        accum,
        linear,
        grad,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        scope,
    )
}
/// Builder for the `ApplyGradientDescent` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyGradientDescent {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyGradientDescent {
    /// Creates a new `ApplyGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyGradientDescent` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        alpha: O1,
        delta: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(var.into(), alpha.into(), delta.into(), scope)
    }

    fn build_impl(
        &self,
        var: crate::Output,
        alpha: crate::Output,
        delta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyGradientDescent", |nd| {
            nd.add_input(var);
            nd.add_input(alpha);
            nd.add_input(delta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyGradientDescent::new().build(var, alpha, delta, scope)`.
pub fn apply_gradient_descent<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    alpha: O1,
    delta: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyGradientDescent::new().build(var, alpha, delta, scope)
}
/// Builder for the `ApplyMomentum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyMomentum {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    use_nesterov: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyMomentum {
    /// Creates a new `ApplyMomentum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_nesterov` attribute.
    pub fn use_nesterov<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_nesterov = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyMomentum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        momentum: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            grad.into(),
            momentum.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        momentum: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyMomentum", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            nd.add_input(momentum);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_nesterov {
                nd.set_attr_bool("use_nesterov", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyMomentum::new().build(var, accum, lr, grad, momentum, scope)`.
pub fn apply_momentum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    momentum: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyMomentum::new().build(var, accum, lr, grad, momentum, scope)
}
/// Builder for the `ApplyPowerSign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyPowerSign {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyPowerSign {
    /// Creates a new `ApplyPowerSign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyPowerSign` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        lr: O2,
        logbase: O3,
        sign_decay: O4,
        beta: O5,
        grad: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            lr.into(),
            logbase.into(),
            sign_decay.into(),
            beta.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        lr: crate::Output,
        logbase: crate::Output,
        sign_decay: crate::Output,
        beta: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyPowerSign", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(lr);
            nd.add_input(logbase);
            nd.add_input(sign_decay);
            nd.add_input(beta);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyPowerSign::new().build(var, m, lr, logbase, sign_decay, beta, grad, scope)`.
pub fn apply_power_sign<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    lr: O2,
    logbase: O3,
    sign_decay: O4,
    beta: O5,
    grad: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyPowerSign::new().build(var, m, lr, logbase, sign_decay, beta, grad, scope)
}
/// Builder for the `ApplyProximalAdagrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyProximalAdagrad {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyProximalAdagrad {
    /// Creates a new `ApplyProximalAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyProximalAdagrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        l1: O3,
        l2: O4,
        grad: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyProximalAdagrad", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyProximalAdagrad::new().build(var, accum, lr, l1, l2, grad, scope)`.
pub fn apply_proximal_adagrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    l1: O3,
    l2: O4,
    grad: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyProximalAdagrad::new().build(var, accum, lr, l1, l2, grad, scope)
}
/// Builder for the `ApplyProximalGradientDescent` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyProximalGradientDescent {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyProximalGradientDescent {
    /// Creates a new `ApplyProximalGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyProximalGradientDescent` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        alpha: O1,
        l1: O2,
        l2: O3,
        delta: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            alpha.into(),
            l1.into(),
            l2.into(),
            delta.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        alpha: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        delta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyProximalGradientDescent", |nd| {
            nd.add_input(var);
            nd.add_input(alpha);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(delta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyProximalGradientDescent::new().build(var, alpha, l1, l2, delta, scope)`.
pub fn apply_proximal_gradient_descent<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    alpha: O1,
    l1: O2,
    l2: O3,
    delta: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyProximalGradientDescent::new().build(var, alpha, l1, l2, delta, scope)
}
/// Builder for the `ApplyRMSProp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApplyRMSProp {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApplyRMSProp {
    /// Creates a new `ApplyRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApplyRMSProp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        ms: O1,
        mom: O2,
        lr: O3,
        rho: O4,
        momentum: O5,
        epsilon: O6,
        grad: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            ms.into(),
            mom.into(),
            lr.into(),
            rho.into(),
            momentum.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        momentum: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApplyRMSProp", |nd| {
            nd.add_input(var);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(momentum);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApplyRMSProp::new().build(var, ms, mom, lr, rho, momentum, epsilon, grad, scope)`.
pub fn apply_rmsprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    ms: O1,
    mom: O2,
    lr: O3,
    rho: O4,
    momentum: O5,
    epsilon: O6,
    grad: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApplyRMSProp::new().build(var, ms, mom, lr, rho, momentum, epsilon, grad, scope)
}
/// Builder for the `ApproximateEqual` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ApproximateEqual {
    T: ::std::option::Option<crate::DataType>,
    tolerance: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ApproximateEqual {
    /// Creates a new `ApproximateEqual`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tolerance` attribute.
    pub fn tolerance<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.tolerance = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ApproximateEqual` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ApproximateEqual", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tolerance {
                nd.set_attr_float("tolerance", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ApproximateEqual::new().build(x, y, scope)`.
pub fn approximate_equal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ApproximateEqual::new().build(x, y, scope)
}
/// Builder for the `ArgMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ArgMax {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    output_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ArgMax {
    /// Creates a new `ArgMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_type` attribute.
    pub fn output_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ArgMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        dimension: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), dimension.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        dimension: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ArgMax", |nd| {
            nd.add_input(input);
            nd.add_input(dimension);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_type {
                nd.set_attr_type("output_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ArgMax::new().build(input, dimension, scope)`.
pub fn arg_max<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    dimension: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ArgMax::new().build(input, dimension, scope)
}
/// Builder for the `ArgMin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ArgMin {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    output_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ArgMin {
    /// Creates a new `ArgMin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_type` attribute.
    pub fn output_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ArgMin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        dimension: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), dimension.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        dimension: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ArgMin", |nd| {
            nd.add_input(input);
            nd.add_input(dimension);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_type {
                nd.set_attr_type("output_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ArgMin::new().build(input, dimension, scope)`.
pub fn arg_min<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    dimension: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ArgMin::new().build(input, dimension, scope)
}
/// Builder for the `AsString` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AsString {
    T: ::std::option::Option<crate::DataType>,
    precision: ::std::option::Option<i64>,
    scientific: ::std::option::Option<bool>,
    shortest: ::std::option::Option<bool>,
    width: ::std::option::Option<i64>,
    fill: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AsString {
    /// Creates a new `AsString`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `precision` attribute.
    pub fn precision<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.precision = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `scientific` attribute.
    pub fn scientific<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.scientific = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shortest` attribute.
    pub fn shortest<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.shortest = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `width` attribute.
    pub fn width<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.width = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fill` attribute.
    pub fn fill<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.fill = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AsString` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AsString", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.precision {
                nd.set_attr_int("precision", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.scientific {
                nd.set_attr_bool("scientific", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shortest {
                nd.set_attr_bool("shortest", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.width {
                nd.set_attr_int("width", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fill {
                nd.set_attr_string("fill", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AsString::new().build(input, scope)`.
pub fn as_string<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AsString::new().build(input, scope)
}
/// Builder for the `Asin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Asin {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Asin {
    /// Creates a new `Asin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Asin` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Asin", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Asin::new().build(x, scope)`.
pub fn asin<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Asin::new().build(x, scope)
}
/// Builder for the `Asinh` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Asinh {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Asinh {
    /// Creates a new `Asinh`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Asinh` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Asinh", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Asinh::new().build(x, scope)`.
pub fn asinh<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Asinh::new().build(x, scope)
}
/// Builder for the `Assert` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Assert {
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    summarize: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Assert {
    /// Creates a new `Assert`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `summarize` attribute.
    pub fn summarize<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.summarize = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Assert` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        condition: O0,
        data: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(condition.into(), data.into(), scope)
    }

    fn build_impl(
        &self,
        condition: crate::Output,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Assert", |nd| {
            nd.add_input(condition);
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.summarize {
                nd.set_attr_int("summarize", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Assert::new().build(condition, data, scope)`.
pub fn assert<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    condition: O0,
    data: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Assert::new().build(condition, data, scope)
}
/// Builder for the `AssertCardinalityDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssertCardinalityDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AssertCardinalityDataset {
    /// Creates a new `AssertCardinalityDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AssertCardinalityDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        cardinality: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), cardinality.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        cardinality: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AssertCardinalityDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(cardinality);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AssertCardinalityDataset::new().build(input_dataset, cardinality, scope)`.
pub fn assert_cardinality_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    cardinality: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AssertCardinalityDataset::new().build(input_dataset, cardinality, scope)
}
/// Builder for the `AssertNextDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssertNextDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AssertNextDataset {
    /// Creates a new `AssertNextDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AssertNextDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        transformations: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), transformations.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        transformations: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AssertNextDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(transformations);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AssertNextDataset::new().build(input_dataset, transformations, scope)`.
pub fn assert_next_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    transformations: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AssertNextDataset::new().build(input_dataset, transformations, scope)
}
/// Builder for the `Assign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Assign {
    T: ::std::option::Option<crate::DataType>,
    validate_shape: ::std::option::Option<bool>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Assign {
    /// Creates a new `Assign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `validate_shape` attribute.
    pub fn validate_shape<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.validate_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Assign` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        value: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Assign", |nd| {
            nd.add_input(ref_);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.validate_shape {
                nd.set_attr_bool("validate_shape", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Assign::new().build(ref_, value, scope)`.
pub fn assign<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    ref_: O0,
    value: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Assign::new().build(ref_, value, scope)
}
/// Builder for the `AssignAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignAdd {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AssignAdd {
    /// Creates a new `AssignAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AssignAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        value: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AssignAdd", |nd| {
            nd.add_input(ref_);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AssignAdd::new().build(ref_, value, scope)`.
pub fn assign_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    value: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AssignAdd::new().build(ref_, value, scope)
}
/// Builder for the `AssignAddVariableOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignAddVariableOp {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AssignAddVariableOp {
    /// Creates a new `AssignAddVariableOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AssignAddVariableOp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        value: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AssignAddVariableOp", |nd| {
            nd.add_input(resource);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AssignAddVariableOp::new().build(resource, value, scope)`.
pub fn assign_add_variable_op<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    value: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AssignAddVariableOp::new().build(resource, value, scope)
}
/// Builder for the `AssignSub` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignSub {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AssignSub {
    /// Creates a new `AssignSub`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AssignSub` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        value: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AssignSub", |nd| {
            nd.add_input(ref_);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AssignSub::new().build(ref_, value, scope)`.
pub fn assign_sub<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    value: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AssignSub::new().build(ref_, value, scope)
}
/// Builder for the `AssignSubVariableOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignSubVariableOp {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AssignSubVariableOp {
    /// Creates a new `AssignSubVariableOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AssignSubVariableOp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        value: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AssignSubVariableOp", |nd| {
            nd.add_input(resource);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AssignSubVariableOp::new().build(resource, value, scope)`.
pub fn assign_sub_variable_op<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    value: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AssignSubVariableOp::new().build(resource, value, scope)
}
/// Builder for the `AssignVariableOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AssignVariableOp {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AssignVariableOp {
    /// Creates a new `AssignVariableOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AssignVariableOp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        value: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AssignVariableOp", |nd| {
            nd.add_input(resource);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AssignVariableOp::new().build(resource, value, scope)`.
pub fn assign_variable_op<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    value: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AssignVariableOp::new().build(resource, value, scope)
}
/// Builder for the `Atan` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Atan {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Atan {
    /// Creates a new `Atan`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Atan` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Atan", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Atan::new().build(x, scope)`.
pub fn atan<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Atan::new().build(x, scope)
}
/// Builder for the `Atan2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Atan2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Atan2 {
    /// Creates a new `Atan2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Atan2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y: O0,
        x: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(y.into(), x.into(), scope)
    }

    fn build_impl(
        &self,
        y: crate::Output,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Atan2", |nd| {
            nd.add_input(y);
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Atan2::new().build(y, x, scope)`.
pub fn atan2<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    y: O0,
    x: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Atan2::new().build(y, x, scope)
}
/// Builder for the `Atanh` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Atanh {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Atanh {
    /// Creates a new `Atanh`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Atanh` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Atanh", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Atanh::new().build(x, scope)`.
pub fn atanh<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Atanh::new().build(x, scope)
}
/// Builder for the `AudioSpectrogram` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AudioSpectrogram {
    window_size: ::std::option::Option<i64>,
    stride: ::std::option::Option<i64>,
    magnitude_squared: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AudioSpectrogram {
    /// Creates a new `AudioSpectrogram`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `window_size` attribute.
    pub fn window_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.window_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `stride` attribute.
    pub fn stride<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.stride = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `magnitude_squared` attribute.
    pub fn magnitude_squared<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.magnitude_squared = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AudioSpectrogram` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AudioSpectrogram", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.window_size {
                nd.set_attr_int("window_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.stride {
                nd.set_attr_int("stride", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.magnitude_squared {
                nd.set_attr_bool("magnitude_squared", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AudioSpectrogram::new().build(input, scope)`.
pub fn audio_spectrogram<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AudioSpectrogram::new().build(input, scope)
}
/// Builder for the `AudioSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AudioSummary {
    sample_rate: ::std::option::Option<f32>,
    max_outputs: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AudioSummary {
    /// Creates a new `AudioSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `sample_rate` attribute.
    pub fn sample_rate<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.sample_rate = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_outputs` attribute.
    pub fn max_outputs<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_outputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AudioSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tag: O0,
        tensor: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tag.into(), tensor.into(), scope)
    }

    fn build_impl(
        &self,
        tag: crate::Output,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AudioSummary", |nd| {
            nd.add_input(tag);
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.sample_rate {
                nd.set_attr_float("sample_rate", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_outputs {
                nd.set_attr_int("max_outputs", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AudioSummary::new().build(tag, tensor, scope)`.
pub fn audio_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tag: O0,
    tensor: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AudioSummary::new().build(tag, tensor, scope)
}
/// Builder for the `AudioSummaryV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AudioSummaryV2 {
    max_outputs: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AudioSummaryV2 {
    /// Creates a new `AudioSummaryV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_outputs` attribute.
    pub fn max_outputs<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_outputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AudioSummaryV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tag: O0,
        tensor: O1,
        sample_rate: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tag.into(), tensor.into(), sample_rate.into(), scope)
    }

    fn build_impl(
        &self,
        tag: crate::Output,
        tensor: crate::Output,
        sample_rate: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AudioSummaryV2", |nd| {
            nd.add_input(tag);
            nd.add_input(tensor);
            nd.add_input(sample_rate);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_outputs {
                nd.set_attr_int("max_outputs", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AudioSummaryV2::new().build(tag, tensor, sample_rate, scope)`.
pub fn audio_summary_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tag: O0,
    tensor: O1,
    sample_rate: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AudioSummaryV2::new().build(tag, tensor, sample_rate, scope)
}
/// Builder for the `AutoShardDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AutoShardDataset {
    auto_shard_policy: ::std::option::Option<i64>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AutoShardDataset {
    /// Creates a new `AutoShardDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `auto_shard_policy` attribute.
    pub fn auto_shard_policy<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.auto_shard_policy = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AutoShardDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_workers: O1,
        index: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            num_workers.into(),
            index.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_workers: crate::Output,
        index: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AutoShardDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_workers);
            nd.add_input(index);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.auto_shard_policy {
                nd.set_attr_int("auto_shard_policy", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AutoShardDataset::new().build(input_dataset, num_workers, index, scope)`.
pub fn auto_shard_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_workers: O1,
    index: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AutoShardDataset::new().build(input_dataset, num_workers, index, scope)
}
/// Builder for the `AvgPool` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AvgPool {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AvgPool {
    /// Creates a new `AvgPool`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AvgPool` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        value: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AvgPool", |nd| {
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AvgPool::new().build(value, scope)`.
pub fn avg_pool<O0: ::std::convert::Into<crate::Output>>(
    value: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AvgPool::new().build(value, scope)
}
/// Builder for the `AvgPool3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AvgPool3D {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AvgPool3D {
    /// Creates a new `AvgPool3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AvgPool3D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AvgPool3D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AvgPool3D::new().build(input, scope)`.
pub fn avg_pool3_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AvgPool3D::new().build(input, scope)
}
/// Builder for the `AvgPool3DGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AvgPool3DGrad {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AvgPool3DGrad {
    /// Creates a new `AvgPool3DGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AvgPool3DGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input_shape: O0,
        grad: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(orig_input_shape.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        orig_input_shape: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AvgPool3DGrad", |nd| {
            nd.add_input(orig_input_shape);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AvgPool3DGrad::new().build(orig_input_shape, grad, scope)`.
pub fn avg_pool3_dgrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    orig_input_shape: O0,
    grad: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AvgPool3DGrad::new().build(orig_input_shape, grad, scope)
}
/// Builder for the `AvgPoolGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct AvgPoolGrad {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl AvgPoolGrad {
    /// Creates a new `AvgPoolGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `AvgPoolGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input_shape: O0,
        grad: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(orig_input_shape.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        orig_input_shape: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("AvgPoolGrad", |nd| {
            nd.add_input(orig_input_shape);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `AvgPoolGrad::new().build(orig_input_shape, grad, scope)`.
pub fn avg_pool_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    orig_input_shape: O0,
    grad: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    AvgPoolGrad::new().build(orig_input_shape, grad, scope)
}
/// Builder for the `BandedTriangularSolve` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BandedTriangularSolve {
    lower: ::std::option::Option<bool>,
    adjoint: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BandedTriangularSolve {
    /// Creates a new `BandedTriangularSolve`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `lower` attribute.
    pub fn lower<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.lower = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint` attribute.
    pub fn adjoint<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BandedTriangularSolve` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        matrix: O0,
        rhs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(matrix.into(), rhs.into(), scope)
    }

    fn build_impl(
        &self,
        matrix: crate::Output,
        rhs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BandedTriangularSolve", |nd| {
            nd.add_input(matrix);
            nd.add_input(rhs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.lower {
                nd.set_attr_bool("lower", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint {
                nd.set_attr_bool("adjoint", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BandedTriangularSolve::new().build(matrix, rhs, scope)`.
pub fn banded_triangular_solve<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    matrix: O0,
    rhs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BandedTriangularSolve::new().build(matrix, rhs, scope)
}
/// Builder for the `Barrier` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Barrier {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Barrier {
    /// Creates a new `Barrier`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Barrier` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Barrier", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Barrier::new().build(scope)`.
pub fn barrier(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Barrier::new().build(scope)
}
/// Builder for the `BarrierClose` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierClose {
    cancel_pending_enqueues: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BarrierClose {
    /// Creates a new `BarrierClose`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `cancel_pending_enqueues` attribute.
    pub fn cancel_pending_enqueues<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.cancel_pending_enqueues = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BarrierClose` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BarrierClose", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.cancel_pending_enqueues {
                nd.set_attr_bool("cancel_pending_enqueues", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BarrierClose::new().build(handle, scope)`.
pub fn barrier_close<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BarrierClose::new().build(handle, scope)
}
/// Builder for the `BarrierIncompleteSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierIncompleteSize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BarrierIncompleteSize {
    /// Creates a new `BarrierIncompleteSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BarrierIncompleteSize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BarrierIncompleteSize", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BarrierIncompleteSize::new().build(handle, scope)`.
pub fn barrier_incomplete_size<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BarrierIncompleteSize::new().build(handle, scope)
}
/// Builder for the `BarrierInsertMany` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierInsertMany {
    T: ::std::option::Option<crate::DataType>,
    component_index: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BarrierInsertMany {
    /// Creates a new `BarrierInsertMany`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `component_index` attribute.
    pub fn component_index<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.component_index = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BarrierInsertMany` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        keys: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), keys.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        keys: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BarrierInsertMany", |nd| {
            nd.add_input(handle);
            nd.add_input(keys);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.component_index {
                nd.set_attr_int("component_index", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BarrierInsertMany::new().build(handle, keys, values, scope)`.
pub fn barrier_insert_many<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    keys: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BarrierInsertMany::new().build(handle, keys, values, scope)
}
/// Builder for the `BarrierReadySize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierReadySize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BarrierReadySize {
    /// Creates a new `BarrierReadySize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BarrierReadySize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BarrierReadySize", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BarrierReadySize::new().build(handle, scope)`.
pub fn barrier_ready_size<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BarrierReadySize::new().build(handle, scope)
}
/// Builder for the `BarrierTakeMany` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BarrierTakeMany {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    allow_small_batch: ::std::option::Option<bool>,
    wait_for_incomplete: ::std::option::Option<bool>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BarrierTakeMany {
    /// Creates a new `BarrierTakeMany`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `allow_small_batch` attribute.
    pub fn allow_small_batch<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.allow_small_batch = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `wait_for_incomplete` attribute.
    pub fn wait_for_incomplete<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.wait_for_incomplete = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BarrierTakeMany` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        num_elements: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), num_elements.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        num_elements: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BarrierTakeMany", |nd| {
            nd.add_input(handle);
            nd.add_input(num_elements);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.allow_small_batch {
                nd.set_attr_bool("allow_small_batch", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.wait_for_incomplete {
                nd.set_attr_bool("wait_for_incomplete", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BarrierTakeMany::new().build(handle, num_elements, scope)`.
pub fn barrier_take_many<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    num_elements: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BarrierTakeMany::new().build(handle, num_elements, scope)
}
/// Builder for the `Batch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Batch {
    num_batch_threads: ::std::option::Option<i64>,
    max_batch_size: ::std::option::Option<i64>,
    max_enqueued_batches: ::std::option::Option<i64>,
    batch_timeout_micros: ::std::option::Option<i64>,
    allowed_batch_sizes: ::std::option::Option<::std::vec::Vec<i64>>,
    grad_timeout_micros: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    batching_queue: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Batch {
    /// Creates a new `Batch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_batch_threads` attribute.
    pub fn num_batch_threads<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_batch_threads = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_batch_size` attribute.
    pub fn max_batch_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_batch_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_enqueued_batches` attribute.
    pub fn max_enqueued_batches<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.max_enqueued_batches = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `batch_timeout_micros` attribute.
    pub fn batch_timeout_micros<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.batch_timeout_micros = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `allowed_batch_sizes` attribute.
    pub fn allowed_batch_sizes<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.allowed_batch_sizes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `grad_timeout_micros` attribute.
    pub fn grad_timeout_micros<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.grad_timeout_micros = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `batching_queue` attribute.
    pub fn batching_queue<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.batching_queue = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Batch` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        in_tensors: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(in_tensors.into(), scope)
    }

    fn build_impl(
        &self,
        in_tensors: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Batch", |nd| {
            nd.add_input(in_tensors);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_batch_threads {
                nd.set_attr_int("num_batch_threads", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_batch_size {
                nd.set_attr_int("max_batch_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_enqueued_batches {
                nd.set_attr_int("max_enqueued_batches", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.batch_timeout_micros {
                nd.set_attr_int("batch_timeout_micros", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.allowed_batch_sizes {
                nd.set_attr_int_list("allowed_batch_sizes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.grad_timeout_micros {
                nd.set_attr_int("grad_timeout_micros", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.batching_queue {
                nd.set_attr_string("batching_queue", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Batch::new().build(in_tensors, scope)`.
pub fn batch<O0: ::std::convert::Into<crate::Output>>(
    in_tensors: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Batch::new().build(in_tensors, scope)
}
/// Builder for the `BatchCholesky` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchCholesky {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchCholesky {
    /// Creates a new `BatchCholesky`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchCholesky` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchCholesky", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchCholesky::new().build(input, scope)`.
pub fn batch_cholesky<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchCholesky::new().build(input, scope)
}
/// Builder for the `BatchCholeskyGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchCholeskyGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchCholeskyGrad {
    /// Creates a new `BatchCholeskyGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchCholeskyGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        l: O0,
        grad: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(l.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        l: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchCholeskyGrad", |nd| {
            nd.add_input(l);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchCholeskyGrad::new().build(l, grad, scope)`.
pub fn batch_cholesky_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    l: O0,
    grad: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchCholeskyGrad::new().build(l, grad, scope)
}
/// Builder for the `BatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchDataset {
    /// Creates a new `BatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        batch_size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), batch_size.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        batch_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(batch_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchDataset::new().build(input_dataset, batch_size, scope)`.
pub fn batch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    batch_size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchDataset::new().build(input_dataset, batch_size, scope)
}
/// Builder for the `BatchDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchDatasetV2 {
    parallel_copy: ::std::option::Option<bool>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchDatasetV2 {
    /// Creates a new `BatchDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `parallel_copy` attribute.
    pub fn parallel_copy<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.parallel_copy = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        batch_size: O1,
        drop_remainder: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            batch_size.into(),
            drop_remainder.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        batch_size: crate::Output,
        drop_remainder: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(batch_size);
            nd.add_input(drop_remainder);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.parallel_copy {
                nd.set_attr_bool("parallel_copy", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchDatasetV2::new().build(input_dataset, batch_size, drop_remainder, scope)`.
pub fn batch_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    batch_size: O1,
    drop_remainder: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchDatasetV2::new().build(input_dataset, batch_size, drop_remainder, scope)
}
/// Builder for the `BatchFFT` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchFFT {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchFFT {
    /// Creates a new `BatchFFT`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchFFT` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchFFT", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchFFT::new().build(input, scope)`.
pub fn batch_fft<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchFFT::new().build(input, scope)
}
/// Builder for the `BatchFFT2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchFFT2D {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchFFT2D {
    /// Creates a new `BatchFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchFFT2D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchFFT2D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchFFT2D::new().build(input, scope)`.
pub fn batch_fft2_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchFFT2D::new().build(input, scope)
}
/// Builder for the `BatchFFT3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchFFT3D {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchFFT3D {
    /// Creates a new `BatchFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchFFT3D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchFFT3D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchFFT3D::new().build(input, scope)`.
pub fn batch_fft3_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchFFT3D::new().build(input, scope)
}
/// Builder for the `BatchFunction` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchFunction {
    f: ::std::option::Option<::std::string::String>,
    num_batch_threads: ::std::option::Option<i64>,
    max_batch_size: ::std::option::Option<i64>,
    batch_timeout_micros: ::std::option::Option<i64>,
    max_enqueued_batches: ::std::option::Option<i64>,
    allowed_batch_sizes: ::std::option::Option<::std::vec::Vec<i64>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    batching_queue: ::std::option::Option<::std::string::String>,
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tcaptured: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    enable_large_batch_splitting: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchFunction {
    /// Creates a new `BatchFunction`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_batch_threads` attribute.
    pub fn num_batch_threads<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_batch_threads = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_batch_size` attribute.
    pub fn max_batch_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_batch_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `batch_timeout_micros` attribute.
    pub fn batch_timeout_micros<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.batch_timeout_micros = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_enqueued_batches` attribute.
    pub fn max_enqueued_batches<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.max_enqueued_batches = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `allowed_batch_sizes` attribute.
    pub fn allowed_batch_sizes<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.allowed_batch_sizes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `batching_queue` attribute.
    pub fn batching_queue<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.batching_queue = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcaptured` attribute.
    pub fn Tcaptured<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcaptured = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `enable_large_batch_splitting` attribute.
    pub fn enable_large_batch_splitting<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.enable_large_batch_splitting = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchFunction` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        in_tensors: O0,
        captured_tensors: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(in_tensors.into(), captured_tensors.into(), scope)
    }

    fn build_impl(
        &self,
        in_tensors: crate::Output,
        captured_tensors: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchFunction", |nd| {
            nd.add_input(in_tensors);
            nd.add_input(captured_tensors);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_batch_threads {
                nd.set_attr_int("num_batch_threads", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_batch_size {
                nd.set_attr_int("max_batch_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.batch_timeout_micros {
                nd.set_attr_int("batch_timeout_micros", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_enqueued_batches {
                nd.set_attr_int("max_enqueued_batches", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.allowed_batch_sizes {
                nd.set_attr_int_list("allowed_batch_sizes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.batching_queue {
                nd.set_attr_string("batching_queue", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcaptured {
                nd.set_attr_type_list("Tcaptured", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.enable_large_batch_splitting {
                nd.set_attr_bool("enable_large_batch_splitting", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchFunction::new().build(in_tensors, captured_tensors, scope)`.
pub fn batch_function<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    in_tensors: O0,
    captured_tensors: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchFunction::new().build(in_tensors, captured_tensors, scope)
}
/// Builder for the `BatchIFFT` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchIFFT {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchIFFT {
    /// Creates a new `BatchIFFT`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchIFFT` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchIFFT", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchIFFT::new().build(input, scope)`.
pub fn batch_ifft<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchIFFT::new().build(input, scope)
}
/// Builder for the `BatchIFFT2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchIFFT2D {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchIFFT2D {
    /// Creates a new `BatchIFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchIFFT2D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchIFFT2D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchIFFT2D::new().build(input, scope)`.
pub fn batch_ifft2_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchIFFT2D::new().build(input, scope)
}
/// Builder for the `BatchIFFT3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchIFFT3D {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchIFFT3D {
    /// Creates a new `BatchIFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchIFFT3D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchIFFT3D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchIFFT3D::new().build(input, scope)`.
pub fn batch_ifft3_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchIFFT3D::new().build(input, scope)
}
/// Builder for the `BatchMatMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatMul {
    T: ::std::option::Option<crate::DataType>,
    adj_x: ::std::option::Option<bool>,
    adj_y: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatMul {
    /// Creates a new `BatchMatMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adj_x` attribute.
    pub fn adj_x<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adj_x = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adj_y` attribute.
    pub fn adj_y<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adj_y = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatMul", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adj_x {
                nd.set_attr_bool("adj_x", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adj_y {
                nd.set_attr_bool("adj_y", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatMul::new().build(x, y, scope)`.
pub fn batch_mat_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatMul::new().build(x, y, scope)
}
/// Builder for the `BatchMatMulV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatMulV2 {
    T: ::std::option::Option<crate::DataType>,
    adj_x: ::std::option::Option<bool>,
    adj_y: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatMulV2 {
    /// Creates a new `BatchMatMulV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adj_x` attribute.
    pub fn adj_x<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adj_x = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adj_y` attribute.
    pub fn adj_y<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adj_y = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatMulV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatMulV2", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adj_x {
                nd.set_attr_bool("adj_x", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adj_y {
                nd.set_attr_bool("adj_y", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatMulV2::new().build(x, y, scope)`.
pub fn batch_mat_mul_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatMulV2::new().build(x, y, scope)
}
/// Builder for the `BatchMatrixBandPart` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixBandPart {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixBandPart {
    /// Creates a new `BatchMatrixBandPart`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixBandPart` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        num_lower: O1,
        num_upper: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), num_lower.into(), num_upper.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        num_lower: crate::Output,
        num_upper: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixBandPart", |nd| {
            nd.add_input(input);
            nd.add_input(num_lower);
            nd.add_input(num_upper);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixBandPart::new().build(input, num_lower, num_upper, scope)`.
pub fn batch_matrix_band_part<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    num_lower: O1,
    num_upper: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixBandPart::new().build(input, num_lower, num_upper, scope)
}
/// Builder for the `BatchMatrixDeterminant` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixDeterminant {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixDeterminant {
    /// Creates a new `BatchMatrixDeterminant`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixDeterminant` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixDeterminant", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixDeterminant::new().build(input, scope)`.
pub fn batch_matrix_determinant<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixDeterminant::new().build(input, scope)
}
/// Builder for the `BatchMatrixDiag` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixDiag {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixDiag {
    /// Creates a new `BatchMatrixDiag`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixDiag` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        diagonal: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(diagonal.into(), scope)
    }

    fn build_impl(
        &self,
        diagonal: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixDiag", |nd| {
            nd.add_input(diagonal);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixDiag::new().build(diagonal, scope)`.
pub fn batch_matrix_diag<O0: ::std::convert::Into<crate::Output>>(
    diagonal: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixDiag::new().build(diagonal, scope)
}
/// Builder for the `BatchMatrixDiagPart` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixDiagPart {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixDiagPart {
    /// Creates a new `BatchMatrixDiagPart`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixDiagPart` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixDiagPart", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixDiagPart::new().build(input, scope)`.
pub fn batch_matrix_diag_part<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixDiagPart::new().build(input, scope)
}
/// Builder for the `BatchMatrixInverse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixInverse {
    adjoint: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixInverse {
    /// Creates a new `BatchMatrixInverse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `adjoint` attribute.
    pub fn adjoint<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixInverse` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixInverse", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.adjoint {
                nd.set_attr_bool("adjoint", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixInverse::new().build(input, scope)`.
pub fn batch_matrix_inverse<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixInverse::new().build(input, scope)
}
/// Builder for the `BatchMatrixSetDiag` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixSetDiag {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixSetDiag {
    /// Creates a new `BatchMatrixSetDiag`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixSetDiag` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        diagonal: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), diagonal.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        diagonal: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixSetDiag", |nd| {
            nd.add_input(input);
            nd.add_input(diagonal);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixSetDiag::new().build(input, diagonal, scope)`.
pub fn batch_matrix_set_diag<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    diagonal: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixSetDiag::new().build(input, diagonal, scope)
}
/// Builder for the `BatchMatrixSolve` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixSolve {
    adjoint: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixSolve {
    /// Creates a new `BatchMatrixSolve`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `adjoint` attribute.
    pub fn adjoint<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixSolve` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        matrix: O0,
        rhs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(matrix.into(), rhs.into(), scope)
    }

    fn build_impl(
        &self,
        matrix: crate::Output,
        rhs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixSolve", |nd| {
            nd.add_input(matrix);
            nd.add_input(rhs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.adjoint {
                nd.set_attr_bool("adjoint", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixSolve::new().build(matrix, rhs, scope)`.
pub fn batch_matrix_solve<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    matrix: O0,
    rhs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixSolve::new().build(matrix, rhs, scope)
}
/// Builder for the `BatchMatrixSolveLs` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixSolveLs {
    T: ::std::option::Option<crate::DataType>,
    fast: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixSolveLs {
    /// Creates a new `BatchMatrixSolveLs`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fast` attribute.
    pub fn fast<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.fast = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixSolveLs` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        matrix: O0,
        rhs: O1,
        l2_regularizer: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(matrix.into(), rhs.into(), l2_regularizer.into(), scope)
    }

    fn build_impl(
        &self,
        matrix: crate::Output,
        rhs: crate::Output,
        l2_regularizer: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixSolveLs", |nd| {
            nd.add_input(matrix);
            nd.add_input(rhs);
            nd.add_input(l2_regularizer);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fast {
                nd.set_attr_bool("fast", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixSolveLs::new().build(matrix, rhs, l2_regularizer, scope)`.
pub fn batch_matrix_solve_ls<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    matrix: O0,
    rhs: O1,
    l2_regularizer: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixSolveLs::new().build(matrix, rhs, l2_regularizer, scope)
}
/// Builder for the `BatchMatrixTriangularSolve` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchMatrixTriangularSolve {
    lower: ::std::option::Option<bool>,
    adjoint: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchMatrixTriangularSolve {
    /// Creates a new `BatchMatrixTriangularSolve`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `lower` attribute.
    pub fn lower<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.lower = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint` attribute.
    pub fn adjoint<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchMatrixTriangularSolve` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        matrix: O0,
        rhs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(matrix.into(), rhs.into(), scope)
    }

    fn build_impl(
        &self,
        matrix: crate::Output,
        rhs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchMatrixTriangularSolve", |nd| {
            nd.add_input(matrix);
            nd.add_input(rhs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.lower {
                nd.set_attr_bool("lower", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint {
                nd.set_attr_bool("adjoint", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchMatrixTriangularSolve::new().build(matrix, rhs, scope)`.
pub fn batch_matrix_triangular_solve<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    matrix: O0,
    rhs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchMatrixTriangularSolve::new().build(matrix, rhs, scope)
}
/// Builder for the `BatchNormWithGlobalNormalization` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchNormWithGlobalNormalization {
    T: ::std::option::Option<crate::DataType>,
    variance_epsilon: ::std::option::Option<f32>,
    scale_after_normalization: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchNormWithGlobalNormalization {
    /// Creates a new `BatchNormWithGlobalNormalization`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `variance_epsilon` attribute.
    pub fn variance_epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.variance_epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `scale_after_normalization` attribute.
    pub fn scale_after_normalization<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.scale_after_normalization = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchNormWithGlobalNormalization` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        t: O0,
        m: O1,
        v: O2,
        beta: O3,
        gamma: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            t.into(),
            m.into(),
            v.into(),
            beta.into(),
            gamma.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        t: crate::Output,
        m: crate::Output,
        v: crate::Output,
        beta: crate::Output,
        gamma: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchNormWithGlobalNormalization", |nd| {
            nd.add_input(t);
            nd.add_input(m);
            nd.add_input(v);
            nd.add_input(beta);
            nd.add_input(gamma);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.variance_epsilon {
                nd.set_attr_float("variance_epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.scale_after_normalization {
                nd.set_attr_bool("scale_after_normalization", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchNormWithGlobalNormalization::new().build(t, m, v, beta, gamma, scope)`.
pub fn batch_norm_with_global_normalization<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    t: O0,
    m: O1,
    v: O2,
    beta: O3,
    gamma: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchNormWithGlobalNormalization::new().build(t, m, v, beta, gamma, scope)
}
/// Builder for the `BatchNormWithGlobalNormalizationGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchNormWithGlobalNormalizationGrad {
    T: ::std::option::Option<crate::DataType>,
    variance_epsilon: ::std::option::Option<f32>,
    scale_after_normalization: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchNormWithGlobalNormalizationGrad {
    /// Creates a new `BatchNormWithGlobalNormalizationGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `variance_epsilon` attribute.
    pub fn variance_epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.variance_epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `scale_after_normalization` attribute.
    pub fn scale_after_normalization<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.scale_after_normalization = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchNormWithGlobalNormalizationGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        t: O0,
        m: O1,
        v: O2,
        gamma: O3,
        backprop: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            t.into(),
            m.into(),
            v.into(),
            gamma.into(),
            backprop.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        t: crate::Output,
        m: crate::Output,
        v: crate::Output,
        gamma: crate::Output,
        backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchNormWithGlobalNormalizationGrad", |nd| {
            nd.add_input(t);
            nd.add_input(m);
            nd.add_input(v);
            nd.add_input(gamma);
            nd.add_input(backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.variance_epsilon {
                nd.set_attr_float("variance_epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.scale_after_normalization {
                nd.set_attr_bool("scale_after_normalization", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchNormWithGlobalNormalizationGrad::new().build(t, m, v, gamma, backprop, scope)`.
pub fn batch_norm_with_global_normalization_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    t: O0,
    m: O1,
    v: O2,
    gamma: O3,
    backprop: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchNormWithGlobalNormalizationGrad::new().build(t, m, v, gamma, backprop, scope)
}
/// Builder for the `BatchSelfAdjointEig` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchSelfAdjointEig {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchSelfAdjointEig {
    /// Creates a new `BatchSelfAdjointEig`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchSelfAdjointEig` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchSelfAdjointEig", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchSelfAdjointEig::new().build(input, scope)`.
pub fn batch_self_adjoint_eig<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchSelfAdjointEig::new().build(input, scope)
}
/// Builder for the `BatchSelfAdjointEigV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchSelfAdjointEigV2 {
    compute_v: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchSelfAdjointEigV2 {
    /// Creates a new `BatchSelfAdjointEigV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `compute_v` attribute.
    pub fn compute_v<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.compute_v = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchSelfAdjointEigV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchSelfAdjointEigV2", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.compute_v {
                nd.set_attr_bool("compute_v", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchSelfAdjointEigV2::new().build(input, scope)`.
pub fn batch_self_adjoint_eig_v2<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchSelfAdjointEigV2::new().build(input, scope)
}
/// Builder for the `BatchSvd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchSvd {
    compute_uv: ::std::option::Option<bool>,
    full_matrices: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchSvd {
    /// Creates a new `BatchSvd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `compute_uv` attribute.
    pub fn compute_uv<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.compute_uv = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `full_matrices` attribute.
    pub fn full_matrices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.full_matrices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchSvd` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchSvd", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.compute_uv {
                nd.set_attr_bool("compute_uv", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.full_matrices {
                nd.set_attr_bool("full_matrices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchSvd::new().build(input, scope)`.
pub fn batch_svd<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchSvd::new().build(input, scope)
}
/// Builder for the `BatchToSpace` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchToSpace {
    T: ::std::option::Option<crate::DataType>,
    block_size: ::std::option::Option<i64>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchToSpace {
    /// Creates a new `BatchToSpace`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `block_size` attribute.
    pub fn block_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.block_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchToSpace` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        crops: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), crops.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        crops: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchToSpace", |nd| {
            nd.add_input(input);
            nd.add_input(crops);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.block_size {
                nd.set_attr_int("block_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchToSpace::new().build(input, crops, scope)`.
pub fn batch_to_space<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    crops: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchToSpace::new().build(input, crops, scope)
}
/// Builder for the `BatchToSpaceND` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BatchToSpaceND {
    T: ::std::option::Option<crate::DataType>,
    Tblock_shape: ::std::option::Option<crate::DataType>,
    Tcrops: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BatchToSpaceND {
    /// Creates a new `BatchToSpaceND`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tblock_shape` attribute.
    pub fn Tblock_shape<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tblock_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcrops` attribute.
    pub fn Tcrops<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcrops = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BatchToSpaceND` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        block_shape: O1,
        crops: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), block_shape.into(), crops.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        block_shape: crate::Output,
        crops: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BatchToSpaceND", |nd| {
            nd.add_input(input);
            nd.add_input(block_shape);
            nd.add_input(crops);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tblock_shape {
                nd.set_attr_type("Tblock_shape", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcrops {
                nd.set_attr_type("Tcrops", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BatchToSpaceND::new().build(input, block_shape, crops, scope)`.
pub fn batch_to_space_nd<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    block_shape: O1,
    crops: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BatchToSpaceND::new().build(input, block_shape, crops, scope)
}
/// Builder for the `BesselI0` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselI0 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselI0 {
    /// Creates a new `BesselI0`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselI0` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselI0", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselI0::new().build(x, scope)`.
pub fn bessel_i0<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselI0::new().build(x, scope)
}
/// Builder for the `BesselI0e` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselI0e {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselI0e {
    /// Creates a new `BesselI0e`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselI0e` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselI0e", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselI0e::new().build(x, scope)`.
pub fn bessel_i0e<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselI0e::new().build(x, scope)
}
/// Builder for the `BesselI1` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselI1 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselI1 {
    /// Creates a new `BesselI1`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselI1` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselI1", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselI1::new().build(x, scope)`.
pub fn bessel_i1<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselI1::new().build(x, scope)
}
/// Builder for the `BesselI1e` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselI1e {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselI1e {
    /// Creates a new `BesselI1e`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselI1e` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselI1e", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselI1e::new().build(x, scope)`.
pub fn bessel_i1e<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselI1e::new().build(x, scope)
}
/// Builder for the `BesselJ0` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselJ0 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselJ0 {
    /// Creates a new `BesselJ0`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselJ0` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselJ0", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselJ0::new().build(x, scope)`.
pub fn bessel_j0<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselJ0::new().build(x, scope)
}
/// Builder for the `BesselJ1` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselJ1 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselJ1 {
    /// Creates a new `BesselJ1`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselJ1` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselJ1", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselJ1::new().build(x, scope)`.
pub fn bessel_j1<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselJ1::new().build(x, scope)
}
/// Builder for the `BesselK0` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselK0 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselK0 {
    /// Creates a new `BesselK0`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselK0` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselK0", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselK0::new().build(x, scope)`.
pub fn bessel_k0<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselK0::new().build(x, scope)
}
/// Builder for the `BesselK0e` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselK0e {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselK0e {
    /// Creates a new `BesselK0e`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselK0e` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselK0e", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselK0e::new().build(x, scope)`.
pub fn bessel_k0e<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselK0e::new().build(x, scope)
}
/// Builder for the `BesselK1` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselK1 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselK1 {
    /// Creates a new `BesselK1`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselK1` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselK1", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselK1::new().build(x, scope)`.
pub fn bessel_k1<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselK1::new().build(x, scope)
}
/// Builder for the `BesselK1e` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselK1e {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselK1e {
    /// Creates a new `BesselK1e`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselK1e` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselK1e", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselK1e::new().build(x, scope)`.
pub fn bessel_k1e<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselK1e::new().build(x, scope)
}
/// Builder for the `BesselY0` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselY0 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselY0 {
    /// Creates a new `BesselY0`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselY0` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselY0", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselY0::new().build(x, scope)`.
pub fn bessel_y0<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselY0::new().build(x, scope)
}
/// Builder for the `BesselY1` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BesselY1 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BesselY1 {
    /// Creates a new `BesselY1`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BesselY1` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BesselY1", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BesselY1::new().build(x, scope)`.
pub fn bessel_y1<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BesselY1::new().build(x, scope)
}
/// Builder for the `Betainc` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Betainc {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Betainc {
    /// Creates a new `Betainc`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Betainc` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        x: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), b.into(), x.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Betainc", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Betainc::new().build(a, b, x, scope)`.
pub fn betainc<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    x: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Betainc::new().build(a, b, x, scope)
}
/// Builder for the `BiasAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BiasAdd {
    T: ::std::option::Option<crate::DataType>,
    data_format: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BiasAdd {
    /// Creates a new `BiasAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BiasAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        value: O0,
        bias: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), bias.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        bias: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BiasAdd", |nd| {
            nd.add_input(value);
            nd.add_input(bias);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BiasAdd::new().build(value, bias, scope)`.
pub fn bias_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    value: O0,
    bias: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BiasAdd::new().build(value, bias, scope)
}
/// Builder for the `BiasAddGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BiasAddGrad {
    T: ::std::option::Option<crate::DataType>,
    data_format: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BiasAddGrad {
    /// Creates a new `BiasAddGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BiasAddGrad` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        out_backprop: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(out_backprop.into(), scope)
    }

    fn build_impl(
        &self,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BiasAddGrad", |nd| {
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BiasAddGrad::new().build(out_backprop, scope)`.
pub fn bias_add_grad<O0: ::std::convert::Into<crate::Output>>(
    out_backprop: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BiasAddGrad::new().build(out_backprop, scope)
}
/// Builder for the `BiasAddV1` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BiasAddV1 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BiasAddV1 {
    /// Creates a new `BiasAddV1`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BiasAddV1` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        value: O0,
        bias: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), bias.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        bias: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BiasAddV1", |nd| {
            nd.add_input(value);
            nd.add_input(bias);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BiasAddV1::new().build(value, bias, scope)`.
pub fn bias_add_v1<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    value: O0,
    bias: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BiasAddV1::new().build(value, bias, scope)
}
/// Builder for the `Bincount` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Bincount {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Bincount {
    /// Creates a new `Bincount`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Bincount` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        arr: O0,
        size: O1,
        weights: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(arr.into(), size.into(), weights.into(), scope)
    }

    fn build_impl(
        &self,
        arr: crate::Output,
        size: crate::Output,
        weights: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Bincount", |nd| {
            nd.add_input(arr);
            nd.add_input(size);
            nd.add_input(weights);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Bincount::new().build(arr, size, weights, scope)`.
pub fn bincount<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    arr: O0,
    size: O1,
    weights: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Bincount::new().build(arr, size, weights, scope)
}
/// Builder for the `Bitcast` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Bitcast {
    T: ::std::option::Option<crate::DataType>,
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Bitcast {
    /// Creates a new `Bitcast`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Bitcast` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Bitcast", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Bitcast::new().build(input, scope)`.
pub fn bitcast<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Bitcast::new().build(input, scope)
}
/// Builder for the `BitwiseAnd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BitwiseAnd {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BitwiseAnd {
    /// Creates a new `BitwiseAnd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BitwiseAnd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BitwiseAnd", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BitwiseAnd::new().build(x, y, scope)`.
pub fn bitwise_and<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BitwiseAnd::new().build(x, y, scope)
}
/// Builder for the `BitwiseOr` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BitwiseOr {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BitwiseOr {
    /// Creates a new `BitwiseOr`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BitwiseOr` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BitwiseOr", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BitwiseOr::new().build(x, y, scope)`.
pub fn bitwise_or<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BitwiseOr::new().build(x, y, scope)
}
/// Builder for the `BitwiseXor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BitwiseXor {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BitwiseXor {
    /// Creates a new `BitwiseXor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BitwiseXor` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BitwiseXor", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BitwiseXor::new().build(x, y, scope)`.
pub fn bitwise_xor<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BitwiseXor::new().build(x, y, scope)
}
/// Builder for the `BlockLSTM` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BlockLSTM {
    forget_bias: ::std::option::Option<f32>,
    cell_clip: ::std::option::Option<f32>,
    use_peephole: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BlockLSTM {
    /// Creates a new `BlockLSTM`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `forget_bias` attribute.
    pub fn forget_bias<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.forget_bias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `cell_clip` attribute.
    pub fn cell_clip<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.cell_clip = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_peephole` attribute.
    pub fn use_peephole<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_peephole = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BlockLSTM` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        seq_len_max: O0,
        x: O1,
        cs_prev: O2,
        h_prev: O3,
        w: O4,
        wci: O5,
        wcf: O6,
        wco: O7,
        b: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            seq_len_max.into(),
            x.into(),
            cs_prev.into(),
            h_prev.into(),
            w.into(),
            wci.into(),
            wcf.into(),
            wco.into(),
            b.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        seq_len_max: crate::Output,
        x: crate::Output,
        cs_prev: crate::Output,
        h_prev: crate::Output,
        w: crate::Output,
        wci: crate::Output,
        wcf: crate::Output,
        wco: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BlockLSTM", |nd| {
            nd.add_input(seq_len_max);
            nd.add_input(x);
            nd.add_input(cs_prev);
            nd.add_input(h_prev);
            nd.add_input(w);
            nd.add_input(wci);
            nd.add_input(wcf);
            nd.add_input(wco);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.forget_bias {
                nd.set_attr_float("forget_bias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.cell_clip {
                nd.set_attr_float("cell_clip", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_peephole {
                nd.set_attr_bool("use_peephole", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BlockLSTM::new().build(seq_len_max, x, cs_prev, h_prev, w, wci, wcf, wco, b, scope)`.
pub fn block_lstm<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    seq_len_max: O0,
    x: O1,
    cs_prev: O2,
    h_prev: O3,
    w: O4,
    wci: O5,
    wcf: O6,
    wco: O7,
    b: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BlockLSTM::new().build(seq_len_max, x, cs_prev, h_prev, w, wci, wcf, wco, b, scope)
}
/// Builder for the `BlockLSTMGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BlockLSTMGrad {
    use_peephole: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BlockLSTMGrad {
    /// Creates a new `BlockLSTMGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `use_peephole` attribute.
    pub fn use_peephole<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_peephole = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BlockLSTMGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
        O12: ::std::convert::Into<crate::Output>,
        O13: ::std::convert::Into<crate::Output>,
        O14: ::std::convert::Into<crate::Output>,
        O15: ::std::convert::Into<crate::Output>,
        O16: ::std::convert::Into<crate::Output>,
        O17: ::std::convert::Into<crate::Output>,
    >(
        &self,
        seq_len_max: O0,
        x: O1,
        cs_prev: O2,
        h_prev: O3,
        w: O4,
        wci: O5,
        wcf: O6,
        wco: O7,
        b: O8,
        i: O9,
        cs: O10,
        f: O11,
        o: O12,
        ci: O13,
        co: O14,
        h: O15,
        cs_grad: O16,
        h_grad: O17,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            seq_len_max.into(),
            x.into(),
            cs_prev.into(),
            h_prev.into(),
            w.into(),
            wci.into(),
            wcf.into(),
            wco.into(),
            b.into(),
            i.into(),
            cs.into(),
            f.into(),
            o.into(),
            ci.into(),
            co.into(),
            h.into(),
            cs_grad.into(),
            h_grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        seq_len_max: crate::Output,
        x: crate::Output,
        cs_prev: crate::Output,
        h_prev: crate::Output,
        w: crate::Output,
        wci: crate::Output,
        wcf: crate::Output,
        wco: crate::Output,
        b: crate::Output,
        i: crate::Output,
        cs: crate::Output,
        f: crate::Output,
        o: crate::Output,
        ci: crate::Output,
        co: crate::Output,
        h: crate::Output,
        cs_grad: crate::Output,
        h_grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BlockLSTMGrad", |nd| {
            nd.add_input(seq_len_max);
            nd.add_input(x);
            nd.add_input(cs_prev);
            nd.add_input(h_prev);
            nd.add_input(w);
            nd.add_input(wci);
            nd.add_input(wcf);
            nd.add_input(wco);
            nd.add_input(b);
            nd.add_input(i);
            nd.add_input(cs);
            nd.add_input(f);
            nd.add_input(o);
            nd.add_input(ci);
            nd.add_input(co);
            nd.add_input(h);
            nd.add_input(cs_grad);
            nd.add_input(h_grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.use_peephole {
                nd.set_attr_bool("use_peephole", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BlockLSTMGrad::new().build(seq_len_max, x, cs_prev, h_prev, w, wci, wcf, wco, b, i, cs, f, o, ci, co, h, cs_grad, h_grad, scope)`.
pub fn block_lstmgrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
    O12: ::std::convert::Into<crate::Output>,
    O13: ::std::convert::Into<crate::Output>,
    O14: ::std::convert::Into<crate::Output>,
    O15: ::std::convert::Into<crate::Output>,
    O16: ::std::convert::Into<crate::Output>,
    O17: ::std::convert::Into<crate::Output>,
>(
    seq_len_max: O0,
    x: O1,
    cs_prev: O2,
    h_prev: O3,
    w: O4,
    wci: O5,
    wcf: O6,
    wco: O7,
    b: O8,
    i: O9,
    cs: O10,
    f: O11,
    o: O12,
    ci: O13,
    co: O14,
    h: O15,
    cs_grad: O16,
    h_grad: O17,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BlockLSTMGrad::new().build(
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h,
        cs_grad,
        h_grad,
        scope,
    )
}
/// Builder for the `BlockLSTMGradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BlockLSTMGradV2 {
    use_peephole: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BlockLSTMGradV2 {
    /// Creates a new `BlockLSTMGradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `use_peephole` attribute.
    pub fn use_peephole<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_peephole = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BlockLSTMGradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
        O12: ::std::convert::Into<crate::Output>,
        O13: ::std::convert::Into<crate::Output>,
        O14: ::std::convert::Into<crate::Output>,
        O15: ::std::convert::Into<crate::Output>,
        O16: ::std::convert::Into<crate::Output>,
        O17: ::std::convert::Into<crate::Output>,
    >(
        &self,
        seq_len_max: O0,
        x: O1,
        cs_prev: O2,
        h_prev: O3,
        w: O4,
        wci: O5,
        wcf: O6,
        wco: O7,
        b: O8,
        i: O9,
        cs: O10,
        f: O11,
        o: O12,
        ci: O13,
        co: O14,
        h: O15,
        cs_grad: O16,
        h_grad: O17,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            seq_len_max.into(),
            x.into(),
            cs_prev.into(),
            h_prev.into(),
            w.into(),
            wci.into(),
            wcf.into(),
            wco.into(),
            b.into(),
            i.into(),
            cs.into(),
            f.into(),
            o.into(),
            ci.into(),
            co.into(),
            h.into(),
            cs_grad.into(),
            h_grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        seq_len_max: crate::Output,
        x: crate::Output,
        cs_prev: crate::Output,
        h_prev: crate::Output,
        w: crate::Output,
        wci: crate::Output,
        wcf: crate::Output,
        wco: crate::Output,
        b: crate::Output,
        i: crate::Output,
        cs: crate::Output,
        f: crate::Output,
        o: crate::Output,
        ci: crate::Output,
        co: crate::Output,
        h: crate::Output,
        cs_grad: crate::Output,
        h_grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BlockLSTMGradV2", |nd| {
            nd.add_input(seq_len_max);
            nd.add_input(x);
            nd.add_input(cs_prev);
            nd.add_input(h_prev);
            nd.add_input(w);
            nd.add_input(wci);
            nd.add_input(wcf);
            nd.add_input(wco);
            nd.add_input(b);
            nd.add_input(i);
            nd.add_input(cs);
            nd.add_input(f);
            nd.add_input(o);
            nd.add_input(ci);
            nd.add_input(co);
            nd.add_input(h);
            nd.add_input(cs_grad);
            nd.add_input(h_grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.use_peephole {
                nd.set_attr_bool("use_peephole", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BlockLSTMGradV2::new().build(seq_len_max, x, cs_prev, h_prev, w, wci, wcf, wco, b, i, cs, f, o, ci, co, h, cs_grad, h_grad, scope)`.
pub fn block_lstmgrad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
    O12: ::std::convert::Into<crate::Output>,
    O13: ::std::convert::Into<crate::Output>,
    O14: ::std::convert::Into<crate::Output>,
    O15: ::std::convert::Into<crate::Output>,
    O16: ::std::convert::Into<crate::Output>,
    O17: ::std::convert::Into<crate::Output>,
>(
    seq_len_max: O0,
    x: O1,
    cs_prev: O2,
    h_prev: O3,
    w: O4,
    wci: O5,
    wcf: O6,
    wco: O7,
    b: O8,
    i: O9,
    cs: O10,
    f: O11,
    o: O12,
    ci: O13,
    co: O14,
    h: O15,
    cs_grad: O16,
    h_grad: O17,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BlockLSTMGradV2::new().build(
        seq_len_max,
        x,
        cs_prev,
        h_prev,
        w,
        wci,
        wcf,
        wco,
        b,
        i,
        cs,
        f,
        o,
        ci,
        co,
        h,
        cs_grad,
        h_grad,
        scope,
    )
}
/// Builder for the `BlockLSTMV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BlockLSTMV2 {
    cell_clip: ::std::option::Option<f32>,
    use_peephole: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BlockLSTMV2 {
    /// Creates a new `BlockLSTMV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `cell_clip` attribute.
    pub fn cell_clip<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.cell_clip = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_peephole` attribute.
    pub fn use_peephole<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_peephole = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BlockLSTMV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        seq_len_max: O0,
        x: O1,
        cs_prev: O2,
        h_prev: O3,
        w: O4,
        wci: O5,
        wcf: O6,
        wco: O7,
        b: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            seq_len_max.into(),
            x.into(),
            cs_prev.into(),
            h_prev.into(),
            w.into(),
            wci.into(),
            wcf.into(),
            wco.into(),
            b.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        seq_len_max: crate::Output,
        x: crate::Output,
        cs_prev: crate::Output,
        h_prev: crate::Output,
        w: crate::Output,
        wci: crate::Output,
        wcf: crate::Output,
        wco: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BlockLSTMV2", |nd| {
            nd.add_input(seq_len_max);
            nd.add_input(x);
            nd.add_input(cs_prev);
            nd.add_input(h_prev);
            nd.add_input(w);
            nd.add_input(wci);
            nd.add_input(wcf);
            nd.add_input(wco);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.cell_clip {
                nd.set_attr_float("cell_clip", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_peephole {
                nd.set_attr_bool("use_peephole", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BlockLSTMV2::new().build(seq_len_max, x, cs_prev, h_prev, w, wci, wcf, wco, b, scope)`.
pub fn block_lstmv2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    seq_len_max: O0,
    x: O1,
    cs_prev: O2,
    h_prev: O3,
    w: O4,
    wci: O5,
    wcf: O6,
    wco: O7,
    b: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BlockLSTMV2::new().build(seq_len_max, x, cs_prev, h_prev, w, wci, wcf, wco, b, scope)
}
/// Builder for the `BoostedTreesAggregateStats` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesAggregateStats {
    max_splits: ::std::option::Option<i64>,
    num_buckets: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesAggregateStats {
    /// Creates a new `BoostedTreesAggregateStats`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_splits` attribute.
    pub fn max_splits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_splits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_buckets` attribute.
    pub fn num_buckets<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesAggregateStats` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        node_ids: O0,
        gradients: O1,
        hessians: O2,
        feature: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            node_ids.into(),
            gradients.into(),
            hessians.into(),
            feature.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        node_ids: crate::Output,
        gradients: crate::Output,
        hessians: crate::Output,
        feature: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesAggregateStats", |nd| {
            nd.add_input(node_ids);
            nd.add_input(gradients);
            nd.add_input(hessians);
            nd.add_input(feature);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_splits {
                nd.set_attr_int("max_splits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_buckets {
                nd.set_attr_int("num_buckets", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesAggregateStats::new().build(node_ids, gradients, hessians, feature, scope)`.
pub fn boosted_trees_aggregate_stats<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    node_ids: O0,
    gradients: O1,
    hessians: O2,
    feature: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesAggregateStats::new().build(node_ids, gradients, hessians, feature, scope)
}
/// Builder for the `BoostedTreesBucketize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesBucketize {
    num_features: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesBucketize {
    /// Creates a new `BoostedTreesBucketize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesBucketize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        float_values: O0,
        bucket_boundaries: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(float_values.into(), bucket_boundaries.into(), scope)
    }

    fn build_impl(
        &self,
        float_values: crate::Output,
        bucket_boundaries: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesBucketize", |nd| {
            nd.add_input(float_values);
            nd.add_input(bucket_boundaries);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesBucketize::new().build(float_values, bucket_boundaries, scope)`.
pub fn boosted_trees_bucketize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    float_values: O0,
    bucket_boundaries: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesBucketize::new().build(float_values, bucket_boundaries, scope)
}
/// Builder for the `BoostedTreesCalculateBestFeatureSplit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCalculateBestFeatureSplit {
    logits_dimension: ::std::option::Option<i64>,
    split_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesCalculateBestFeatureSplit {
    /// Creates a new `BoostedTreesCalculateBestFeatureSplit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `logits_dimension` attribute.
    pub fn logits_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.logits_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `split_type` attribute.
    pub fn split_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.split_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesCalculateBestFeatureSplit` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        node_id_range: O0,
        stats_summary: O1,
        l1: O2,
        l2: O3,
        tree_complexity: O4,
        min_node_weight: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            node_id_range.into(),
            stats_summary.into(),
            l1.into(),
            l2.into(),
            tree_complexity.into(),
            min_node_weight.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        node_id_range: crate::Output,
        stats_summary: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        tree_complexity: crate::Output,
        min_node_weight: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesCalculateBestFeatureSplit", |nd| {
            nd.add_input(node_id_range);
            nd.add_input(stats_summary);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(tree_complexity);
            nd.add_input(min_node_weight);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.logits_dimension {
                nd.set_attr_int("logits_dimension", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.split_type {
                nd.set_attr_string("split_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesCalculateBestFeatureSplit::new().build(node_id_range, stats_summary, l1, l2, tree_complexity, min_node_weight, scope)`.
pub fn boosted_trees_calculate_best_feature_split<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    node_id_range: O0,
    stats_summary: O1,
    l1: O2,
    l2: O3,
    tree_complexity: O4,
    min_node_weight: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesCalculateBestFeatureSplit::new().build(
        node_id_range,
        stats_summary,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        scope,
    )
}
/// Builder for the `BoostedTreesCalculateBestFeatureSplitV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCalculateBestFeatureSplitV2 {
    num_features: ::std::option::Option<i64>,
    logits_dimension: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesCalculateBestFeatureSplitV2 {
    /// Creates a new `BoostedTreesCalculateBestFeatureSplitV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `logits_dimension` attribute.
    pub fn logits_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.logits_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesCalculateBestFeatureSplitV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        node_id_range: O0,
        stats_summaries_list: O1,
        split_types: O2,
        candidate_feature_ids: O3,
        l1: O4,
        l2: O5,
        tree_complexity: O6,
        min_node_weight: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            node_id_range.into(),
            stats_summaries_list.into(),
            split_types.into(),
            candidate_feature_ids.into(),
            l1.into(),
            l2.into(),
            tree_complexity.into(),
            min_node_weight.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        node_id_range: crate::Output,
        stats_summaries_list: crate::Output,
        split_types: crate::Output,
        candidate_feature_ids: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        tree_complexity: crate::Output,
        min_node_weight: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesCalculateBestFeatureSplitV2", |nd| {
            nd.add_input(node_id_range);
            nd.add_input(stats_summaries_list);
            nd.add_input(split_types);
            nd.add_input(candidate_feature_ids);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(tree_complexity);
            nd.add_input(min_node_weight);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.logits_dimension {
                nd.set_attr_int("logits_dimension", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesCalculateBestFeatureSplitV2::new().build(node_id_range, stats_summaries_list, split_types, candidate_feature_ids, l1, l2, tree_complexity, min_node_weight, scope)`.
pub fn boosted_trees_calculate_best_feature_split_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    node_id_range: O0,
    stats_summaries_list: O1,
    split_types: O2,
    candidate_feature_ids: O3,
    l1: O4,
    l2: O5,
    tree_complexity: O6,
    min_node_weight: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesCalculateBestFeatureSplitV2::new().build(
        node_id_range,
        stats_summaries_list,
        split_types,
        candidate_feature_ids,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        scope,
    )
}
/// Builder for the `BoostedTreesCalculateBestGainsPerFeature` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCalculateBestGainsPerFeature {
    max_splits: ::std::option::Option<i64>,
    num_features: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesCalculateBestGainsPerFeature {
    /// Creates a new `BoostedTreesCalculateBestGainsPerFeature`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_splits` attribute.
    pub fn max_splits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_splits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesCalculateBestGainsPerFeature` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        node_id_range: O0,
        stats_summary_list: O1,
        l1: O2,
        l2: O3,
        tree_complexity: O4,
        min_node_weight: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            node_id_range.into(),
            stats_summary_list.into(),
            l1.into(),
            l2.into(),
            tree_complexity.into(),
            min_node_weight.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        node_id_range: crate::Output,
        stats_summary_list: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        tree_complexity: crate::Output,
        min_node_weight: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesCalculateBestGainsPerFeature", |nd| {
            nd.add_input(node_id_range);
            nd.add_input(stats_summary_list);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(tree_complexity);
            nd.add_input(min_node_weight);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_splits {
                nd.set_attr_int("max_splits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesCalculateBestGainsPerFeature::new().build(node_id_range, stats_summary_list, l1, l2, tree_complexity, min_node_weight, scope)`.
pub fn boosted_trees_calculate_best_gains_per_feature<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    node_id_range: O0,
    stats_summary_list: O1,
    l1: O2,
    l2: O3,
    tree_complexity: O4,
    min_node_weight: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesCalculateBestGainsPerFeature::new().build(
        node_id_range,
        stats_summary_list,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        scope,
    )
}
/// Builder for the `BoostedTreesCenterBias` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCenterBias {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesCenterBias {
    /// Creates a new `BoostedTreesCenterBias`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesCenterBias` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_ensemble_handle: O0,
        mean_gradients: O1,
        mean_hessians: O2,
        l1: O3,
        l2: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tree_ensemble_handle.into(),
            mean_gradients.into(),
            mean_hessians.into(),
            l1.into(),
            l2.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        mean_gradients: crate::Output,
        mean_hessians: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesCenterBias", |nd| {
            nd.add_input(tree_ensemble_handle);
            nd.add_input(mean_gradients);
            nd.add_input(mean_hessians);
            nd.add_input(l1);
            nd.add_input(l2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesCenterBias::new().build(tree_ensemble_handle, mean_gradients, mean_hessians, l1, l2, scope)`.
pub fn boosted_trees_center_bias<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    tree_ensemble_handle: O0,
    mean_gradients: O1,
    mean_hessians: O2,
    l1: O3,
    l2: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesCenterBias::new().build(
        tree_ensemble_handle,
        mean_gradients,
        mean_hessians,
        l1,
        l2,
        scope,
    )
}
/// Builder for the `BoostedTreesCreateEnsemble` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCreateEnsemble {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesCreateEnsemble {
    /// Creates a new `BoostedTreesCreateEnsemble`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesCreateEnsemble` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_ensemble_handle: O0,
        stamp_token: O1,
        tree_ensemble_serialized: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tree_ensemble_handle.into(),
            stamp_token.into(),
            tree_ensemble_serialized.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        stamp_token: crate::Output,
        tree_ensemble_serialized: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesCreateEnsemble", |nd| {
            nd.add_input(tree_ensemble_handle);
            nd.add_input(stamp_token);
            nd.add_input(tree_ensemble_serialized);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesCreateEnsemble::new().build(tree_ensemble_handle, stamp_token, tree_ensemble_serialized, scope)`.
pub fn boosted_trees_create_ensemble<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tree_ensemble_handle: O0,
    stamp_token: O1,
    tree_ensemble_serialized: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesCreateEnsemble::new().build(
        tree_ensemble_handle,
        stamp_token,
        tree_ensemble_serialized,
        scope,
    )
}
/// Builder for the `BoostedTreesCreateQuantileStreamResource` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesCreateQuantileStreamResource {
    max_elements: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesCreateQuantileStreamResource {
    /// Creates a new `BoostedTreesCreateQuantileStreamResource`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_elements` attribute.
    pub fn max_elements<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_elements = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesCreateQuantileStreamResource` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        quantile_stream_resource_handle: O0,
        epsilon: O1,
        num_streams: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            quantile_stream_resource_handle.into(),
            epsilon.into(),
            num_streams.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        quantile_stream_resource_handle: crate::Output,
        epsilon: crate::Output,
        num_streams: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesCreateQuantileStreamResource", |nd| {
            nd.add_input(quantile_stream_resource_handle);
            nd.add_input(epsilon);
            nd.add_input(num_streams);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_elements {
                nd.set_attr_int("max_elements", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesCreateQuantileStreamResource::new().build(quantile_stream_resource_handle, epsilon, num_streams, scope)`.
pub fn boosted_trees_create_quantile_stream_resource<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    quantile_stream_resource_handle: O0,
    epsilon: O1,
    num_streams: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesCreateQuantileStreamResource::new().build(
        quantile_stream_resource_handle,
        epsilon,
        num_streams,
        scope,
    )
}
/// Builder for the `BoostedTreesDeserializeEnsemble` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesDeserializeEnsemble {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesDeserializeEnsemble {
    /// Creates a new `BoostedTreesDeserializeEnsemble`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesDeserializeEnsemble` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_ensemble_handle: O0,
        stamp_token: O1,
        tree_ensemble_serialized: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tree_ensemble_handle.into(),
            stamp_token.into(),
            tree_ensemble_serialized.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        stamp_token: crate::Output,
        tree_ensemble_serialized: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesDeserializeEnsemble", |nd| {
            nd.add_input(tree_ensemble_handle);
            nd.add_input(stamp_token);
            nd.add_input(tree_ensemble_serialized);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesDeserializeEnsemble::new().build(tree_ensemble_handle, stamp_token, tree_ensemble_serialized, scope)`.
pub fn boosted_trees_deserialize_ensemble<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tree_ensemble_handle: O0,
    stamp_token: O1,
    tree_ensemble_serialized: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesDeserializeEnsemble::new().build(
        tree_ensemble_handle,
        stamp_token,
        tree_ensemble_serialized,
        scope,
    )
}
/// Builder for the `BoostedTreesEnsembleResourceHandleOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesEnsembleResourceHandleOp {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesEnsembleResourceHandleOp {
    /// Creates a new `BoostedTreesEnsembleResourceHandleOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesEnsembleResourceHandleOp` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesEnsembleResourceHandleOp", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesEnsembleResourceHandleOp::new().build(scope)`.
pub fn boosted_trees_ensemble_resource_handle_op(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesEnsembleResourceHandleOp::new().build(scope)
}
/// Builder for the `BoostedTreesExampleDebugOutputs` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesExampleDebugOutputs {
    num_bucketized_features: ::std::option::Option<i64>,
    logits_dimension: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesExampleDebugOutputs {
    /// Creates a new `BoostedTreesExampleDebugOutputs`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_bucketized_features` attribute.
    pub fn num_bucketized_features<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_bucketized_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `logits_dimension` attribute.
    pub fn logits_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.logits_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesExampleDebugOutputs` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_ensemble_handle: O0,
        bucketized_features: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tree_ensemble_handle.into(),
            bucketized_features.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        bucketized_features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesExampleDebugOutputs", |nd| {
            nd.add_input(tree_ensemble_handle);
            nd.add_input(bucketized_features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_bucketized_features {
                nd.set_attr_int("num_bucketized_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.logits_dimension {
                nd.set_attr_int("logits_dimension", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesExampleDebugOutputs::new().build(tree_ensemble_handle, bucketized_features, scope)`.
pub fn boosted_trees_example_debug_outputs<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tree_ensemble_handle: O0,
    bucketized_features: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesExampleDebugOutputs::new().build(tree_ensemble_handle, bucketized_features, scope)
}
/// Builder for the `BoostedTreesFlushQuantileSummaries` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesFlushQuantileSummaries {
    num_features: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesFlushQuantileSummaries {
    /// Creates a new `BoostedTreesFlushQuantileSummaries`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesFlushQuantileSummaries` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        quantile_stream_resource_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(quantile_stream_resource_handle.into(), scope)
    }

    fn build_impl(
        &self,
        quantile_stream_resource_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesFlushQuantileSummaries", |nd| {
            nd.add_input(quantile_stream_resource_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesFlushQuantileSummaries::new().build(quantile_stream_resource_handle, scope)`.
pub fn boosted_trees_flush_quantile_summaries<O0: ::std::convert::Into<crate::Output>>(
    quantile_stream_resource_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesFlushQuantileSummaries::new().build(quantile_stream_resource_handle, scope)
}
/// Builder for the `BoostedTreesGetEnsembleStates` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesGetEnsembleStates {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesGetEnsembleStates {
    /// Creates a new `BoostedTreesGetEnsembleStates`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesGetEnsembleStates` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tree_ensemble_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_ensemble_handle.into(), scope)
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesGetEnsembleStates", |nd| {
            nd.add_input(tree_ensemble_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesGetEnsembleStates::new().build(tree_ensemble_handle, scope)`.
pub fn boosted_trees_get_ensemble_states<O0: ::std::convert::Into<crate::Output>>(
    tree_ensemble_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesGetEnsembleStates::new().build(tree_ensemble_handle, scope)
}
/// Builder for the `BoostedTreesMakeQuantileSummaries` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesMakeQuantileSummaries {
    num_features: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesMakeQuantileSummaries {
    /// Creates a new `BoostedTreesMakeQuantileSummaries`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesMakeQuantileSummaries` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        float_values: O0,
        example_weights: O1,
        epsilon: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            float_values.into(),
            example_weights.into(),
            epsilon.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        float_values: crate::Output,
        example_weights: crate::Output,
        epsilon: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesMakeQuantileSummaries", |nd| {
            nd.add_input(float_values);
            nd.add_input(example_weights);
            nd.add_input(epsilon);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesMakeQuantileSummaries::new().build(float_values, example_weights, epsilon, scope)`.
pub fn boosted_trees_make_quantile_summaries<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    float_values: O0,
    example_weights: O1,
    epsilon: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesMakeQuantileSummaries::new().build(float_values, example_weights, epsilon, scope)
}
/// Builder for the `BoostedTreesMakeStatsSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesMakeStatsSummary {
    max_splits: ::std::option::Option<i64>,
    num_buckets: ::std::option::Option<i64>,
    num_features: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesMakeStatsSummary {
    /// Creates a new `BoostedTreesMakeStatsSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_splits` attribute.
    pub fn max_splits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_splits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_buckets` attribute.
    pub fn num_buckets<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesMakeStatsSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        node_ids: O0,
        gradients: O1,
        hessians: O2,
        bucketized_features_list: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            node_ids.into(),
            gradients.into(),
            hessians.into(),
            bucketized_features_list.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        node_ids: crate::Output,
        gradients: crate::Output,
        hessians: crate::Output,
        bucketized_features_list: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesMakeStatsSummary", |nd| {
            nd.add_input(node_ids);
            nd.add_input(gradients);
            nd.add_input(hessians);
            nd.add_input(bucketized_features_list);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_splits {
                nd.set_attr_int("max_splits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_buckets {
                nd.set_attr_int("num_buckets", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesMakeStatsSummary::new().build(node_ids, gradients, hessians, bucketized_features_list, scope)`.
pub fn boosted_trees_make_stats_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    node_ids: O0,
    gradients: O1,
    hessians: O2,
    bucketized_features_list: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesMakeStatsSummary::new().build(
        node_ids,
        gradients,
        hessians,
        bucketized_features_list,
        scope,
    )
}
/// Builder for the `BoostedTreesPredict` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesPredict {
    num_bucketized_features: ::std::option::Option<i64>,
    logits_dimension: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesPredict {
    /// Creates a new `BoostedTreesPredict`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_bucketized_features` attribute.
    pub fn num_bucketized_features<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_bucketized_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `logits_dimension` attribute.
    pub fn logits_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.logits_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesPredict` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_ensemble_handle: O0,
        bucketized_features: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tree_ensemble_handle.into(),
            bucketized_features.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        bucketized_features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesPredict", |nd| {
            nd.add_input(tree_ensemble_handle);
            nd.add_input(bucketized_features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_bucketized_features {
                nd.set_attr_int("num_bucketized_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.logits_dimension {
                nd.set_attr_int("logits_dimension", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesPredict::new().build(tree_ensemble_handle, bucketized_features, scope)`.
pub fn boosted_trees_predict<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tree_ensemble_handle: O0,
    bucketized_features: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesPredict::new().build(tree_ensemble_handle, bucketized_features, scope)
}
/// Builder for the `BoostedTreesQuantileStreamResourceAddSummaries` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceAddSummaries {
    num_features: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesQuantileStreamResourceAddSummaries {
    /// Creates a new `BoostedTreesQuantileStreamResourceAddSummaries`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesQuantileStreamResourceAddSummaries` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        quantile_stream_resource_handle: O0,
        summaries: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            quantile_stream_resource_handle.into(),
            summaries.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        quantile_stream_resource_handle: crate::Output,
        summaries: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesQuantileStreamResourceAddSummaries", |nd| {
            nd.add_input(quantile_stream_resource_handle);
            nd.add_input(summaries);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesQuantileStreamResourceAddSummaries::new().build(quantile_stream_resource_handle, summaries, scope)`.
pub fn boosted_trees_quantile_stream_resource_add_summaries<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    quantile_stream_resource_handle: O0,
    summaries: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesQuantileStreamResourceAddSummaries::new().build(
        quantile_stream_resource_handle,
        summaries,
        scope,
    )
}
/// Builder for the `BoostedTreesQuantileStreamResourceDeserialize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceDeserialize {
    num_streams: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesQuantileStreamResourceDeserialize {
    /// Creates a new `BoostedTreesQuantileStreamResourceDeserialize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_streams` attribute.
    pub fn num_streams<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_streams = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesQuantileStreamResourceDeserialize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        quantile_stream_resource_handle: O0,
        bucket_boundaries: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            quantile_stream_resource_handle.into(),
            bucket_boundaries.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        quantile_stream_resource_handle: crate::Output,
        bucket_boundaries: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesQuantileStreamResourceDeserialize", |nd| {
            nd.add_input(quantile_stream_resource_handle);
            nd.add_input(bucket_boundaries);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_streams {
                nd.set_attr_int("num_streams", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesQuantileStreamResourceDeserialize::new().build(quantile_stream_resource_handle, bucket_boundaries, scope)`.
pub fn boosted_trees_quantile_stream_resource_deserialize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    quantile_stream_resource_handle: O0,
    bucket_boundaries: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesQuantileStreamResourceDeserialize::new().build(
        quantile_stream_resource_handle,
        bucket_boundaries,
        scope,
    )
}
/// Builder for the `BoostedTreesQuantileStreamResourceFlush` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceFlush {
    generate_quantiles: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesQuantileStreamResourceFlush {
    /// Creates a new `BoostedTreesQuantileStreamResourceFlush`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `generate_quantiles` attribute.
    pub fn generate_quantiles<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.generate_quantiles = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesQuantileStreamResourceFlush` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        quantile_stream_resource_handle: O0,
        num_buckets: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            quantile_stream_resource_handle.into(),
            num_buckets.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        quantile_stream_resource_handle: crate::Output,
        num_buckets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesQuantileStreamResourceFlush", |nd| {
            nd.add_input(quantile_stream_resource_handle);
            nd.add_input(num_buckets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.generate_quantiles {
                nd.set_attr_bool("generate_quantiles", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesQuantileStreamResourceFlush::new().build(quantile_stream_resource_handle, num_buckets, scope)`.
pub fn boosted_trees_quantile_stream_resource_flush<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    quantile_stream_resource_handle: O0,
    num_buckets: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesQuantileStreamResourceFlush::new().build(
        quantile_stream_resource_handle,
        num_buckets,
        scope,
    )
}
/// Builder for the `BoostedTreesQuantileStreamResourceGetBucketBoundaries` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceGetBucketBoundaries {
    num_features: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesQuantileStreamResourceGetBucketBoundaries {
    /// Creates a new `BoostedTreesQuantileStreamResourceGetBucketBoundaries`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesQuantileStreamResourceGetBucketBoundaries` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        quantile_stream_resource_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(quantile_stream_resource_handle.into(), scope)
    }

    fn build_impl(
        &self,
        quantile_stream_resource_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "BoostedTreesQuantileStreamResourceGetBucketBoundaries",
            |nd| {
                nd.add_input(quantile_stream_resource_handle);
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.num_features {
                    nd.set_attr_int("num_features", *value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `BoostedTreesQuantileStreamResourceGetBucketBoundaries::new().build(quantile_stream_resource_handle, scope)`.
pub fn boosted_trees_quantile_stream_resource_get_bucket_boundaries<
    O0: ::std::convert::Into<crate::Output>,
>(
    quantile_stream_resource_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesQuantileStreamResourceGetBucketBoundaries::new()
        .build(quantile_stream_resource_handle, scope)
}
/// Builder for the `BoostedTreesQuantileStreamResourceHandleOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesQuantileStreamResourceHandleOp {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesQuantileStreamResourceHandleOp {
    /// Creates a new `BoostedTreesQuantileStreamResourceHandleOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesQuantileStreamResourceHandleOp` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesQuantileStreamResourceHandleOp", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesQuantileStreamResourceHandleOp::new().build(scope)`.
pub fn boosted_trees_quantile_stream_resource_handle_op(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesQuantileStreamResourceHandleOp::new().build(scope)
}
/// Builder for the `BoostedTreesSerializeEnsemble` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesSerializeEnsemble {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesSerializeEnsemble {
    /// Creates a new `BoostedTreesSerializeEnsemble`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesSerializeEnsemble` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tree_ensemble_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_ensemble_handle.into(), scope)
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesSerializeEnsemble", |nd| {
            nd.add_input(tree_ensemble_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesSerializeEnsemble::new().build(tree_ensemble_handle, scope)`.
pub fn boosted_trees_serialize_ensemble<O0: ::std::convert::Into<crate::Output>>(
    tree_ensemble_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesSerializeEnsemble::new().build(tree_ensemble_handle, scope)
}
/// Builder for the `BoostedTreesSparseAggregateStats` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesSparseAggregateStats {
    max_splits: ::std::option::Option<i64>,
    num_buckets: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesSparseAggregateStats {
    /// Creates a new `BoostedTreesSparseAggregateStats`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_splits` attribute.
    pub fn max_splits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_splits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_buckets` attribute.
    pub fn num_buckets<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesSparseAggregateStats` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        node_ids: O0,
        gradients: O1,
        hessians: O2,
        feature_indices: O3,
        feature_values: O4,
        feature_shape: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            node_ids.into(),
            gradients.into(),
            hessians.into(),
            feature_indices.into(),
            feature_values.into(),
            feature_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        node_ids: crate::Output,
        gradients: crate::Output,
        hessians: crate::Output,
        feature_indices: crate::Output,
        feature_values: crate::Output,
        feature_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesSparseAggregateStats", |nd| {
            nd.add_input(node_ids);
            nd.add_input(gradients);
            nd.add_input(hessians);
            nd.add_input(feature_indices);
            nd.add_input(feature_values);
            nd.add_input(feature_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_splits {
                nd.set_attr_int("max_splits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_buckets {
                nd.set_attr_int("num_buckets", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesSparseAggregateStats::new().build(node_ids, gradients, hessians, feature_indices, feature_values, feature_shape, scope)`.
pub fn boosted_trees_sparse_aggregate_stats<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    node_ids: O0,
    gradients: O1,
    hessians: O2,
    feature_indices: O3,
    feature_values: O4,
    feature_shape: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesSparseAggregateStats::new().build(
        node_ids,
        gradients,
        hessians,
        feature_indices,
        feature_values,
        feature_shape,
        scope,
    )
}
/// Builder for the `BoostedTreesSparseCalculateBestFeatureSplit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesSparseCalculateBestFeatureSplit {
    logits_dimension: ::std::option::Option<i64>,
    split_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesSparseCalculateBestFeatureSplit {
    /// Creates a new `BoostedTreesSparseCalculateBestFeatureSplit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `logits_dimension` attribute.
    pub fn logits_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.logits_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `split_type` attribute.
    pub fn split_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.split_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesSparseCalculateBestFeatureSplit` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        node_id_range: O0,
        stats_summary_indices: O1,
        stats_summary_values: O2,
        stats_summary_shape: O3,
        l1: O4,
        l2: O5,
        tree_complexity: O6,
        min_node_weight: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            node_id_range.into(),
            stats_summary_indices.into(),
            stats_summary_values.into(),
            stats_summary_shape.into(),
            l1.into(),
            l2.into(),
            tree_complexity.into(),
            min_node_weight.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        node_id_range: crate::Output,
        stats_summary_indices: crate::Output,
        stats_summary_values: crate::Output,
        stats_summary_shape: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        tree_complexity: crate::Output,
        min_node_weight: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesSparseCalculateBestFeatureSplit", |nd| {
            nd.add_input(node_id_range);
            nd.add_input(stats_summary_indices);
            nd.add_input(stats_summary_values);
            nd.add_input(stats_summary_shape);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(tree_complexity);
            nd.add_input(min_node_weight);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.logits_dimension {
                nd.set_attr_int("logits_dimension", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.split_type {
                nd.set_attr_string("split_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesSparseCalculateBestFeatureSplit::new().build(node_id_range, stats_summary_indices, stats_summary_values, stats_summary_shape, l1, l2, tree_complexity, min_node_weight, scope)`.
pub fn boosted_trees_sparse_calculate_best_feature_split<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    node_id_range: O0,
    stats_summary_indices: O1,
    stats_summary_values: O2,
    stats_summary_shape: O3,
    l1: O4,
    l2: O5,
    tree_complexity: O6,
    min_node_weight: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesSparseCalculateBestFeatureSplit::new().build(
        node_id_range,
        stats_summary_indices,
        stats_summary_values,
        stats_summary_shape,
        l1,
        l2,
        tree_complexity,
        min_node_weight,
        scope,
    )
}
/// Builder for the `BoostedTreesTrainingPredict` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesTrainingPredict {
    num_bucketized_features: ::std::option::Option<i64>,
    logits_dimension: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesTrainingPredict {
    /// Creates a new `BoostedTreesTrainingPredict`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_bucketized_features` attribute.
    pub fn num_bucketized_features<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_bucketized_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `logits_dimension` attribute.
    pub fn logits_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.logits_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesTrainingPredict` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_ensemble_handle: O0,
        cached_tree_ids: O1,
        cached_node_ids: O2,
        bucketized_features: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tree_ensemble_handle.into(),
            cached_tree_ids.into(),
            cached_node_ids.into(),
            bucketized_features.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        cached_tree_ids: crate::Output,
        cached_node_ids: crate::Output,
        bucketized_features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesTrainingPredict", |nd| {
            nd.add_input(tree_ensemble_handle);
            nd.add_input(cached_tree_ids);
            nd.add_input(cached_node_ids);
            nd.add_input(bucketized_features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_bucketized_features {
                nd.set_attr_int("num_bucketized_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.logits_dimension {
                nd.set_attr_int("logits_dimension", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesTrainingPredict::new().build(tree_ensemble_handle, cached_tree_ids, cached_node_ids, bucketized_features, scope)`.
pub fn boosted_trees_training_predict<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    tree_ensemble_handle: O0,
    cached_tree_ids: O1,
    cached_node_ids: O2,
    bucketized_features: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesTrainingPredict::new().build(
        tree_ensemble_handle,
        cached_tree_ids,
        cached_node_ids,
        bucketized_features,
        scope,
    )
}
/// Builder for the `BoostedTreesUpdateEnsemble` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesUpdateEnsemble {
    pruning_mode: ::std::option::Option<i64>,
    num_features: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesUpdateEnsemble {
    /// Creates a new `BoostedTreesUpdateEnsemble`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `pruning_mode` attribute.
    pub fn pruning_mode<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.pruning_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesUpdateEnsemble` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_ensemble_handle: O0,
        feature_ids: O1,
        node_ids: O2,
        gains: O3,
        thresholds: O4,
        left_node_contribs: O5,
        right_node_contribs: O6,
        max_depth: O7,
        learning_rate: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tree_ensemble_handle.into(),
            feature_ids.into(),
            node_ids.into(),
            gains.into(),
            thresholds.into(),
            left_node_contribs.into(),
            right_node_contribs.into(),
            max_depth.into(),
            learning_rate.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        feature_ids: crate::Output,
        node_ids: crate::Output,
        gains: crate::Output,
        thresholds: crate::Output,
        left_node_contribs: crate::Output,
        right_node_contribs: crate::Output,
        max_depth: crate::Output,
        learning_rate: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesUpdateEnsemble", |nd| {
            nd.add_input(tree_ensemble_handle);
            nd.add_input(feature_ids);
            nd.add_input(node_ids);
            nd.add_input(gains);
            nd.add_input(thresholds);
            nd.add_input(left_node_contribs);
            nd.add_input(right_node_contribs);
            nd.add_input(max_depth);
            nd.add_input(learning_rate);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.pruning_mode {
                nd.set_attr_int("pruning_mode", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesUpdateEnsemble::new().build(tree_ensemble_handle, feature_ids, node_ids, gains, thresholds, left_node_contribs, right_node_contribs, max_depth, learning_rate, scope)`.
pub fn boosted_trees_update_ensemble<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    tree_ensemble_handle: O0,
    feature_ids: O1,
    node_ids: O2,
    gains: O3,
    thresholds: O4,
    left_node_contribs: O5,
    right_node_contribs: O6,
    max_depth: O7,
    learning_rate: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesUpdateEnsemble::new().build(
        tree_ensemble_handle,
        feature_ids,
        node_ids,
        gains,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        max_depth,
        learning_rate,
        scope,
    )
}
/// Builder for the `BoostedTreesUpdateEnsembleV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BoostedTreesUpdateEnsembleV2 {
    num_features: ::std::option::Option<i64>,
    logits_dimension: ::std::option::Option<i64>,
    num_groups: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BoostedTreesUpdateEnsembleV2 {
    /// Creates a new `BoostedTreesUpdateEnsembleV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `logits_dimension` attribute.
    pub fn logits_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.logits_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_groups` attribute.
    pub fn num_groups<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_groups = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BoostedTreesUpdateEnsembleV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_ensemble_handle: O0,
        feature_ids: O1,
        dimension_ids: O2,
        node_ids: O3,
        gains: O4,
        thresholds: O5,
        left_node_contribs: O6,
        right_node_contribs: O7,
        split_types: O8,
        max_depth: O9,
        learning_rate: O10,
        pruning_mode: O11,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tree_ensemble_handle.into(),
            feature_ids.into(),
            dimension_ids.into(),
            node_ids.into(),
            gains.into(),
            thresholds.into(),
            left_node_contribs.into(),
            right_node_contribs.into(),
            split_types.into(),
            max_depth.into(),
            learning_rate.into(),
            pruning_mode.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        feature_ids: crate::Output,
        dimension_ids: crate::Output,
        node_ids: crate::Output,
        gains: crate::Output,
        thresholds: crate::Output,
        left_node_contribs: crate::Output,
        right_node_contribs: crate::Output,
        split_types: crate::Output,
        max_depth: crate::Output,
        learning_rate: crate::Output,
        pruning_mode: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BoostedTreesUpdateEnsembleV2", |nd| {
            nd.add_input(tree_ensemble_handle);
            nd.add_input(feature_ids);
            nd.add_input(dimension_ids);
            nd.add_input(node_ids);
            nd.add_input(gains);
            nd.add_input(thresholds);
            nd.add_input(left_node_contribs);
            nd.add_input(right_node_contribs);
            nd.add_input(split_types);
            nd.add_input(max_depth);
            nd.add_input(learning_rate);
            nd.add_input(pruning_mode);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.logits_dimension {
                nd.set_attr_int("logits_dimension", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_groups {
                nd.set_attr_int("num_groups", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BoostedTreesUpdateEnsembleV2::new().build(tree_ensemble_handle, feature_ids, dimension_ids, node_ids, gains, thresholds, left_node_contribs, right_node_contribs, split_types, max_depth, learning_rate, pruning_mode, scope)`.
pub fn boosted_trees_update_ensemble_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
>(
    tree_ensemble_handle: O0,
    feature_ids: O1,
    dimension_ids: O2,
    node_ids: O3,
    gains: O4,
    thresholds: O5,
    left_node_contribs: O6,
    right_node_contribs: O7,
    split_types: O8,
    max_depth: O9,
    learning_rate: O10,
    pruning_mode: O11,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BoostedTreesUpdateEnsembleV2::new().build(
        tree_ensemble_handle,
        feature_ids,
        dimension_ids,
        node_ids,
        gains,
        thresholds,
        left_node_contribs,
        right_node_contribs,
        split_types,
        max_depth,
        learning_rate,
        pruning_mode,
        scope,
    )
}
/// Builder for the `BroadcastArgs` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BroadcastArgs {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BroadcastArgs {
    /// Creates a new `BroadcastArgs`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BroadcastArgs` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        s0: O0,
        s1: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(s0.into(), s1.into(), scope)
    }

    fn build_impl(
        &self,
        s0: crate::Output,
        s1: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BroadcastArgs", |nd| {
            nd.add_input(s0);
            nd.add_input(s1);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BroadcastArgs::new().build(s0, s1, scope)`.
pub fn broadcast_args<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    s0: O0,
    s1: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BroadcastArgs::new().build(s0, s1, scope)
}
/// Builder for the `BroadcastGradientArgs` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BroadcastGradientArgs {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BroadcastGradientArgs {
    /// Creates a new `BroadcastGradientArgs`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BroadcastGradientArgs` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        s0: O0,
        s1: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(s0.into(), s1.into(), scope)
    }

    fn build_impl(
        &self,
        s0: crate::Output,
        s1: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BroadcastGradientArgs", |nd| {
            nd.add_input(s0);
            nd.add_input(s1);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BroadcastGradientArgs::new().build(s0, s1, scope)`.
pub fn broadcast_gradient_args<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    s0: O0,
    s1: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BroadcastGradientArgs::new().build(s0, s1, scope)
}
/// Builder for the `BroadcastTo` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BroadcastTo {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BroadcastTo {
    /// Creates a new `BroadcastTo`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BroadcastTo` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        shape: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BroadcastTo", |nd| {
            nd.add_input(input);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BroadcastTo::new().build(input, shape, scope)`.
pub fn broadcast_to<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    shape: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BroadcastTo::new().build(input, shape, scope)
}
/// Builder for the `Bucketize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Bucketize {
    T: ::std::option::Option<crate::DataType>,
    boundaries: ::std::option::Option<::std::vec::Vec<f32>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Bucketize {
    /// Creates a new `Bucketize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `boundaries` attribute.
    pub fn boundaries<ArgType: ::std::convert::Into<::std::vec::Vec<f32>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.boundaries = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Bucketize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Bucketize", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.boundaries {
                nd.set_attr_float_list("boundaries", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Bucketize::new().build(input, scope)`.
pub fn bucketize<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Bucketize::new().build(input, scope)
}
/// Builder for the `BytesProducedStatsDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct BytesProducedStatsDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl BytesProducedStatsDataset {
    /// Creates a new `BytesProducedStatsDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `BytesProducedStatsDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        tag: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), tag.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        tag: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("BytesProducedStatsDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(tag);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `BytesProducedStatsDataset::new().build(input_dataset, tag, scope)`.
pub fn bytes_produced_stats_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    tag: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    BytesProducedStatsDataset::new().build(input_dataset, tag, scope)
}
/// Builder for the `CSRSparseMatrixComponents` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSRSparseMatrixComponents {
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CSRSparseMatrixComponents {
    /// Creates a new `CSRSparseMatrixComponents`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CSRSparseMatrixComponents` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        csr_sparse_matrix: O0,
        index: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(csr_sparse_matrix.into(), index.into(), scope)
    }

    fn build_impl(
        &self,
        csr_sparse_matrix: crate::Output,
        index: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CSRSparseMatrixComponents", |nd| {
            nd.add_input(csr_sparse_matrix);
            nd.add_input(index);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CSRSparseMatrixComponents::new().build(csr_sparse_matrix, index, scope)`.
pub fn csrsparse_matrix_components<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    csr_sparse_matrix: O0,
    index: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CSRSparseMatrixComponents::new().build(csr_sparse_matrix, index, scope)
}
/// Builder for the `CSRSparseMatrixToDense` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSRSparseMatrixToDense {
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CSRSparseMatrixToDense {
    /// Creates a new `CSRSparseMatrixToDense`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CSRSparseMatrixToDense` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        sparse_input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(sparse_input.into(), scope)
    }

    fn build_impl(
        &self,
        sparse_input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CSRSparseMatrixToDense", |nd| {
            nd.add_input(sparse_input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CSRSparseMatrixToDense::new().build(sparse_input, scope)`.
pub fn csrsparse_matrix_to_dense<O0: ::std::convert::Into<crate::Output>>(
    sparse_input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CSRSparseMatrixToDense::new().build(sparse_input, scope)
}
/// Builder for the `CSRSparseMatrixToSparseTensor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSRSparseMatrixToSparseTensor {
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CSRSparseMatrixToSparseTensor {
    /// Creates a new `CSRSparseMatrixToSparseTensor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CSRSparseMatrixToSparseTensor` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        sparse_matrix: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(sparse_matrix.into(), scope)
    }

    fn build_impl(
        &self,
        sparse_matrix: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CSRSparseMatrixToSparseTensor", |nd| {
            nd.add_input(sparse_matrix);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CSRSparseMatrixToSparseTensor::new().build(sparse_matrix, scope)`.
pub fn csrsparse_matrix_to_sparse_tensor<O0: ::std::convert::Into<crate::Output>>(
    sparse_matrix: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CSRSparseMatrixToSparseTensor::new().build(sparse_matrix, scope)
}
/// Builder for the `CSVDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CSVDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CSVDataset {
    /// Creates a new `CSVDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CSVDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filenames: O0,
        compression_type: O1,
        buffer_size: O2,
        header: O3,
        field_delim: O4,
        use_quote_delim: O5,
        na_value: O6,
        select_cols: O7,
        record_defaults: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            filenames.into(),
            compression_type.into(),
            buffer_size.into(),
            header.into(),
            field_delim.into(),
            use_quote_delim.into(),
            na_value.into(),
            select_cols.into(),
            record_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        filenames: crate::Output,
        compression_type: crate::Output,
        buffer_size: crate::Output,
        header: crate::Output,
        field_delim: crate::Output,
        use_quote_delim: crate::Output,
        na_value: crate::Output,
        select_cols: crate::Output,
        record_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CSVDataset", |nd| {
            nd.add_input(filenames);
            nd.add_input(compression_type);
            nd.add_input(buffer_size);
            nd.add_input(header);
            nd.add_input(field_delim);
            nd.add_input(use_quote_delim);
            nd.add_input(na_value);
            nd.add_input(select_cols);
            nd.add_input(record_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CSVDataset::new().build(filenames, compression_type, buffer_size, header, field_delim, use_quote_delim, na_value, select_cols, record_defaults, scope)`.
pub fn csvdataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    filenames: O0,
    compression_type: O1,
    buffer_size: O2,
    header: O3,
    field_delim: O4,
    use_quote_delim: O5,
    na_value: O6,
    select_cols: O7,
    record_defaults: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CSVDataset::new().build(
        filenames,
        compression_type,
        buffer_size,
        header,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols,
        record_defaults,
        scope,
    )
}
/// Builder for the `CTCBeamSearchDecoder` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CTCBeamSearchDecoder {
    beam_width: ::std::option::Option<i64>,
    top_paths: ::std::option::Option<i64>,
    merge_repeated: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CTCBeamSearchDecoder {
    /// Creates a new `CTCBeamSearchDecoder`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `beam_width` attribute.
    pub fn beam_width<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.beam_width = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `top_paths` attribute.
    pub fn top_paths<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.top_paths = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `merge_repeated` attribute.
    pub fn merge_repeated<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.merge_repeated = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CTCBeamSearchDecoder` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        sequence_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), sequence_length.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        sequence_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CTCBeamSearchDecoder", |nd| {
            nd.add_input(inputs);
            nd.add_input(sequence_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.beam_width {
                nd.set_attr_int("beam_width", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.top_paths {
                nd.set_attr_int("top_paths", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.merge_repeated {
                nd.set_attr_bool("merge_repeated", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CTCBeamSearchDecoder::new().build(inputs, sequence_length, scope)`.
pub fn ctcbeam_search_decoder<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    sequence_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CTCBeamSearchDecoder::new().build(inputs, sequence_length, scope)
}
/// Builder for the `CTCGreedyDecoder` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CTCGreedyDecoder {
    merge_repeated: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CTCGreedyDecoder {
    /// Creates a new `CTCGreedyDecoder`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `merge_repeated` attribute.
    pub fn merge_repeated<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.merge_repeated = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CTCGreedyDecoder` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        sequence_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), sequence_length.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        sequence_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CTCGreedyDecoder", |nd| {
            nd.add_input(inputs);
            nd.add_input(sequence_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.merge_repeated {
                nd.set_attr_bool("merge_repeated", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CTCGreedyDecoder::new().build(inputs, sequence_length, scope)`.
pub fn ctcgreedy_decoder<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    sequence_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CTCGreedyDecoder::new().build(inputs, sequence_length, scope)
}
/// Builder for the `CTCLoss` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CTCLoss {
    preprocess_collapse_repeated: ::std::option::Option<bool>,
    ctc_merge_repeated: ::std::option::Option<bool>,
    ignore_longer_outputs_than_inputs: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CTCLoss {
    /// Creates a new `CTCLoss`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `preprocess_collapse_repeated` attribute.
    pub fn preprocess_collapse_repeated<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preprocess_collapse_repeated = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ctc_merge_repeated` attribute.
    pub fn ctc_merge_repeated<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ctc_merge_repeated = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ignore_longer_outputs_than_inputs` attribute.
    pub fn ignore_longer_outputs_than_inputs<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ignore_longer_outputs_than_inputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CTCLoss` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        labels_indices: O1,
        labels_values: O2,
        sequence_length: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            inputs.into(),
            labels_indices.into(),
            labels_values.into(),
            sequence_length.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        labels_indices: crate::Output,
        labels_values: crate::Output,
        sequence_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CTCLoss", |nd| {
            nd.add_input(inputs);
            nd.add_input(labels_indices);
            nd.add_input(labels_values);
            nd.add_input(sequence_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.preprocess_collapse_repeated {
                nd.set_attr_bool("preprocess_collapse_repeated", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ctc_merge_repeated {
                nd.set_attr_bool("ctc_merge_repeated", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ignore_longer_outputs_than_inputs {
                nd.set_attr_bool("ignore_longer_outputs_than_inputs", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CTCLoss::new().build(inputs, labels_indices, labels_values, sequence_length, scope)`.
pub fn ctcloss<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    labels_indices: O1,
    labels_values: O2,
    sequence_length: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CTCLoss::new().build(
        inputs,
        labels_indices,
        labels_values,
        sequence_length,
        scope,
    )
}
/// Builder for the `CTCLossV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CTCLossV2 {
    preprocess_collapse_repeated: ::std::option::Option<bool>,
    ctc_merge_repeated: ::std::option::Option<bool>,
    ignore_longer_outputs_than_inputs: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CTCLossV2 {
    /// Creates a new `CTCLossV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `preprocess_collapse_repeated` attribute.
    pub fn preprocess_collapse_repeated<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preprocess_collapse_repeated = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ctc_merge_repeated` attribute.
    pub fn ctc_merge_repeated<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ctc_merge_repeated = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ignore_longer_outputs_than_inputs` attribute.
    pub fn ignore_longer_outputs_than_inputs<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ignore_longer_outputs_than_inputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CTCLossV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        labels_indices: O1,
        labels_values: O2,
        sequence_length: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            inputs.into(),
            labels_indices.into(),
            labels_values.into(),
            sequence_length.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        labels_indices: crate::Output,
        labels_values: crate::Output,
        sequence_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CTCLossV2", |nd| {
            nd.add_input(inputs);
            nd.add_input(labels_indices);
            nd.add_input(labels_values);
            nd.add_input(sequence_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.preprocess_collapse_repeated {
                nd.set_attr_bool("preprocess_collapse_repeated", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ctc_merge_repeated {
                nd.set_attr_bool("ctc_merge_repeated", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ignore_longer_outputs_than_inputs {
                nd.set_attr_bool("ignore_longer_outputs_than_inputs", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CTCLossV2::new().build(inputs, labels_indices, labels_values, sequence_length, scope)`.
pub fn ctcloss_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    labels_indices: O1,
    labels_values: O2,
    sequence_length: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CTCLossV2::new().build(
        inputs,
        labels_indices,
        labels_values,
        sequence_length,
        scope,
    )
}
/// Builder for the `CacheDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CacheDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CacheDataset {
    /// Creates a new `CacheDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CacheDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        filename: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), filename.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        filename: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CacheDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(filename);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CacheDataset::new().build(input_dataset, filename, scope)`.
pub fn cache_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    filename: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CacheDataset::new().build(input_dataset, filename, scope)
}
/// Builder for the `CacheDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CacheDatasetV2 {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CacheDatasetV2 {
    /// Creates a new `CacheDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CacheDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        filename: O1,
        cache: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), filename.into(), cache.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        filename: crate::Output,
        cache: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CacheDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(filename);
            nd.add_input(cache);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CacheDatasetV2::new().build(input_dataset, filename, cache, scope)`.
pub fn cache_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    filename: O1,
    cache: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CacheDatasetV2::new().build(input_dataset, filename, cache, scope)
}
/// Builder for the `Case` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Case {
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    branches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Case {
    /// Creates a new `Case`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `branches` attribute.
    pub fn branches<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.branches = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Case` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        branch_index: O0,
        input: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(branch_index.into(), input.into(), scope)
    }

    fn build_impl(
        &self,
        branch_index: crate::Output,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Case", |nd| {
            nd.add_input(branch_index);
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.branches {
                nd.set_attr_string_list("branches", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Case::new().build(branch_index, input, scope)`.
pub fn case<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    branch_index: O0,
    input: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Case::new().build(branch_index, input, scope)
}
/// Builder for the `Cast` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cast {
    SrcT: ::std::option::Option<crate::DataType>,
    DstT: ::std::option::Option<crate::DataType>,
    Truncate: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Cast {
    /// Creates a new `Cast`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `SrcT` attribute.
    pub fn SrcT<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.SrcT = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `DstT` attribute.
    pub fn DstT<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.DstT = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Truncate` attribute.
    pub fn Truncate<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.Truncate = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Cast` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Cast", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.SrcT {
                nd.set_attr_type("SrcT", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.DstT {
                nd.set_attr_type("DstT", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Truncate {
                nd.set_attr_bool("Truncate", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Cast::new().build(x, scope)`.
pub fn cast<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Cast::new().build(x, scope)
}
/// Builder for the `Ceil` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Ceil {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Ceil {
    /// Creates a new `Ceil`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Ceil` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Ceil", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Ceil::new().build(x, scope)`.
pub fn ceil<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Ceil::new().build(x, scope)
}
/// Builder for the `CheckNumerics` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CheckNumerics {
    T: ::std::option::Option<crate::DataType>,
    message: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CheckNumerics {
    /// Creates a new `CheckNumerics`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `message` attribute.
    pub fn message<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.message = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CheckNumerics` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tensor: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CheckNumerics", |nd| {
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.message {
                nd.set_attr_string("message", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CheckNumerics::new().build(tensor, scope)`.
pub fn check_numerics<O0: ::std::convert::Into<crate::Output>>(
    tensor: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CheckNumerics::new().build(tensor, scope)
}
/// Builder for the `CheckNumericsV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CheckNumericsV2 {
    T: ::std::option::Option<crate::DataType>,
    message: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CheckNumericsV2 {
    /// Creates a new `CheckNumericsV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `message` attribute.
    pub fn message<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.message = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CheckNumericsV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tensor: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CheckNumericsV2", |nd| {
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.message {
                nd.set_attr_string("message", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CheckNumericsV2::new().build(tensor, scope)`.
pub fn check_numerics_v2<O0: ::std::convert::Into<crate::Output>>(
    tensor: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CheckNumericsV2::new().build(tensor, scope)
}
/// Builder for the `Cholesky` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cholesky {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Cholesky {
    /// Creates a new `Cholesky`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Cholesky` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Cholesky", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Cholesky::new().build(input, scope)`.
pub fn cholesky<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Cholesky::new().build(input, scope)
}
/// Builder for the `CholeskyGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CholeskyGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CholeskyGrad {
    /// Creates a new `CholeskyGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CholeskyGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        l: O0,
        grad: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(l.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        l: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CholeskyGrad", |nd| {
            nd.add_input(l);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CholeskyGrad::new().build(l, grad, scope)`.
pub fn cholesky_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    l: O0,
    grad: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CholeskyGrad::new().build(l, grad, scope)
}
/// Builder for the `ChooseFastestBranchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ChooseFastestBranchDataset {
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    num_elements_per_branch: ::std::option::Option<i64>,
    branches: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    other_arguments_lengths: ::std::option::Option<::std::vec::Vec<i64>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ChooseFastestBranchDataset {
    /// Creates a new `ChooseFastestBranchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_elements_per_branch` attribute.
    pub fn num_elements_per_branch<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_elements_per_branch = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `branches` attribute.
    pub fn branches<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.branches = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `other_arguments_lengths` attribute.
    pub fn other_arguments_lengths<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.other_arguments_lengths = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ChooseFastestBranchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        ratio_numerator: O1,
        ratio_denominator: O2,
        other_arguments: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            ratio_numerator.into(),
            ratio_denominator.into(),
            other_arguments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        ratio_numerator: crate::Output,
        ratio_denominator: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ChooseFastestBranchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(ratio_numerator);
            nd.add_input(ratio_denominator);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_elements_per_branch {
                nd.set_attr_int("num_elements_per_branch", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.branches {
                nd.set_attr_string_list("branches", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.other_arguments_lengths {
                nd.set_attr_int_list("other_arguments_lengths", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ChooseFastestBranchDataset::new().build(input_dataset, ratio_numerator, ratio_denominator, other_arguments, scope)`.
pub fn choose_fastest_branch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    ratio_numerator: O1,
    ratio_denominator: O2,
    other_arguments: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ChooseFastestBranchDataset::new().build(
        input_dataset,
        ratio_numerator,
        ratio_denominator,
        other_arguments,
        scope,
    )
}
/// Builder for the `ChooseFastestDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ChooseFastestDataset {
    N: ::std::option::Option<i64>,
    num_experiments: ::std::option::Option<i64>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ChooseFastestDataset {
    /// Creates a new `ChooseFastestDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_experiments` attribute.
    pub fn num_experiments<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_experiments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ChooseFastestDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_datasets: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_datasets.into(), scope)
    }

    fn build_impl(
        &self,
        input_datasets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ChooseFastestDataset", |nd| {
            nd.add_input(input_datasets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_experiments {
                nd.set_attr_int("num_experiments", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ChooseFastestDataset::new().build(input_datasets, scope)`.
pub fn choose_fastest_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_datasets: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ChooseFastestDataset::new().build(input_datasets, scope)
}
/// Builder for the `ClipByValue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ClipByValue {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ClipByValue {
    /// Creates a new `ClipByValue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ClipByValue` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        t: O0,
        clip_value_min: O1,
        clip_value_max: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            t.into(),
            clip_value_min.into(),
            clip_value_max.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        t: crate::Output,
        clip_value_min: crate::Output,
        clip_value_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ClipByValue", |nd| {
            nd.add_input(t);
            nd.add_input(clip_value_min);
            nd.add_input(clip_value_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ClipByValue::new().build(t, clip_value_min, clip_value_max, scope)`.
pub fn clip_by_value<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    t: O0,
    clip_value_min: O1,
    clip_value_max: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ClipByValue::new().build(t, clip_value_min, clip_value_max, scope)
}
/// Builder for the `CloseSummaryWriter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CloseSummaryWriter {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CloseSummaryWriter {
    /// Creates a new `CloseSummaryWriter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CloseSummaryWriter` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        writer: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(writer.into(), scope)
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CloseSummaryWriter", |nd| {
            nd.add_input(writer);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CloseSummaryWriter::new().build(writer, scope)`.
pub fn close_summary_writer<O0: ::std::convert::Into<crate::Output>>(
    writer: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CloseSummaryWriter::new().build(writer, scope)
}
/// Builder for the `CollectiveBcastRecv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveBcastRecv {
    T: ::std::option::Option<crate::DataType>,
    group_size: ::std::option::Option<i64>,
    group_key: ::std::option::Option<i64>,
    instance_key: ::std::option::Option<i64>,
    shape: ::std::option::Option<crate::Shape>,
    communication_hint: ::std::option::Option<::std::string::String>,
    timeout_seconds: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CollectiveBcastRecv {
    /// Creates a new `CollectiveBcastRecv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `group_size` attribute.
    pub fn group_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.group_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `group_key` attribute.
    pub fn group_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.group_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `instance_key` attribute.
    pub fn instance_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.instance_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `communication_hint` attribute.
    pub fn communication_hint<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.communication_hint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_seconds` attribute.
    pub fn timeout_seconds<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.timeout_seconds = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CollectiveBcastRecv` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("CollectiveBcastRecv", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.group_size {
                nd.set_attr_int("group_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.group_key {
                nd.set_attr_int("group_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.instance_key {
                nd.set_attr_int("instance_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.communication_hint {
                nd.set_attr_string("communication_hint", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_seconds {
                nd.set_attr_float("timeout_seconds", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CollectiveBcastRecv::new().build(scope)`.
pub fn collective_bcast_recv(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    CollectiveBcastRecv::new().build(scope)
}
/// Builder for the `CollectiveBcastSend` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveBcastSend {
    T: ::std::option::Option<crate::DataType>,
    group_size: ::std::option::Option<i64>,
    group_key: ::std::option::Option<i64>,
    instance_key: ::std::option::Option<i64>,
    shape: ::std::option::Option<crate::Shape>,
    communication_hint: ::std::option::Option<::std::string::String>,
    timeout_seconds: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CollectiveBcastSend {
    /// Creates a new `CollectiveBcastSend`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `group_size` attribute.
    pub fn group_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.group_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `group_key` attribute.
    pub fn group_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.group_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `instance_key` attribute.
    pub fn instance_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.instance_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `communication_hint` attribute.
    pub fn communication_hint<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.communication_hint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_seconds` attribute.
    pub fn timeout_seconds<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.timeout_seconds = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CollectiveBcastSend` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CollectiveBcastSend", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.group_size {
                nd.set_attr_int("group_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.group_key {
                nd.set_attr_int("group_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.instance_key {
                nd.set_attr_int("instance_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.communication_hint {
                nd.set_attr_string("communication_hint", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_seconds {
                nd.set_attr_float("timeout_seconds", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CollectiveBcastSend::new().build(input, scope)`.
pub fn collective_bcast_send<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CollectiveBcastSend::new().build(input, scope)
}
/// Builder for the `CollectiveGather` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveGather {
    T: ::std::option::Option<crate::DataType>,
    group_size: ::std::option::Option<i64>,
    group_key: ::std::option::Option<i64>,
    instance_key: ::std::option::Option<i64>,
    shape: ::std::option::Option<crate::Shape>,
    communication_hint: ::std::option::Option<::std::string::String>,
    timeout_seconds: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CollectiveGather {
    /// Creates a new `CollectiveGather`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `group_size` attribute.
    pub fn group_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.group_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `group_key` attribute.
    pub fn group_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.group_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `instance_key` attribute.
    pub fn instance_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.instance_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `communication_hint` attribute.
    pub fn communication_hint<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.communication_hint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_seconds` attribute.
    pub fn timeout_seconds<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.timeout_seconds = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CollectiveGather` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CollectiveGather", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.group_size {
                nd.set_attr_int("group_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.group_key {
                nd.set_attr_int("group_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.instance_key {
                nd.set_attr_int("instance_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.communication_hint {
                nd.set_attr_string("communication_hint", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_seconds {
                nd.set_attr_float("timeout_seconds", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CollectiveGather::new().build(input, scope)`.
pub fn collective_gather<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CollectiveGather::new().build(input, scope)
}
/// Builder for the `CollectivePermute` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectivePermute {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CollectivePermute {
    /// Creates a new `CollectivePermute`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CollectivePermute` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        source_target_pairs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), source_target_pairs.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        source_target_pairs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CollectivePermute", |nd| {
            nd.add_input(input);
            nd.add_input(source_target_pairs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CollectivePermute::new().build(input, source_target_pairs, scope)`.
pub fn collective_permute<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    source_target_pairs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CollectivePermute::new().build(input, source_target_pairs, scope)
}
/// Builder for the `CollectiveReduce` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CollectiveReduce {
    T: ::std::option::Option<crate::DataType>,
    group_size: ::std::option::Option<i64>,
    group_key: ::std::option::Option<i64>,
    instance_key: ::std::option::Option<i64>,
    merge_op: ::std::option::Option<::std::string::String>,
    final_op: ::std::option::Option<::std::string::String>,
    subdiv_offsets: ::std::option::Option<::std::vec::Vec<i64>>,
    wait_for: ::std::option::Option<::std::vec::Vec<i64>>,
    communication_hint: ::std::option::Option<::std::string::String>,
    timeout_seconds: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CollectiveReduce {
    /// Creates a new `CollectiveReduce`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `group_size` attribute.
    pub fn group_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.group_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `group_key` attribute.
    pub fn group_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.group_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `instance_key` attribute.
    pub fn instance_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.instance_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `merge_op` attribute.
    pub fn merge_op<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.merge_op = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `final_op` attribute.
    pub fn final_op<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.final_op = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `subdiv_offsets` attribute.
    pub fn subdiv_offsets<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.subdiv_offsets = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `wait_for` attribute.
    pub fn wait_for<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.wait_for = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `communication_hint` attribute.
    pub fn communication_hint<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.communication_hint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_seconds` attribute.
    pub fn timeout_seconds<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.timeout_seconds = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CollectiveReduce` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CollectiveReduce", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.group_size {
                nd.set_attr_int("group_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.group_key {
                nd.set_attr_int("group_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.instance_key {
                nd.set_attr_int("instance_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.merge_op {
                nd.set_attr_string("merge_op", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.final_op {
                nd.set_attr_string("final_op", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.subdiv_offsets {
                nd.set_attr_int_list("subdiv_offsets", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.wait_for {
                nd.set_attr_int_list("wait_for", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.communication_hint {
                nd.set_attr_string("communication_hint", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_seconds {
                nd.set_attr_float("timeout_seconds", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CollectiveReduce::new().build(input, scope)`.
pub fn collective_reduce<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CollectiveReduce::new().build(input, scope)
}
/// Builder for the `CombinedNonMaxSuppression` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CombinedNonMaxSuppression {
    pad_per_class: ::std::option::Option<bool>,
    clip_boxes: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CombinedNonMaxSuppression {
    /// Creates a new `CombinedNonMaxSuppression`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `pad_per_class` attribute.
    pub fn pad_per_class<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.pad_per_class = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `clip_boxes` attribute.
    pub fn clip_boxes<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.clip_boxes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CombinedNonMaxSuppression` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        boxes: O0,
        scores: O1,
        max_output_size_per_class: O2,
        max_total_size: O3,
        iou_threshold: O4,
        score_threshold: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            boxes.into(),
            scores.into(),
            max_output_size_per_class.into(),
            max_total_size.into(),
            iou_threshold.into(),
            score_threshold.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        boxes: crate::Output,
        scores: crate::Output,
        max_output_size_per_class: crate::Output,
        max_total_size: crate::Output,
        iou_threshold: crate::Output,
        score_threshold: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CombinedNonMaxSuppression", |nd| {
            nd.add_input(boxes);
            nd.add_input(scores);
            nd.add_input(max_output_size_per_class);
            nd.add_input(max_total_size);
            nd.add_input(iou_threshold);
            nd.add_input(score_threshold);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.pad_per_class {
                nd.set_attr_bool("pad_per_class", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.clip_boxes {
                nd.set_attr_bool("clip_boxes", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CombinedNonMaxSuppression::new().build(boxes, scores, max_output_size_per_class, max_total_size, iou_threshold, score_threshold, scope)`.
pub fn combined_non_max_suppression<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    boxes: O0,
    scores: O1,
    max_output_size_per_class: O2,
    max_total_size: O3,
    iou_threshold: O4,
    score_threshold: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CombinedNonMaxSuppression::new().build(
        boxes,
        scores,
        max_output_size_per_class,
        max_total_size,
        iou_threshold,
        score_threshold,
        scope,
    )
}
/// Builder for the `CompareAndBitpack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CompareAndBitpack {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CompareAndBitpack {
    /// Creates a new `CompareAndBitpack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CompareAndBitpack` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        threshold: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), threshold.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        threshold: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CompareAndBitpack", |nd| {
            nd.add_input(input);
            nd.add_input(threshold);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CompareAndBitpack::new().build(input, threshold, scope)`.
pub fn compare_and_bitpack<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    threshold: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CompareAndBitpack::new().build(input, threshold, scope)
}
/// Builder for the `Complex` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Complex {
    T: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Complex {
    /// Creates a new `Complex`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Complex` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        real: O0,
        imag: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(real.into(), imag.into(), scope)
    }

    fn build_impl(
        &self,
        real: crate::Output,
        imag: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Complex", |nd| {
            nd.add_input(real);
            nd.add_input(imag);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Complex::new().build(real, imag, scope)`.
pub fn complex<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    real: O0,
    imag: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Complex::new().build(real, imag, scope)
}
/// Builder for the `ComplexAbs` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ComplexAbs {
    T: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ComplexAbs {
    /// Creates a new `ComplexAbs`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ComplexAbs` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ComplexAbs", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ComplexAbs::new().build(x, scope)`.
pub fn complex_abs<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ComplexAbs::new().build(x, scope)
}
/// Builder for the `CompressElement` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CompressElement {
    input_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CompressElement {
    /// Creates a new `CompressElement`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `input_types` attribute.
    pub fn input_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CompressElement` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        components: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(components.into(), scope)
    }

    fn build_impl(
        &self,
        components: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CompressElement", |nd| {
            nd.add_input(components);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.input_types {
                nd.set_attr_type_list("input_types", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CompressElement::new().build(components, scope)`.
pub fn compress_element<O0: ::std::convert::Into<crate::Output>>(
    components: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CompressElement::new().build(components, scope)
}
/// Builder for the `ComputeAccidentalHits` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ComputeAccidentalHits {
    num_true: ::std::option::Option<i64>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ComputeAccidentalHits {
    /// Creates a new `ComputeAccidentalHits`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_true` attribute.
    pub fn num_true<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_true = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ComputeAccidentalHits` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        true_classes: O0,
        sampled_candidates: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(true_classes.into(), sampled_candidates.into(), scope)
    }

    fn build_impl(
        &self,
        true_classes: crate::Output,
        sampled_candidates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ComputeAccidentalHits", |nd| {
            nd.add_input(true_classes);
            nd.add_input(sampled_candidates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_true {
                nd.set_attr_int("num_true", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ComputeAccidentalHits::new().build(true_classes, sampled_candidates, scope)`.
pub fn compute_accidental_hits<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    true_classes: O0,
    sampled_candidates: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ComputeAccidentalHits::new().build(true_classes, sampled_candidates, scope)
}
/// Builder for the `Concat` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Concat {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Concat {
    /// Creates a new `Concat`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Concat` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        concat_dim: O0,
        values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(concat_dim.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        concat_dim: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Concat", |nd| {
            nd.add_input(concat_dim);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Concat::new().build(concat_dim, values, scope)`.
pub fn concat<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    concat_dim: O0,
    values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Concat::new().build(concat_dim, values, scope)
}
/// Builder for the `ConcatOffset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConcatOffset {
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ConcatOffset {
    /// Creates a new `ConcatOffset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ConcatOffset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        concat_dim: O0,
        shape: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(concat_dim.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        concat_dim: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ConcatOffset", |nd| {
            nd.add_input(concat_dim);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ConcatOffset::new().build(concat_dim, shape, scope)`.
pub fn concat_offset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    concat_dim: O0,
    shape: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ConcatOffset::new().build(concat_dim, shape, scope)
}
/// Builder for the `ConcatV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConcatV2 {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ConcatV2 {
    /// Creates a new `ConcatV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ConcatV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        values: O0,
        axis: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(values.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        values: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ConcatV2", |nd| {
            nd.add_input(values);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ConcatV2::new().build(values, axis, scope)`.
pub fn concat_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    values: O0,
    axis: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ConcatV2::new().build(values, axis, scope)
}
/// Builder for the `ConcatenateDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConcatenateDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ConcatenateDataset {
    /// Creates a new `ConcatenateDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ConcatenateDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        another_dataset: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), another_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        another_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ConcatenateDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(another_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ConcatenateDataset::new().build(input_dataset, another_dataset, scope)`.
pub fn concatenate_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    another_dataset: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ConcatenateDataset::new().build(input_dataset, another_dataset, scope)
}
/// Builder for the `ConditionalAccumulator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConditionalAccumulator {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    reduction_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ConditionalAccumulator {
    /// Creates a new `ConditionalAccumulator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reduction_type` attribute.
    pub fn reduction_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduction_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ConditionalAccumulator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ConditionalAccumulator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reduction_type {
                nd.set_attr_string("reduction_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ConditionalAccumulator::new().build(scope)`.
pub fn conditional_accumulator(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    ConditionalAccumulator::new().build(scope)
}
/// Builder for the `ConfigureDistributedTPU` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConfigureDistributedTPU {
    embedding_config: ::std::option::Option<::std::string::String>,
    tpu_embedding_config: ::std::option::Option<::std::string::String>,
    is_global_init: ::std::option::Option<bool>,
    enable_whole_mesh_compilations: ::std::option::Option<bool>,
    compilation_failure_closes_chips: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ConfigureDistributedTPU {
    /// Creates a new `ConfigureDistributedTPU`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `embedding_config` attribute.
    pub fn embedding_config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.embedding_config = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tpu_embedding_config` attribute.
    pub fn tpu_embedding_config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tpu_embedding_config = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_global_init` attribute.
    pub fn is_global_init<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_global_init = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `enable_whole_mesh_compilations` attribute.
    pub fn enable_whole_mesh_compilations<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.enable_whole_mesh_compilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `compilation_failure_closes_chips` attribute.
    pub fn compilation_failure_closes_chips<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compilation_failure_closes_chips = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ConfigureDistributedTPU` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ConfigureDistributedTPU", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.embedding_config {
                nd.set_attr_string("embedding_config", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tpu_embedding_config {
                nd.set_attr_string("tpu_embedding_config", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_global_init {
                nd.set_attr_bool("is_global_init", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.enable_whole_mesh_compilations {
                nd.set_attr_bool("enable_whole_mesh_compilations", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.compilation_failure_closes_chips {
                nd.set_attr_bool("compilation_failure_closes_chips", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ConfigureDistributedTPU::new().build(scope)`.
pub fn configure_distributed_tpu(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    ConfigureDistributedTPU::new().build(scope)
}
/// Builder for the `ConfigureTPUEmbedding` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConfigureTPUEmbedding {
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ConfigureTPUEmbedding {
    /// Creates a new `ConfigureTPUEmbedding`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ConfigureTPUEmbedding` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ConfigureTPUEmbedding", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ConfigureTPUEmbedding::new().build(scope)`.
pub fn configure_tpuembedding(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    ConfigureTPUEmbedding::new().build(scope)
}
/// Builder for the `Conj` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conj {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conj {
    /// Creates a new `Conj`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conj` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conj", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conj::new().build(input, scope)`.
pub fn conj<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conj::new().build(input, scope)
}
/// Builder for the `ConjugateTranspose` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConjugateTranspose {
    T: ::std::option::Option<crate::DataType>,
    Tperm: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ConjugateTranspose {
    /// Creates a new `ConjugateTranspose`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tperm` attribute.
    pub fn Tperm<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tperm = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ConjugateTranspose` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        perm: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), perm.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        perm: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ConjugateTranspose", |nd| {
            nd.add_input(x);
            nd.add_input(perm);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tperm {
                nd.set_attr_type("Tperm", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ConjugateTranspose::new().build(x, perm, scope)`.
pub fn conjugate_transpose<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    perm: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ConjugateTranspose::new().build(x, perm, scope)
}
/// Builder for the `Const` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Const {
    value: ::std::option::Option<::std::boxed::Box<dyn crate::AnyTensor>>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Const {
    /// Creates a new `Const`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `value` attribute.
    pub fn value<T: crate::TensorType, ArgType: ::std::convert::Into<crate::Tensor<T>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value = ::std::option::Option::Some(
            (::std::boxed::Box::new(value.into()) as ::std::boxed::Box<dyn crate::AnyTensor>),
        );
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Const` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Const", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.value {
                nd.set_attr_any_tensor("value", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Const::new().build(scope)`.
pub fn const_(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Const::new().build(scope)
}
/// Builder for the `ConsumeMutexLock` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ConsumeMutexLock {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ConsumeMutexLock {
    /// Creates a new `ConsumeMutexLock`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ConsumeMutexLock` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        mutex_lock: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(mutex_lock.into(), scope)
    }

    fn build_impl(
        &self,
        mutex_lock: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ConsumeMutexLock", |nd| {
            nd.add_input(mutex_lock);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ConsumeMutexLock::new().build(mutex_lock, scope)`.
pub fn consume_mutex_lock<O0: ::std::convert::Into<crate::Output>>(
    mutex_lock: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ConsumeMutexLock::new().build(mutex_lock, scope)
}
/// Builder for the `ControlTrigger` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ControlTrigger {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ControlTrigger {
    /// Creates a new `ControlTrigger`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ControlTrigger` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ControlTrigger", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ControlTrigger::new().build(scope)`.
pub fn control_trigger(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    ControlTrigger::new().build(scope)
}
/// Builder for the `Conv2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv2D {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    use_cudnn_on_gpu: ::std::option::Option<bool>,
    padding: ::std::option::Option<::std::string::String>,
    explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conv2D {
    /// Creates a new `Conv2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_cudnn_on_gpu` attribute.
    pub fn use_cudnn_on_gpu<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_cudnn_on_gpu = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `explicit_paddings` attribute.
    pub fn explicit_paddings<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.explicit_paddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conv2D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), filter.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conv2D", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_cudnn_on_gpu {
                nd.set_attr_bool("use_cudnn_on_gpu", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.explicit_paddings {
                nd.set_attr_int_list("explicit_paddings", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conv2D::new().build(input, filter, scope)`.
pub fn conv2_d<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    filter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conv2D::new().build(input, filter, scope)
}
/// Builder for the `Conv2DBackpropFilter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv2DBackpropFilter {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    use_cudnn_on_gpu: ::std::option::Option<bool>,
    padding: ::std::option::Option<::std::string::String>,
    explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conv2DBackpropFilter {
    /// Creates a new `Conv2DBackpropFilter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_cudnn_on_gpu` attribute.
    pub fn use_cudnn_on_gpu<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_cudnn_on_gpu = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `explicit_paddings` attribute.
    pub fn explicit_paddings<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.explicit_paddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conv2DBackpropFilter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter_sizes: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter_sizes.into(),
            out_backprop.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter_sizes: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conv2DBackpropFilter", |nd| {
            nd.add_input(input);
            nd.add_input(filter_sizes);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_cudnn_on_gpu {
                nd.set_attr_bool("use_cudnn_on_gpu", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.explicit_paddings {
                nd.set_attr_int_list("explicit_paddings", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conv2DBackpropFilter::new().build(input, filter_sizes, out_backprop, scope)`.
pub fn conv2_dbackprop_filter<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter_sizes: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conv2DBackpropFilter::new().build(input, filter_sizes, out_backprop, scope)
}
/// Builder for the `Conv2DBackpropInput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv2DBackpropInput {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    use_cudnn_on_gpu: ::std::option::Option<bool>,
    padding: ::std::option::Option<::std::string::String>,
    explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conv2DBackpropInput {
    /// Creates a new `Conv2DBackpropInput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_cudnn_on_gpu` attribute.
    pub fn use_cudnn_on_gpu<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_cudnn_on_gpu = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `explicit_paddings` attribute.
    pub fn explicit_paddings<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.explicit_paddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conv2DBackpropInput` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_sizes: O0,
        filter: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_sizes.into(),
            filter.into(),
            out_backprop.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_sizes: crate::Output,
        filter: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conv2DBackpropInput", |nd| {
            nd.add_input(input_sizes);
            nd.add_input(filter);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_cudnn_on_gpu {
                nd.set_attr_bool("use_cudnn_on_gpu", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.explicit_paddings {
                nd.set_attr_int_list("explicit_paddings", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conv2DBackpropInput::new().build(input_sizes, filter, out_backprop, scope)`.
pub fn conv2_dbackprop_input<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_sizes: O0,
    filter: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conv2DBackpropInput::new().build(input_sizes, filter, out_backprop, scope)
}
/// Builder for the `Conv3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3D {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conv3D {
    /// Creates a new `Conv3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conv3D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), filter.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conv3D", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conv3D::new().build(input, filter, scope)`.
pub fn conv3_d<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    filter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conv3D::new().build(input, filter, scope)
}
/// Builder for the `Conv3DBackpropFilter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3DBackpropFilter {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conv3DBackpropFilter {
    /// Creates a new `Conv3DBackpropFilter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conv3DBackpropFilter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), filter.into(), out_backprop.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conv3DBackpropFilter", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conv3DBackpropFilter::new().build(input, filter, out_backprop, scope)`.
pub fn conv3_dbackprop_filter<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conv3DBackpropFilter::new().build(input, filter, out_backprop, scope)
}
/// Builder for the `Conv3DBackpropFilterV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3DBackpropFilterV2 {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conv3DBackpropFilterV2 {
    /// Creates a new `Conv3DBackpropFilterV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conv3DBackpropFilterV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter_sizes: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter_sizes.into(),
            out_backprop.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter_sizes: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conv3DBackpropFilterV2", |nd| {
            nd.add_input(input);
            nd.add_input(filter_sizes);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conv3DBackpropFilterV2::new().build(input, filter_sizes, out_backprop, scope)`.
pub fn conv3_dbackprop_filter_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter_sizes: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conv3DBackpropFilterV2::new().build(input, filter_sizes, out_backprop, scope)
}
/// Builder for the `Conv3DBackpropInput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3DBackpropInput {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conv3DBackpropInput {
    /// Creates a new `Conv3DBackpropInput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conv3DBackpropInput` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), filter.into(), out_backprop.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conv3DBackpropInput", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conv3DBackpropInput::new().build(input, filter, out_backprop, scope)`.
pub fn conv3_dbackprop_input<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conv3DBackpropInput::new().build(input, filter, out_backprop, scope)
}
/// Builder for the `Conv3DBackpropInputV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Conv3DBackpropInputV2 {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    Tshape: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Conv3DBackpropInputV2 {
    /// Creates a new `Conv3DBackpropInputV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tshape` attribute.
    pub fn Tshape<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tshape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Conv3DBackpropInputV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_sizes: O0,
        filter: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_sizes.into(),
            filter.into(),
            out_backprop.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_sizes: crate::Output,
        filter: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Conv3DBackpropInputV2", |nd| {
            nd.add_input(input_sizes);
            nd.add_input(filter);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tshape {
                nd.set_attr_type("Tshape", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Conv3DBackpropInputV2::new().build(input_sizes, filter, out_backprop, scope)`.
pub fn conv3_dbackprop_input_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_sizes: O0,
    filter: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Conv3DBackpropInputV2::new().build(input_sizes, filter, out_backprop, scope)
}
/// Builder for the `Copy` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Copy {
    T: ::std::option::Option<crate::DataType>,
    tensor_name: ::std::option::Option<::std::string::String>,
    debug_ops_spec: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Copy {
    /// Creates a new `Copy`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_name` attribute.
    pub fn tensor_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `debug_ops_spec` attribute.
    pub fn debug_ops_spec<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.debug_ops_spec = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Copy` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Copy", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_name {
                nd.set_attr_string("tensor_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.debug_ops_spec {
                nd.set_attr_string_list("debug_ops_spec", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Copy::new().build(input, scope)`.
pub fn copy<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Copy::new().build(input, scope)
}
/// Builder for the `CopyHost` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CopyHost {
    T: ::std::option::Option<crate::DataType>,
    tensor_name: ::std::option::Option<::std::string::String>,
    debug_ops_spec: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CopyHost {
    /// Creates a new `CopyHost`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_name` attribute.
    pub fn tensor_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `debug_ops_spec` attribute.
    pub fn debug_ops_spec<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.debug_ops_spec = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CopyHost` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CopyHost", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_name {
                nd.set_attr_string("tensor_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.debug_ops_spec {
                nd.set_attr_string_list("debug_ops_spec", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CopyHost::new().build(input, scope)`.
pub fn copy_host<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CopyHost::new().build(input, scope)
}
/// Builder for the `Cos` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cos {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Cos {
    /// Creates a new `Cos`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Cos` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Cos", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Cos::new().build(x, scope)`.
pub fn cos<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Cos::new().build(x, scope)
}
/// Builder for the `Cosh` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cosh {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Cosh {
    /// Creates a new `Cosh`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Cosh` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Cosh", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Cosh::new().build(x, scope)`.
pub fn cosh<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Cosh::new().build(x, scope)
}
/// Builder for the `CountUpTo` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CountUpTo {
    limit: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CountUpTo {
    /// Creates a new `CountUpTo`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `limit` attribute.
    pub fn limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CountUpTo` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        ref_: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CountUpTo", |nd| {
            nd.add_input(ref_);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.limit {
                nd.set_attr_int("limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CountUpTo::new().build(ref_, scope)`.
pub fn count_up_to<O0: ::std::convert::Into<crate::Output>>(
    ref_: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CountUpTo::new().build(ref_, scope)
}
/// Builder for the `CreateSummaryDbWriter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CreateSummaryDbWriter {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CreateSummaryDbWriter {
    /// Creates a new `CreateSummaryDbWriter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CreateSummaryDbWriter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        db_uri: O1,
        experiment_name: O2,
        run_name: O3,
        user_name: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            writer.into(),
            db_uri.into(),
            experiment_name.into(),
            run_name.into(),
            user_name.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        db_uri: crate::Output,
        experiment_name: crate::Output,
        run_name: crate::Output,
        user_name: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CreateSummaryDbWriter", |nd| {
            nd.add_input(writer);
            nd.add_input(db_uri);
            nd.add_input(experiment_name);
            nd.add_input(run_name);
            nd.add_input(user_name);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CreateSummaryDbWriter::new().build(writer, db_uri, experiment_name, run_name, user_name, scope)`.
pub fn create_summary_db_writer<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    db_uri: O1,
    experiment_name: O2,
    run_name: O3,
    user_name: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CreateSummaryDbWriter::new().build(writer, db_uri, experiment_name, run_name, user_name, scope)
}
/// Builder for the `CreateSummaryFileWriter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CreateSummaryFileWriter {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CreateSummaryFileWriter {
    /// Creates a new `CreateSummaryFileWriter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CreateSummaryFileWriter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        logdir: O1,
        max_queue: O2,
        flush_millis: O3,
        filename_suffix: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            writer.into(),
            logdir.into(),
            max_queue.into(),
            flush_millis.into(),
            filename_suffix.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        logdir: crate::Output,
        max_queue: crate::Output,
        flush_millis: crate::Output,
        filename_suffix: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CreateSummaryFileWriter", |nd| {
            nd.add_input(writer);
            nd.add_input(logdir);
            nd.add_input(max_queue);
            nd.add_input(flush_millis);
            nd.add_input(filename_suffix);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CreateSummaryFileWriter::new().build(writer, logdir, max_queue, flush_millis, filename_suffix, scope)`.
pub fn create_summary_file_writer<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    logdir: O1,
    max_queue: O2,
    flush_millis: O3,
    filename_suffix: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CreateSummaryFileWriter::new().build(
        writer,
        logdir,
        max_queue,
        flush_millis,
        filename_suffix,
        scope,
    )
}
/// Builder for the `CropAndResize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CropAndResize {
    T: ::std::option::Option<crate::DataType>,
    method: ::std::option::Option<::std::string::String>,
    extrapolation_value: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CropAndResize {
    /// Creates a new `CropAndResize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `method` attribute.
    pub fn method<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.method = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `extrapolation_value` attribute.
    pub fn extrapolation_value<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.extrapolation_value = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CropAndResize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        image: O0,
        boxes: O1,
        box_ind: O2,
        crop_size: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            image.into(),
            boxes.into(),
            box_ind.into(),
            crop_size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        image: crate::Output,
        boxes: crate::Output,
        box_ind: crate::Output,
        crop_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CropAndResize", |nd| {
            nd.add_input(image);
            nd.add_input(boxes);
            nd.add_input(box_ind);
            nd.add_input(crop_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.method {
                nd.set_attr_string("method", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.extrapolation_value {
                nd.set_attr_float("extrapolation_value", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CropAndResize::new().build(image, boxes, box_ind, crop_size, scope)`.
pub fn crop_and_resize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    image: O0,
    boxes: O1,
    box_ind: O2,
    crop_size: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CropAndResize::new().build(image, boxes, box_ind, crop_size, scope)
}
/// Builder for the `CropAndResizeGradBoxes` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CropAndResizeGradBoxes {
    T: ::std::option::Option<crate::DataType>,
    method: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CropAndResizeGradBoxes {
    /// Creates a new `CropAndResizeGradBoxes`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `method` attribute.
    pub fn method<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.method = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CropAndResizeGradBoxes` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        grads: O0,
        image: O1,
        boxes: O2,
        box_ind: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            grads.into(),
            image.into(),
            boxes.into(),
            box_ind.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        grads: crate::Output,
        image: crate::Output,
        boxes: crate::Output,
        box_ind: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CropAndResizeGradBoxes", |nd| {
            nd.add_input(grads);
            nd.add_input(image);
            nd.add_input(boxes);
            nd.add_input(box_ind);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.method {
                nd.set_attr_string("method", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CropAndResizeGradBoxes::new().build(grads, image, boxes, box_ind, scope)`.
pub fn crop_and_resize_grad_boxes<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    grads: O0,
    image: O1,
    boxes: O2,
    box_ind: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CropAndResizeGradBoxes::new().build(grads, image, boxes, box_ind, scope)
}
/// Builder for the `CropAndResizeGradImage` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CropAndResizeGradImage {
    T: ::std::option::Option<crate::DataType>,
    method: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CropAndResizeGradImage {
    /// Creates a new `CropAndResizeGradImage`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `method` attribute.
    pub fn method<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.method = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CropAndResizeGradImage` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        grads: O0,
        boxes: O1,
        box_ind: O2,
        image_size: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            grads.into(),
            boxes.into(),
            box_ind.into(),
            image_size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        grads: crate::Output,
        boxes: crate::Output,
        box_ind: crate::Output,
        image_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CropAndResizeGradImage", |nd| {
            nd.add_input(grads);
            nd.add_input(boxes);
            nd.add_input(box_ind);
            nd.add_input(image_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.method {
                nd.set_attr_string("method", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CropAndResizeGradImage::new().build(grads, boxes, box_ind, image_size, scope)`.
pub fn crop_and_resize_grad_image<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    grads: O0,
    boxes: O1,
    box_ind: O2,
    image_size: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CropAndResizeGradImage::new().build(grads, boxes, box_ind, image_size, scope)
}
/// Builder for the `Cross` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cross {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Cross {
    /// Creates a new `Cross`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Cross` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), b.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Cross", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Cross::new().build(a, b, scope)`.
pub fn cross<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    a: O0,
    b: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Cross::new().build(a, b, scope)
}
/// Builder for the `CrossReplicaSum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CrossReplicaSum {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CrossReplicaSum {
    /// Creates a new `CrossReplicaSum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CrossReplicaSum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        group_assignment: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), group_assignment.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        group_assignment: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CrossReplicaSum", |nd| {
            nd.add_input(input);
            nd.add_input(group_assignment);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CrossReplicaSum::new().build(input, group_assignment, scope)`.
pub fn cross_replica_sum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    group_assignment: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CrossReplicaSum::new().build(input, group_assignment, scope)
}
/// Builder for the `CudnnRNN` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNN {
    T: ::std::option::Option<crate::DataType>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    is_training: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNN {
    /// Creates a new `CudnnRNN`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNN` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_h: O1,
        input_c: O2,
        params: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_h.into(),
            input_c.into(),
            params.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_h: crate::Output,
        input_c: crate::Output,
        params: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNN", |nd| {
            nd.add_input(input);
            nd.add_input(input_h);
            nd.add_input(input_c);
            nd.add_input(params);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNN::new().build(input, input_h, input_c, params, scope)`.
pub fn cudnn_rnn<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_h: O1,
    input_c: O2,
    params: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNN::new().build(input, input_h, input_c, params, scope)
}
/// Builder for the `CudnnRNNBackprop` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNBackprop {
    T: ::std::option::Option<crate::DataType>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNBackprop {
    /// Creates a new `CudnnRNNBackprop`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNBackprop` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_h: O1,
        input_c: O2,
        params: O3,
        output: O4,
        output_h: O5,
        output_c: O6,
        output_backprop: O7,
        output_h_backprop: O8,
        output_c_backprop: O9,
        reserve_space: O10,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_h.into(),
            input_c.into(),
            params.into(),
            output.into(),
            output_h.into(),
            output_c.into(),
            output_backprop.into(),
            output_h_backprop.into(),
            output_c_backprop.into(),
            reserve_space.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_h: crate::Output,
        input_c: crate::Output,
        params: crate::Output,
        output: crate::Output,
        output_h: crate::Output,
        output_c: crate::Output,
        output_backprop: crate::Output,
        output_h_backprop: crate::Output,
        output_c_backprop: crate::Output,
        reserve_space: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNBackprop", |nd| {
            nd.add_input(input);
            nd.add_input(input_h);
            nd.add_input(input_c);
            nd.add_input(params);
            nd.add_input(output);
            nd.add_input(output_h);
            nd.add_input(output_c);
            nd.add_input(output_backprop);
            nd.add_input(output_h_backprop);
            nd.add_input(output_c_backprop);
            nd.add_input(reserve_space);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNBackprop::new().build(input, input_h, input_c, params, output, output_h, output_c, output_backprop, output_h_backprop, output_c_backprop, reserve_space, scope)`.
pub fn cudnn_rnnbackprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_h: O1,
    input_c: O2,
    params: O3,
    output: O4,
    output_h: O5,
    output_c: O6,
    output_backprop: O7,
    output_h_backprop: O8,
    output_c_backprop: O9,
    reserve_space: O10,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNBackprop::new().build(
        input,
        input_h,
        input_c,
        params,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        scope,
    )
}
/// Builder for the `CudnnRNNBackpropV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNBackpropV2 {
    T: ::std::option::Option<crate::DataType>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNBackpropV2 {
    /// Creates a new `CudnnRNNBackpropV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNBackpropV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_h: O1,
        input_c: O2,
        params: O3,
        output: O4,
        output_h: O5,
        output_c: O6,
        output_backprop: O7,
        output_h_backprop: O8,
        output_c_backprop: O9,
        reserve_space: O10,
        host_reserved: O11,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_h.into(),
            input_c.into(),
            params.into(),
            output.into(),
            output_h.into(),
            output_c.into(),
            output_backprop.into(),
            output_h_backprop.into(),
            output_c_backprop.into(),
            reserve_space.into(),
            host_reserved.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_h: crate::Output,
        input_c: crate::Output,
        params: crate::Output,
        output: crate::Output,
        output_h: crate::Output,
        output_c: crate::Output,
        output_backprop: crate::Output,
        output_h_backprop: crate::Output,
        output_c_backprop: crate::Output,
        reserve_space: crate::Output,
        host_reserved: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNBackpropV2", |nd| {
            nd.add_input(input);
            nd.add_input(input_h);
            nd.add_input(input_c);
            nd.add_input(params);
            nd.add_input(output);
            nd.add_input(output_h);
            nd.add_input(output_c);
            nd.add_input(output_backprop);
            nd.add_input(output_h_backprop);
            nd.add_input(output_c_backprop);
            nd.add_input(reserve_space);
            nd.add_input(host_reserved);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNBackpropV2::new().build(input, input_h, input_c, params, output, output_h, output_c, output_backprop, output_h_backprop, output_c_backprop, reserve_space, host_reserved, scope)`.
pub fn cudnn_rnnbackprop_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_h: O1,
    input_c: O2,
    params: O3,
    output: O4,
    output_h: O5,
    output_c: O6,
    output_backprop: O7,
    output_h_backprop: O8,
    output_c_backprop: O9,
    reserve_space: O10,
    host_reserved: O11,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNBackpropV2::new().build(
        input,
        input_h,
        input_c,
        params,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        host_reserved,
        scope,
    )
}
/// Builder for the `CudnnRNNBackpropV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNBackpropV3 {
    T: ::std::option::Option<crate::DataType>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    num_proj: ::std::option::Option<i64>,
    time_major: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNBackpropV3 {
    /// Creates a new `CudnnRNNBackpropV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_proj` attribute.
    pub fn num_proj<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_proj = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `time_major` attribute.
    pub fn time_major<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.time_major = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNBackpropV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
        O12: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_h: O1,
        input_c: O2,
        params: O3,
        sequence_lengths: O4,
        output: O5,
        output_h: O6,
        output_c: O7,
        output_backprop: O8,
        output_h_backprop: O9,
        output_c_backprop: O10,
        reserve_space: O11,
        host_reserved: O12,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_h.into(),
            input_c.into(),
            params.into(),
            sequence_lengths.into(),
            output.into(),
            output_h.into(),
            output_c.into(),
            output_backprop.into(),
            output_h_backprop.into(),
            output_c_backprop.into(),
            reserve_space.into(),
            host_reserved.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_h: crate::Output,
        input_c: crate::Output,
        params: crate::Output,
        sequence_lengths: crate::Output,
        output: crate::Output,
        output_h: crate::Output,
        output_c: crate::Output,
        output_backprop: crate::Output,
        output_h_backprop: crate::Output,
        output_c_backprop: crate::Output,
        reserve_space: crate::Output,
        host_reserved: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNBackpropV3", |nd| {
            nd.add_input(input);
            nd.add_input(input_h);
            nd.add_input(input_c);
            nd.add_input(params);
            nd.add_input(sequence_lengths);
            nd.add_input(output);
            nd.add_input(output_h);
            nd.add_input(output_c);
            nd.add_input(output_backprop);
            nd.add_input(output_h_backprop);
            nd.add_input(output_c_backprop);
            nd.add_input(reserve_space);
            nd.add_input(host_reserved);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_proj {
                nd.set_attr_int("num_proj", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.time_major {
                nd.set_attr_bool("time_major", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNBackpropV3::new().build(input, input_h, input_c, params, sequence_lengths, output, output_h, output_c, output_backprop, output_h_backprop, output_c_backprop, reserve_space, host_reserved, scope)`.
pub fn cudnn_rnnbackprop_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
    O12: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_h: O1,
    input_c: O2,
    params: O3,
    sequence_lengths: O4,
    output: O5,
    output_h: O6,
    output_c: O7,
    output_backprop: O8,
    output_h_backprop: O9,
    output_c_backprop: O10,
    reserve_space: O11,
    host_reserved: O12,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNBackpropV3::new().build(
        input,
        input_h,
        input_c,
        params,
        sequence_lengths,
        output,
        output_h,
        output_c,
        output_backprop,
        output_h_backprop,
        output_c_backprop,
        reserve_space,
        host_reserved,
        scope,
    )
}
/// Builder for the `CudnnRNNCanonicalToParams` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNCanonicalToParams {
    T: ::std::option::Option<crate::DataType>,
    num_params: ::std::option::Option<i64>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNCanonicalToParams {
    /// Creates a new `CudnnRNNCanonicalToParams`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_params` attribute.
    pub fn num_params<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_params = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNCanonicalToParams` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        num_layers: O0,
        num_units: O1,
        input_size: O2,
        weights: O3,
        biases: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            num_layers.into(),
            num_units.into(),
            input_size.into(),
            weights.into(),
            biases.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        num_layers: crate::Output,
        num_units: crate::Output,
        input_size: crate::Output,
        weights: crate::Output,
        biases: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNCanonicalToParams", |nd| {
            nd.add_input(num_layers);
            nd.add_input(num_units);
            nd.add_input(input_size);
            nd.add_input(weights);
            nd.add_input(biases);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_params {
                nd.set_attr_int("num_params", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNCanonicalToParams::new().build(num_layers, num_units, input_size, weights, biases, scope)`.
pub fn cudnn_rnncanonical_to_params<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    num_layers: O0,
    num_units: O1,
    input_size: O2,
    weights: O3,
    biases: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNCanonicalToParams::new()
        .build(num_layers, num_units, input_size, weights, biases, scope)
}
/// Builder for the `CudnnRNNCanonicalToParamsV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNCanonicalToParamsV2 {
    T: ::std::option::Option<crate::DataType>,
    num_params_weights: ::std::option::Option<i64>,
    num_params_biases: ::std::option::Option<i64>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    num_proj: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNCanonicalToParamsV2 {
    /// Creates a new `CudnnRNNCanonicalToParamsV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_params_weights` attribute.
    pub fn num_params_weights<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_params_weights = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_params_biases` attribute.
    pub fn num_params_biases<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_params_biases = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_proj` attribute.
    pub fn num_proj<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_proj = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNCanonicalToParamsV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        num_layers: O0,
        num_units: O1,
        input_size: O2,
        weights: O3,
        biases: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            num_layers.into(),
            num_units.into(),
            input_size.into(),
            weights.into(),
            biases.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        num_layers: crate::Output,
        num_units: crate::Output,
        input_size: crate::Output,
        weights: crate::Output,
        biases: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNCanonicalToParamsV2", |nd| {
            nd.add_input(num_layers);
            nd.add_input(num_units);
            nd.add_input(input_size);
            nd.add_input(weights);
            nd.add_input(biases);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_params_weights {
                nd.set_attr_int("num_params_weights", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_params_biases {
                nd.set_attr_int("num_params_biases", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_proj {
                nd.set_attr_int("num_proj", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNCanonicalToParamsV2::new().build(num_layers, num_units, input_size, weights, biases, scope)`.
pub fn cudnn_rnncanonical_to_params_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    num_layers: O0,
    num_units: O1,
    input_size: O2,
    weights: O3,
    biases: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNCanonicalToParamsV2::new()
        .build(num_layers, num_units, input_size, weights, biases, scope)
}
/// Builder for the `CudnnRNNParamsSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNParamsSize {
    T: ::std::option::Option<crate::DataType>,
    S: ::std::option::Option<crate::DataType>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    num_proj: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNParamsSize {
    /// Creates a new `CudnnRNNParamsSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `S` attribute.
    pub fn S<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.S = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_proj` attribute.
    pub fn num_proj<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_proj = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNParamsSize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        num_layers: O0,
        num_units: O1,
        input_size: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            num_layers.into(),
            num_units.into(),
            input_size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        num_layers: crate::Output,
        num_units: crate::Output,
        input_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNParamsSize", |nd| {
            nd.add_input(num_layers);
            nd.add_input(num_units);
            nd.add_input(input_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.S {
                nd.set_attr_type("S", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_proj {
                nd.set_attr_int("num_proj", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNParamsSize::new().build(num_layers, num_units, input_size, scope)`.
pub fn cudnn_rnnparams_size<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    num_layers: O0,
    num_units: O1,
    input_size: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNParamsSize::new().build(num_layers, num_units, input_size, scope)
}
/// Builder for the `CudnnRNNParamsToCanonical` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNParamsToCanonical {
    T: ::std::option::Option<crate::DataType>,
    num_params: ::std::option::Option<i64>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNParamsToCanonical {
    /// Creates a new `CudnnRNNParamsToCanonical`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_params` attribute.
    pub fn num_params<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_params = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNParamsToCanonical` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        num_layers: O0,
        num_units: O1,
        input_size: O2,
        params: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            num_layers.into(),
            num_units.into(),
            input_size.into(),
            params.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        num_layers: crate::Output,
        num_units: crate::Output,
        input_size: crate::Output,
        params: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNParamsToCanonical", |nd| {
            nd.add_input(num_layers);
            nd.add_input(num_units);
            nd.add_input(input_size);
            nd.add_input(params);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_params {
                nd.set_attr_int("num_params", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNParamsToCanonical::new().build(num_layers, num_units, input_size, params, scope)`.
pub fn cudnn_rnnparams_to_canonical<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    num_layers: O0,
    num_units: O1,
    input_size: O2,
    params: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNParamsToCanonical::new().build(num_layers, num_units, input_size, params, scope)
}
/// Builder for the `CudnnRNNParamsToCanonicalV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNParamsToCanonicalV2 {
    T: ::std::option::Option<crate::DataType>,
    num_params_weights: ::std::option::Option<i64>,
    num_params_biases: ::std::option::Option<i64>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    num_proj: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNParamsToCanonicalV2 {
    /// Creates a new `CudnnRNNParamsToCanonicalV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_params_weights` attribute.
    pub fn num_params_weights<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_params_weights = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_params_biases` attribute.
    pub fn num_params_biases<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_params_biases = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_proj` attribute.
    pub fn num_proj<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_proj = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNParamsToCanonicalV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        num_layers: O0,
        num_units: O1,
        input_size: O2,
        params: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            num_layers.into(),
            num_units.into(),
            input_size.into(),
            params.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        num_layers: crate::Output,
        num_units: crate::Output,
        input_size: crate::Output,
        params: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNParamsToCanonicalV2", |nd| {
            nd.add_input(num_layers);
            nd.add_input(num_units);
            nd.add_input(input_size);
            nd.add_input(params);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_params_weights {
                nd.set_attr_int("num_params_weights", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_params_biases {
                nd.set_attr_int("num_params_biases", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_proj {
                nd.set_attr_int("num_proj", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNParamsToCanonicalV2::new().build(num_layers, num_units, input_size, params, scope)`.
pub fn cudnn_rnnparams_to_canonical_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    num_layers: O0,
    num_units: O1,
    input_size: O2,
    params: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNParamsToCanonicalV2::new().build(num_layers, num_units, input_size, params, scope)
}
/// Builder for the `CudnnRNNV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNV2 {
    T: ::std::option::Option<crate::DataType>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    is_training: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNV2 {
    /// Creates a new `CudnnRNNV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_h: O1,
        input_c: O2,
        params: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_h.into(),
            input_c.into(),
            params.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_h: crate::Output,
        input_c: crate::Output,
        params: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNV2", |nd| {
            nd.add_input(input);
            nd.add_input(input_h);
            nd.add_input(input_c);
            nd.add_input(params);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNV2::new().build(input, input_h, input_c, params, scope)`.
pub fn cudnn_rnnv2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_h: O1,
    input_c: O2,
    params: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNV2::new().build(input, input_h, input_c, params, scope)
}
/// Builder for the `CudnnRNNV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CudnnRNNV3 {
    T: ::std::option::Option<crate::DataType>,
    rnn_mode: ::std::option::Option<::std::string::String>,
    input_mode: ::std::option::Option<::std::string::String>,
    direction: ::std::option::Option<::std::string::String>,
    dropout: ::std::option::Option<f32>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    num_proj: ::std::option::Option<i64>,
    is_training: ::std::option::Option<bool>,
    time_major: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CudnnRNNV3 {
    /// Creates a new `CudnnRNNV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rnn_mode` attribute.
    pub fn rnn_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rnn_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_mode` attribute.
    pub fn input_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `direction` attribute.
    pub fn direction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.direction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dropout` attribute.
    pub fn dropout<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.dropout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_proj` attribute.
    pub fn num_proj<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_proj = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `time_major` attribute.
    pub fn time_major<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.time_major = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CudnnRNNV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_h: O1,
        input_c: O2,
        params: O3,
        sequence_lengths: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_h.into(),
            input_c.into(),
            params.into(),
            sequence_lengths.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_h: crate::Output,
        input_c: crate::Output,
        params: crate::Output,
        sequence_lengths: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CudnnRNNV3", |nd| {
            nd.add_input(input);
            nd.add_input(input_h);
            nd.add_input(input_c);
            nd.add_input(params);
            nd.add_input(sequence_lengths);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rnn_mode {
                nd.set_attr_string("rnn_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_mode {
                nd.set_attr_string("input_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.direction {
                nd.set_attr_string("direction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dropout {
                nd.set_attr_float("dropout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_proj {
                nd.set_attr_int("num_proj", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.time_major {
                nd.set_attr_bool("time_major", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CudnnRNNV3::new().build(input, input_h, input_c, params, sequence_lengths, scope)`.
pub fn cudnn_rnnv3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_h: O1,
    input_c: O2,
    params: O3,
    sequence_lengths: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CudnnRNNV3::new().build(input, input_h, input_c, params, sequence_lengths, scope)
}
/// Builder for the `Cumprod` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cumprod {
    exclusive: ::std::option::Option<bool>,
    reverse: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Cumprod {
    /// Creates a new `Cumprod`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `exclusive` attribute.
    pub fn exclusive<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.exclusive = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reverse` attribute.
    pub fn reverse<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.reverse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Cumprod` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        axis: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Cumprod", |nd| {
            nd.add_input(x);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.exclusive {
                nd.set_attr_bool("exclusive", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reverse {
                nd.set_attr_bool("reverse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Cumprod::new().build(x, axis, scope)`.
pub fn cumprod<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    axis: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Cumprod::new().build(x, axis, scope)
}
/// Builder for the `Cumsum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Cumsum {
    exclusive: ::std::option::Option<bool>,
    reverse: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Cumsum {
    /// Creates a new `Cumsum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `exclusive` attribute.
    pub fn exclusive<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.exclusive = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reverse` attribute.
    pub fn reverse<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.reverse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Cumsum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        axis: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Cumsum", |nd| {
            nd.add_input(x);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.exclusive {
                nd.set_attr_bool("exclusive", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reverse {
                nd.set_attr_bool("reverse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Cumsum::new().build(x, axis, scope)`.
pub fn cumsum<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    axis: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Cumsum::new().build(x, axis, scope)
}
/// Builder for the `CumulativeLogsumexp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct CumulativeLogsumexp {
    exclusive: ::std::option::Option<bool>,
    reverse: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl CumulativeLogsumexp {
    /// Creates a new `CumulativeLogsumexp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `exclusive` attribute.
    pub fn exclusive<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.exclusive = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reverse` attribute.
    pub fn reverse<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.reverse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `CumulativeLogsumexp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        axis: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("CumulativeLogsumexp", |nd| {
            nd.add_input(x);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.exclusive {
                nd.set_attr_bool("exclusive", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reverse {
                nd.set_attr_bool("reverse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `CumulativeLogsumexp::new().build(x, axis, scope)`.
pub fn cumulative_logsumexp<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    axis: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    CumulativeLogsumexp::new().build(x, axis, scope)
}
/// Builder for the `DataFormatDimMap` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DataFormatDimMap {
    T: ::std::option::Option<crate::DataType>,
    src_format: ::std::option::Option<::std::string::String>,
    dst_format: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DataFormatDimMap {
    /// Creates a new `DataFormatDimMap`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `src_format` attribute.
    pub fn src_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.src_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dst_format` attribute.
    pub fn dst_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dst_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DataFormatDimMap` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DataFormatDimMap", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.src_format {
                nd.set_attr_string("src_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dst_format {
                nd.set_attr_string("dst_format", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DataFormatDimMap::new().build(x, scope)`.
pub fn data_format_dim_map<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DataFormatDimMap::new().build(x, scope)
}
/// Builder for the `DataFormatVecPermute` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DataFormatVecPermute {
    T: ::std::option::Option<crate::DataType>,
    src_format: ::std::option::Option<::std::string::String>,
    dst_format: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DataFormatVecPermute {
    /// Creates a new `DataFormatVecPermute`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `src_format` attribute.
    pub fn src_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.src_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dst_format` attribute.
    pub fn dst_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dst_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DataFormatVecPermute` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DataFormatVecPermute", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.src_format {
                nd.set_attr_string("src_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dst_format {
                nd.set_attr_string("dst_format", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DataFormatVecPermute::new().build(x, scope)`.
pub fn data_format_vec_permute<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DataFormatVecPermute::new().build(x, scope)
}
/// Builder for the `DataServiceDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DataServiceDataset {
    task_refresh_interval_hint_ms: ::std::option::Option<i64>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DataServiceDataset {
    /// Creates a new `DataServiceDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `task_refresh_interval_hint_ms` attribute.
    pub fn task_refresh_interval_hint_ms<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.task_refresh_interval_hint_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DataServiceDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        dataset_id: O0,
        processing_mode: O1,
        address: O2,
        protocol: O3,
        job_name: O4,
        max_outstanding_requests: O5,
        iteration_counter: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            dataset_id.into(),
            processing_mode.into(),
            address.into(),
            protocol.into(),
            job_name.into(),
            max_outstanding_requests.into(),
            iteration_counter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        dataset_id: crate::Output,
        processing_mode: crate::Output,
        address: crate::Output,
        protocol: crate::Output,
        job_name: crate::Output,
        max_outstanding_requests: crate::Output,
        iteration_counter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DataServiceDataset", |nd| {
            nd.add_input(dataset_id);
            nd.add_input(processing_mode);
            nd.add_input(address);
            nd.add_input(protocol);
            nd.add_input(job_name);
            nd.add_input(max_outstanding_requests);
            nd.add_input(iteration_counter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.task_refresh_interval_hint_ms {
                nd.set_attr_int("task_refresh_interval_hint_ms", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DataServiceDataset::new().build(dataset_id, processing_mode, address, protocol, job_name, max_outstanding_requests, iteration_counter, scope)`.
pub fn data_service_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    dataset_id: O0,
    processing_mode: O1,
    address: O2,
    protocol: O3,
    job_name: O4,
    max_outstanding_requests: O5,
    iteration_counter: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DataServiceDataset::new().build(
        dataset_id,
        processing_mode,
        address,
        protocol,
        job_name,
        max_outstanding_requests,
        iteration_counter,
        scope,
    )
}
/// Builder for the `DatasetCardinality` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetCardinality {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DatasetCardinality {
    /// Creates a new `DatasetCardinality`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DatasetCardinality` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DatasetCardinality", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DatasetCardinality::new().build(input_dataset, scope)`.
pub fn dataset_cardinality<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DatasetCardinality::new().build(input_dataset, scope)
}
/// Builder for the `DatasetFromGraph` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetFromGraph {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DatasetFromGraph {
    /// Creates a new `DatasetFromGraph`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DatasetFromGraph` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        graph_def: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(graph_def.into(), scope)
    }

    fn build_impl(
        &self,
        graph_def: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DatasetFromGraph", |nd| {
            nd.add_input(graph_def);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DatasetFromGraph::new().build(graph_def, scope)`.
pub fn dataset_from_graph<O0: ::std::convert::Into<crate::Output>>(
    graph_def: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DatasetFromGraph::new().build(graph_def, scope)
}
/// Builder for the `DatasetToGraph` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetToGraph {
    stateful_whitelist: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    allow_stateful: ::std::option::Option<bool>,
    strip_device_assignment: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DatasetToGraph {
    /// Creates a new `DatasetToGraph`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `stateful_whitelist` attribute.
    pub fn stateful_whitelist<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.stateful_whitelist = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `allow_stateful` attribute.
    pub fn allow_stateful<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.allow_stateful = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strip_device_assignment` attribute.
    pub fn strip_device_assignment<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strip_device_assignment = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DatasetToGraph` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DatasetToGraph", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.stateful_whitelist {
                nd.set_attr_string_list("stateful_whitelist", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.allow_stateful {
                nd.set_attr_bool("allow_stateful", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strip_device_assignment {
                nd.set_attr_bool("strip_device_assignment", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DatasetToGraph::new().build(input_dataset, scope)`.
pub fn dataset_to_graph<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DatasetToGraph::new().build(input_dataset, scope)
}
/// Builder for the `DatasetToGraphV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetToGraphV2 {
    external_state_policy: ::std::option::Option<i64>,
    strip_device_assignment: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DatasetToGraphV2 {
    /// Creates a new `DatasetToGraphV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `external_state_policy` attribute.
    pub fn external_state_policy<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.external_state_policy = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strip_device_assignment` attribute.
    pub fn strip_device_assignment<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strip_device_assignment = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DatasetToGraphV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DatasetToGraphV2", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.external_state_policy {
                nd.set_attr_int("external_state_policy", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strip_device_assignment {
                nd.set_attr_bool("strip_device_assignment", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DatasetToGraphV2::new().build(input_dataset, scope)`.
pub fn dataset_to_graph_v2<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DatasetToGraphV2::new().build(input_dataset, scope)
}
/// Builder for the `DatasetToSingleElement` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetToSingleElement {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DatasetToSingleElement {
    /// Creates a new `DatasetToSingleElement`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DatasetToSingleElement` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(dataset.into(), scope)
    }

    fn build_impl(
        &self,
        dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DatasetToSingleElement", |nd| {
            nd.add_input(dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DatasetToSingleElement::new().build(dataset, scope)`.
pub fn dataset_to_single_element<O0: ::std::convert::Into<crate::Output>>(
    dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DatasetToSingleElement::new().build(dataset, scope)
}
/// Builder for the `DatasetToTFRecord` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DatasetToTFRecord {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DatasetToTFRecord {
    /// Creates a new `DatasetToTFRecord`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DatasetToTFRecord` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        filename: O1,
        compression_type: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            filename.into(),
            compression_type.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        filename: crate::Output,
        compression_type: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DatasetToTFRecord", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(filename);
            nd.add_input(compression_type);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DatasetToTFRecord::new().build(input_dataset, filename, compression_type, scope)`.
pub fn dataset_to_tfrecord<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    filename: O1,
    compression_type: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DatasetToTFRecord::new().build(input_dataset, filename, compression_type, scope)
}
/// Builder for the `Dawsn` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dawsn {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Dawsn {
    /// Creates a new `Dawsn`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Dawsn` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Dawsn", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Dawsn::new().build(x, scope)`.
pub fn dawsn<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Dawsn::new().build(x, scope)
}
/// Builder for the `DebugGradientIdentity` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugGradientIdentity {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DebugGradientIdentity {
    /// Creates a new `DebugGradientIdentity`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DebugGradientIdentity` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DebugGradientIdentity", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DebugGradientIdentity::new().build(input, scope)`.
pub fn debug_gradient_identity<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DebugGradientIdentity::new().build(input, scope)
}
/// Builder for the `DebugGradientRefIdentity` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugGradientRefIdentity {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DebugGradientRefIdentity {
    /// Creates a new `DebugGradientRefIdentity`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DebugGradientRefIdentity` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DebugGradientRefIdentity", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DebugGradientRefIdentity::new().build(input, scope)`.
pub fn debug_gradient_ref_identity<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DebugGradientRefIdentity::new().build(input, scope)
}
/// Builder for the `DebugIdentity` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugIdentity {
    T: ::std::option::Option<crate::DataType>,
    device_name: ::std::option::Option<::std::string::String>,
    tensor_name: ::std::option::Option<::std::string::String>,
    debug_urls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    gated_grpc: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DebugIdentity {
    /// Creates a new `DebugIdentity`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_name` attribute.
    pub fn device_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.device_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_name` attribute.
    pub fn tensor_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `debug_urls` attribute.
    pub fn debug_urls<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.debug_urls = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `gated_grpc` attribute.
    pub fn gated_grpc<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.gated_grpc = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DebugIdentity` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DebugIdentity", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_name {
                nd.set_attr_string("device_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_name {
                nd.set_attr_string("tensor_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.debug_urls {
                nd.set_attr_string_list("debug_urls", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.gated_grpc {
                nd.set_attr_bool("gated_grpc", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DebugIdentity::new().build(input, scope)`.
pub fn debug_identity<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DebugIdentity::new().build(input, scope)
}
/// Builder for the `DebugIdentityV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugIdentityV2 {
    T: ::std::option::Option<crate::DataType>,
    tfdbg_context_id: ::std::option::Option<::std::string::String>,
    op_name: ::std::option::Option<::std::string::String>,
    output_slot: ::std::option::Option<i64>,
    tensor_debug_mode: ::std::option::Option<i64>,
    debug_urls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    circular_buffer_size: ::std::option::Option<i64>,
    tfdbg_run_id: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DebugIdentityV2 {
    /// Creates a new `DebugIdentityV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tfdbg_context_id` attribute.
    pub fn tfdbg_context_id<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tfdbg_context_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `op_name` attribute.
    pub fn op_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.op_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_slot` attribute.
    pub fn output_slot<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.output_slot = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_debug_mode` attribute.
    pub fn tensor_debug_mode<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.tensor_debug_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `debug_urls` attribute.
    pub fn debug_urls<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.debug_urls = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `circular_buffer_size` attribute.
    pub fn circular_buffer_size<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.circular_buffer_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tfdbg_run_id` attribute.
    pub fn tfdbg_run_id<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tfdbg_run_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DebugIdentityV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DebugIdentityV2", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tfdbg_context_id {
                nd.set_attr_string("tfdbg_context_id", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.op_name {
                nd.set_attr_string("op_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_slot {
                nd.set_attr_int("output_slot", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_debug_mode {
                nd.set_attr_int("tensor_debug_mode", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.debug_urls {
                nd.set_attr_string_list("debug_urls", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.circular_buffer_size {
                nd.set_attr_int("circular_buffer_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tfdbg_run_id {
                nd.set_attr_string("tfdbg_run_id", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DebugIdentityV2::new().build(input, scope)`.
pub fn debug_identity_v2<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DebugIdentityV2::new().build(input, scope)
}
/// Builder for the `DebugNanCount` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugNanCount {
    T: ::std::option::Option<crate::DataType>,
    device_name: ::std::option::Option<::std::string::String>,
    tensor_name: ::std::option::Option<::std::string::String>,
    debug_urls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    gated_grpc: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DebugNanCount {
    /// Creates a new `DebugNanCount`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_name` attribute.
    pub fn device_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.device_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_name` attribute.
    pub fn tensor_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `debug_urls` attribute.
    pub fn debug_urls<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.debug_urls = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `gated_grpc` attribute.
    pub fn gated_grpc<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.gated_grpc = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DebugNanCount` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DebugNanCount", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_name {
                nd.set_attr_string("device_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_name {
                nd.set_attr_string("tensor_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.debug_urls {
                nd.set_attr_string_list("debug_urls", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.gated_grpc {
                nd.set_attr_bool("gated_grpc", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DebugNanCount::new().build(input, scope)`.
pub fn debug_nan_count<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DebugNanCount::new().build(input, scope)
}
/// Builder for the `DebugNumericSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugNumericSummary {
    T: ::std::option::Option<crate::DataType>,
    device_name: ::std::option::Option<::std::string::String>,
    tensor_name: ::std::option::Option<::std::string::String>,
    debug_urls: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    lower_bound: ::std::option::Option<f32>,
    upper_bound: ::std::option::Option<f32>,
    mute_if_healthy: ::std::option::Option<bool>,
    gated_grpc: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DebugNumericSummary {
    /// Creates a new `DebugNumericSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_name` attribute.
    pub fn device_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.device_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_name` attribute.
    pub fn tensor_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `debug_urls` attribute.
    pub fn debug_urls<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.debug_urls = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `lower_bound` attribute.
    pub fn lower_bound<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.lower_bound = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `upper_bound` attribute.
    pub fn upper_bound<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.upper_bound = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `mute_if_healthy` attribute.
    pub fn mute_if_healthy<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.mute_if_healthy = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `gated_grpc` attribute.
    pub fn gated_grpc<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.gated_grpc = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DebugNumericSummary` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DebugNumericSummary", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_name {
                nd.set_attr_string("device_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_name {
                nd.set_attr_string("tensor_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.debug_urls {
                nd.set_attr_string_list("debug_urls", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.lower_bound {
                nd.set_attr_float("lower_bound", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.upper_bound {
                nd.set_attr_float("upper_bound", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.mute_if_healthy {
                nd.set_attr_bool("mute_if_healthy", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.gated_grpc {
                nd.set_attr_bool("gated_grpc", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DebugNumericSummary::new().build(input, scope)`.
pub fn debug_numeric_summary<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DebugNumericSummary::new().build(input, scope)
}
/// Builder for the `DebugNumericSummaryV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DebugNumericSummaryV2 {
    output_dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    tensor_debug_mode: ::std::option::Option<i64>,
    tensor_id: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DebugNumericSummaryV2 {
    /// Creates a new `DebugNumericSummaryV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_dtype` attribute.
    pub fn output_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_debug_mode` attribute.
    pub fn tensor_debug_mode<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.tensor_debug_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_id` attribute.
    pub fn tensor_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.tensor_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DebugNumericSummaryV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DebugNumericSummaryV2", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_dtype {
                nd.set_attr_type("output_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_debug_mode {
                nd.set_attr_int("tensor_debug_mode", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_id {
                nd.set_attr_int("tensor_id", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DebugNumericSummaryV2::new().build(input, scope)`.
pub fn debug_numeric_summary_v2<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DebugNumericSummaryV2::new().build(input, scope)
}
/// Builder for the `DecodeAndCropJpeg` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeAndCropJpeg {
    channels: ::std::option::Option<i64>,
    ratio: ::std::option::Option<i64>,
    fancy_upscaling: ::std::option::Option<bool>,
    try_recover_truncated: ::std::option::Option<bool>,
    acceptable_fraction: ::std::option::Option<f32>,
    dct_method: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeAndCropJpeg {
    /// Creates a new `DecodeAndCropJpeg`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `channels` attribute.
    pub fn channels<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.channels = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ratio` attribute.
    pub fn ratio<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.ratio = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fancy_upscaling` attribute.
    pub fn fancy_upscaling<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.fancy_upscaling = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `try_recover_truncated` attribute.
    pub fn try_recover_truncated<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.try_recover_truncated = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `acceptable_fraction` attribute.
    pub fn acceptable_fraction<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.acceptable_fraction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dct_method` attribute.
    pub fn dct_method<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dct_method = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeAndCropJpeg` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        contents: O0,
        crop_window: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(contents.into(), crop_window.into(), scope)
    }

    fn build_impl(
        &self,
        contents: crate::Output,
        crop_window: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeAndCropJpeg", |nd| {
            nd.add_input(contents);
            nd.add_input(crop_window);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.channels {
                nd.set_attr_int("channels", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ratio {
                nd.set_attr_int("ratio", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fancy_upscaling {
                nd.set_attr_bool("fancy_upscaling", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.try_recover_truncated {
                nd.set_attr_bool("try_recover_truncated", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.acceptable_fraction {
                nd.set_attr_float("acceptable_fraction", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dct_method {
                nd.set_attr_string("dct_method", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeAndCropJpeg::new().build(contents, crop_window, scope)`.
pub fn decode_and_crop_jpeg<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    contents: O0,
    crop_window: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeAndCropJpeg::new().build(contents, crop_window, scope)
}
/// Builder for the `DecodeBase64` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeBase64 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeBase64 {
    /// Creates a new `DecodeBase64`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeBase64` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeBase64", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeBase64::new().build(input, scope)`.
pub fn decode_base64<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeBase64::new().build(input, scope)
}
/// Builder for the `DecodeBmp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeBmp {
    channels: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeBmp {
    /// Creates a new `DecodeBmp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `channels` attribute.
    pub fn channels<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.channels = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeBmp` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        contents: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(contents.into(), scope)
    }

    fn build_impl(
        &self,
        contents: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeBmp", |nd| {
            nd.add_input(contents);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.channels {
                nd.set_attr_int("channels", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeBmp::new().build(contents, scope)`.
pub fn decode_bmp<O0: ::std::convert::Into<crate::Output>>(
    contents: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeBmp::new().build(contents, scope)
}
/// Builder for the `DecodeCSV` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeCSV {
    OUT_TYPE: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    field_delim: ::std::option::Option<::std::string::String>,
    use_quote_delim: ::std::option::Option<bool>,
    na_value: ::std::option::Option<::std::string::String>,
    select_cols: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeCSV {
    /// Creates a new `DecodeCSV`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `OUT_TYPE` attribute.
    pub fn OUT_TYPE<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.OUT_TYPE = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `field_delim` attribute.
    pub fn field_delim<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.field_delim = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_quote_delim` attribute.
    pub fn use_quote_delim<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_quote_delim = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `na_value` attribute.
    pub fn na_value<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.na_value = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `select_cols` attribute.
    pub fn select_cols<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.select_cols = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeCSV` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        records: O0,
        record_defaults: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(records.into(), record_defaults.into(), scope)
    }

    fn build_impl(
        &self,
        records: crate::Output,
        record_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeCSV", |nd| {
            nd.add_input(records);
            nd.add_input(record_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.OUT_TYPE {
                nd.set_attr_type_list("OUT_TYPE", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.field_delim {
                nd.set_attr_string("field_delim", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_quote_delim {
                nd.set_attr_bool("use_quote_delim", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.na_value {
                nd.set_attr_string("na_value", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.select_cols {
                nd.set_attr_int_list("select_cols", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeCSV::new().build(records, record_defaults, scope)`.
pub fn decode_csv<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    records: O0,
    record_defaults: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeCSV::new().build(records, record_defaults, scope)
}
/// Builder for the `DecodeCompressed` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeCompressed {
    compression_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeCompressed {
    /// Creates a new `DecodeCompressed`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `compression_type` attribute.
    pub fn compression_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compression_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeCompressed` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        bytes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(bytes.into(), scope)
    }

    fn build_impl(
        &self,
        bytes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeCompressed", |nd| {
            nd.add_input(bytes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.compression_type {
                nd.set_attr_string("compression_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeCompressed::new().build(bytes, scope)`.
pub fn decode_compressed<O0: ::std::convert::Into<crate::Output>>(
    bytes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeCompressed::new().build(bytes, scope)
}
/// Builder for the `DecodeGif` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeGif {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeGif {
    /// Creates a new `DecodeGif`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeGif` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        contents: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(contents.into(), scope)
    }

    fn build_impl(
        &self,
        contents: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeGif", |nd| {
            nd.add_input(contents);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeGif::new().build(contents, scope)`.
pub fn decode_gif<O0: ::std::convert::Into<crate::Output>>(
    contents: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeGif::new().build(contents, scope)
}
/// Builder for the `DecodeJSONExample` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeJSONExample {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeJSONExample {
    /// Creates a new `DecodeJSONExample`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeJSONExample` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        json_examples: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(json_examples.into(), scope)
    }

    fn build_impl(
        &self,
        json_examples: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeJSONExample", |nd| {
            nd.add_input(json_examples);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeJSONExample::new().build(json_examples, scope)`.
pub fn decode_jsonexample<O0: ::std::convert::Into<crate::Output>>(
    json_examples: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeJSONExample::new().build(json_examples, scope)
}
/// Builder for the `DecodeJpeg` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeJpeg {
    channels: ::std::option::Option<i64>,
    ratio: ::std::option::Option<i64>,
    fancy_upscaling: ::std::option::Option<bool>,
    try_recover_truncated: ::std::option::Option<bool>,
    acceptable_fraction: ::std::option::Option<f32>,
    dct_method: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeJpeg {
    /// Creates a new `DecodeJpeg`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `channels` attribute.
    pub fn channels<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.channels = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ratio` attribute.
    pub fn ratio<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.ratio = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fancy_upscaling` attribute.
    pub fn fancy_upscaling<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.fancy_upscaling = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `try_recover_truncated` attribute.
    pub fn try_recover_truncated<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.try_recover_truncated = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `acceptable_fraction` attribute.
    pub fn acceptable_fraction<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.acceptable_fraction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dct_method` attribute.
    pub fn dct_method<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dct_method = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeJpeg` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        contents: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(contents.into(), scope)
    }

    fn build_impl(
        &self,
        contents: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeJpeg", |nd| {
            nd.add_input(contents);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.channels {
                nd.set_attr_int("channels", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ratio {
                nd.set_attr_int("ratio", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fancy_upscaling {
                nd.set_attr_bool("fancy_upscaling", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.try_recover_truncated {
                nd.set_attr_bool("try_recover_truncated", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.acceptable_fraction {
                nd.set_attr_float("acceptable_fraction", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dct_method {
                nd.set_attr_string("dct_method", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeJpeg::new().build(contents, scope)`.
pub fn decode_jpeg<O0: ::std::convert::Into<crate::Output>>(
    contents: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeJpeg::new().build(contents, scope)
}
/// Builder for the `DecodePaddedRaw` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodePaddedRaw {
    out_type: ::std::option::Option<crate::DataType>,
    little_endian: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodePaddedRaw {
    /// Creates a new `DecodePaddedRaw`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `little_endian` attribute.
    pub fn little_endian<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.little_endian = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodePaddedRaw` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_bytes: O0,
        fixed_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_bytes.into(), fixed_length.into(), scope)
    }

    fn build_impl(
        &self,
        input_bytes: crate::Output,
        fixed_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodePaddedRaw", |nd| {
            nd.add_input(input_bytes);
            nd.add_input(fixed_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.little_endian {
                nd.set_attr_bool("little_endian", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodePaddedRaw::new().build(input_bytes, fixed_length, scope)`.
pub fn decode_padded_raw<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_bytes: O0,
    fixed_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodePaddedRaw::new().build(input_bytes, fixed_length, scope)
}
/// Builder for the `DecodePng` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodePng {
    channels: ::std::option::Option<i64>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodePng {
    /// Creates a new `DecodePng`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `channels` attribute.
    pub fn channels<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.channels = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodePng` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        contents: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(contents.into(), scope)
    }

    fn build_impl(
        &self,
        contents: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodePng", |nd| {
            nd.add_input(contents);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.channels {
                nd.set_attr_int("channels", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodePng::new().build(contents, scope)`.
pub fn decode_png<O0: ::std::convert::Into<crate::Output>>(
    contents: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodePng::new().build(contents, scope)
}
/// Builder for the `DecodeProtoV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeProtoV2 {
    message_type: ::std::option::Option<::std::string::String>,
    field_names: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    descriptor_source: ::std::option::Option<::std::string::String>,
    message_format: ::std::option::Option<::std::string::String>,
    sanitize: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeProtoV2 {
    /// Creates a new `DecodeProtoV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `message_type` attribute.
    pub fn message_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.message_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `field_names` attribute.
    pub fn field_names<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.field_names = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `descriptor_source` attribute.
    pub fn descriptor_source<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.descriptor_source = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `message_format` attribute.
    pub fn message_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.message_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sanitize` attribute.
    pub fn sanitize<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.sanitize = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeProtoV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        bytes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(bytes.into(), scope)
    }

    fn build_impl(
        &self,
        bytes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeProtoV2", |nd| {
            nd.add_input(bytes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.message_type {
                nd.set_attr_string("message_type", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.field_names {
                nd.set_attr_string_list("field_names", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.descriptor_source {
                nd.set_attr_string("descriptor_source", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.message_format {
                nd.set_attr_string("message_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sanitize {
                nd.set_attr_bool("sanitize", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeProtoV2::new().build(bytes, scope)`.
pub fn decode_proto_v2<O0: ::std::convert::Into<crate::Output>>(
    bytes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeProtoV2::new().build(bytes, scope)
}
/// Builder for the `DecodeRaw` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeRaw {
    out_type: ::std::option::Option<crate::DataType>,
    little_endian: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeRaw {
    /// Creates a new `DecodeRaw`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `little_endian` attribute.
    pub fn little_endian<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.little_endian = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeRaw` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        bytes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(bytes.into(), scope)
    }

    fn build_impl(
        &self,
        bytes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeRaw", |nd| {
            nd.add_input(bytes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.little_endian {
                nd.set_attr_bool("little_endian", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeRaw::new().build(bytes, scope)`.
pub fn decode_raw<O0: ::std::convert::Into<crate::Output>>(
    bytes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeRaw::new().build(bytes, scope)
}
/// Builder for the `DecodeWav` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DecodeWav {
    desired_channels: ::std::option::Option<i64>,
    desired_samples: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DecodeWav {
    /// Creates a new `DecodeWav`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `desired_channels` attribute.
    pub fn desired_channels<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.desired_channels = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `desired_samples` attribute.
    pub fn desired_samples<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.desired_samples = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DecodeWav` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        contents: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(contents.into(), scope)
    }

    fn build_impl(
        &self,
        contents: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DecodeWav", |nd| {
            nd.add_input(contents);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.desired_channels {
                nd.set_attr_int("desired_channels", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.desired_samples {
                nd.set_attr_int("desired_samples", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DecodeWav::new().build(contents, scope)`.
pub fn decode_wav<O0: ::std::convert::Into<crate::Output>>(
    contents: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DecodeWav::new().build(contents, scope)
}
/// Builder for the `DeepCopy` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeepCopy {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeepCopy {
    /// Creates a new `DeepCopy`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeepCopy` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeepCopy", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeepCopy::new().build(x, scope)`.
pub fn deep_copy<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeepCopy::new().build(x, scope)
}
/// Builder for the `DeleteIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteIterator {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeleteIterator {
    /// Creates a new `DeleteIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeleteIterator` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        deleter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), deleter.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        deleter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeleteIterator", |nd| {
            nd.add_input(handle);
            nd.add_input(deleter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeleteIterator::new().build(handle, deleter, scope)`.
pub fn delete_iterator<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    deleter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeleteIterator::new().build(handle, deleter, scope)
}
/// Builder for the `DeleteMemoryCache` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteMemoryCache {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeleteMemoryCache {
    /// Creates a new `DeleteMemoryCache`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeleteMemoryCache` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        deleter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), deleter.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        deleter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeleteMemoryCache", |nd| {
            nd.add_input(handle);
            nd.add_input(deleter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeleteMemoryCache::new().build(handle, deleter, scope)`.
pub fn delete_memory_cache<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    deleter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeleteMemoryCache::new().build(handle, deleter, scope)
}
/// Builder for the `DeleteMultiDeviceIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteMultiDeviceIterator {
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeleteMultiDeviceIterator {
    /// Creates a new `DeleteMultiDeviceIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeleteMultiDeviceIterator` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        multi_device_iterator: O0,
        iterators: O1,
        deleter: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            multi_device_iterator.into(),
            iterators.into(),
            deleter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        multi_device_iterator: crate::Output,
        iterators: crate::Output,
        deleter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeleteMultiDeviceIterator", |nd| {
            nd.add_input(multi_device_iterator);
            nd.add_input(iterators);
            nd.add_input(deleter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeleteMultiDeviceIterator::new().build(multi_device_iterator, iterators, deleter, scope)`.
pub fn delete_multi_device_iterator<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    multi_device_iterator: O0,
    iterators: O1,
    deleter: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeleteMultiDeviceIterator::new().build(multi_device_iterator, iterators, deleter, scope)
}
/// Builder for the `DeleteRandomSeedGenerator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteRandomSeedGenerator {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeleteRandomSeedGenerator {
    /// Creates a new `DeleteRandomSeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeleteRandomSeedGenerator` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        deleter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), deleter.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        deleter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeleteRandomSeedGenerator", |nd| {
            nd.add_input(handle);
            nd.add_input(deleter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeleteRandomSeedGenerator::new().build(handle, deleter, scope)`.
pub fn delete_random_seed_generator<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    deleter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeleteRandomSeedGenerator::new().build(handle, deleter, scope)
}
/// Builder for the `DeleteSeedGenerator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteSeedGenerator {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeleteSeedGenerator {
    /// Creates a new `DeleteSeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeleteSeedGenerator` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        deleter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), deleter.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        deleter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeleteSeedGenerator", |nd| {
            nd.add_input(handle);
            nd.add_input(deleter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeleteSeedGenerator::new().build(handle, deleter, scope)`.
pub fn delete_seed_generator<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    deleter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeleteSeedGenerator::new().build(handle, deleter, scope)
}
/// Builder for the `DeleteSessionTensor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeleteSessionTensor {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeleteSessionTensor {
    /// Creates a new `DeleteSessionTensor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeleteSessionTensor` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeleteSessionTensor", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeleteSessionTensor::new().build(handle, scope)`.
pub fn delete_session_tensor<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeleteSessionTensor::new().build(handle, scope)
}
/// Builder for the `DenseBincount` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseBincount {
    Tidx: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    binary_output: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DenseBincount {
    /// Creates a new `DenseBincount`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `binary_output` attribute.
    pub fn binary_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.binary_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DenseBincount` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        size: O1,
        weights: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), size.into(), weights.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        size: crate::Output,
        weights: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DenseBincount", |nd| {
            nd.add_input(input);
            nd.add_input(size);
            nd.add_input(weights);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.binary_output {
                nd.set_attr_bool("binary_output", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DenseBincount::new().build(input, size, weights, scope)`.
pub fn dense_bincount<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    size: O1,
    weights: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DenseBincount::new().build(input, size, weights, scope)
}
/// Builder for the `DenseCountSparseOutput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseCountSparseOutput {
    T: ::std::option::Option<crate::DataType>,
    minlength: ::std::option::Option<i64>,
    maxlength: ::std::option::Option<i64>,
    binary_output: ::std::option::Option<bool>,
    output_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DenseCountSparseOutput {
    /// Creates a new `DenseCountSparseOutput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `minlength` attribute.
    pub fn minlength<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.minlength = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `maxlength` attribute.
    pub fn maxlength<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.maxlength = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `binary_output` attribute.
    pub fn binary_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.binary_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_type` attribute.
    pub fn output_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DenseCountSparseOutput` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        values: O0,
        weights: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(values.into(), weights.into(), scope)
    }

    fn build_impl(
        &self,
        values: crate::Output,
        weights: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DenseCountSparseOutput", |nd| {
            nd.add_input(values);
            nd.add_input(weights);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.minlength {
                nd.set_attr_int("minlength", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.maxlength {
                nd.set_attr_int("maxlength", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.binary_output {
                nd.set_attr_bool("binary_output", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_type {
                nd.set_attr_type("output_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DenseCountSparseOutput::new().build(values, weights, scope)`.
pub fn dense_count_sparse_output<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    values: O0,
    weights: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DenseCountSparseOutput::new().build(values, weights, scope)
}
/// Builder for the `DenseToCSRSparseMatrix` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseToCSRSparseMatrix {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DenseToCSRSparseMatrix {
    /// Creates a new `DenseToCSRSparseMatrix`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DenseToCSRSparseMatrix` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        dense_input: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(dense_input.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        dense_input: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DenseToCSRSparseMatrix", |nd| {
            nd.add_input(dense_input);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DenseToCSRSparseMatrix::new().build(dense_input, indices, scope)`.
pub fn dense_to_csrsparse_matrix<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    dense_input: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DenseToCSRSparseMatrix::new().build(dense_input, indices, scope)
}
/// Builder for the `DenseToDenseSetOperation` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseToDenseSetOperation {
    set_operation: ::std::option::Option<::std::string::String>,
    validate_indices: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DenseToDenseSetOperation {
    /// Creates a new `DenseToDenseSetOperation`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `set_operation` attribute.
    pub fn set_operation<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.set_operation = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `validate_indices` attribute.
    pub fn validate_indices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.validate_indices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DenseToDenseSetOperation` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        set1: O0,
        set2: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(set1.into(), set2.into(), scope)
    }

    fn build_impl(
        &self,
        set1: crate::Output,
        set2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DenseToDenseSetOperation", |nd| {
            nd.add_input(set1);
            nd.add_input(set2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.set_operation {
                nd.set_attr_string("set_operation", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.validate_indices {
                nd.set_attr_bool("validate_indices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DenseToDenseSetOperation::new().build(set1, set2, scope)`.
pub fn dense_to_dense_set_operation<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    set1: O0,
    set2: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DenseToDenseSetOperation::new().build(set1, set2, scope)
}
/// Builder for the `DenseToSparseBatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseToSparseBatchDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DenseToSparseBatchDataset {
    /// Creates a new `DenseToSparseBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DenseToSparseBatchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        batch_size: O1,
        row_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            batch_size.into(),
            row_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        batch_size: crate::Output,
        row_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DenseToSparseBatchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(batch_size);
            nd.add_input(row_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DenseToSparseBatchDataset::new().build(input_dataset, batch_size, row_shape, scope)`.
pub fn dense_to_sparse_batch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    batch_size: O1,
    row_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DenseToSparseBatchDataset::new().build(input_dataset, batch_size, row_shape, scope)
}
/// Builder for the `DenseToSparseSetOperation` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DenseToSparseSetOperation {
    set_operation: ::std::option::Option<::std::string::String>,
    validate_indices: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DenseToSparseSetOperation {
    /// Creates a new `DenseToSparseSetOperation`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `set_operation` attribute.
    pub fn set_operation<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.set_operation = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `validate_indices` attribute.
    pub fn validate_indices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.validate_indices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DenseToSparseSetOperation` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        set1: O0,
        set2_indices: O1,
        set2_values: O2,
        set2_shape: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            set1.into(),
            set2_indices.into(),
            set2_values.into(),
            set2_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        set1: crate::Output,
        set2_indices: crate::Output,
        set2_values: crate::Output,
        set2_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DenseToSparseSetOperation", |nd| {
            nd.add_input(set1);
            nd.add_input(set2_indices);
            nd.add_input(set2_values);
            nd.add_input(set2_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.set_operation {
                nd.set_attr_string("set_operation", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.validate_indices {
                nd.set_attr_bool("validate_indices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DenseToSparseSetOperation::new().build(set1, set2_indices, set2_values, set2_shape, scope)`.
pub fn dense_to_sparse_set_operation<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    set1: O0,
    set2_indices: O1,
    set2_values: O2,
    set2_shape: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DenseToSparseSetOperation::new().build(set1, set2_indices, set2_values, set2_shape, scope)
}
/// Builder for the `DepthToSpace` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DepthToSpace {
    T: ::std::option::Option<crate::DataType>,
    block_size: ::std::option::Option<i64>,
    data_format: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DepthToSpace {
    /// Creates a new `DepthToSpace`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `block_size` attribute.
    pub fn block_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.block_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DepthToSpace` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DepthToSpace", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.block_size {
                nd.set_attr_int("block_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DepthToSpace::new().build(input, scope)`.
pub fn depth_to_space<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DepthToSpace::new().build(input, scope)
}
/// Builder for the `DepthwiseConv2dNative` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DepthwiseConv2dNative {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DepthwiseConv2dNative {
    /// Creates a new `DepthwiseConv2dNative`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `explicit_paddings` attribute.
    pub fn explicit_paddings<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.explicit_paddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DepthwiseConv2dNative` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), filter.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DepthwiseConv2dNative", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.explicit_paddings {
                nd.set_attr_int_list("explicit_paddings", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DepthwiseConv2dNative::new().build(input, filter, scope)`.
pub fn depthwise_conv2d_native<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DepthwiseConv2dNative::new().build(input, filter, scope)
}
/// Builder for the `DepthwiseConv2dNativeBackpropFilter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DepthwiseConv2dNativeBackpropFilter {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DepthwiseConv2dNativeBackpropFilter {
    /// Creates a new `DepthwiseConv2dNativeBackpropFilter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `explicit_paddings` attribute.
    pub fn explicit_paddings<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.explicit_paddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DepthwiseConv2dNativeBackpropFilter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter_sizes: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter_sizes.into(),
            out_backprop.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter_sizes: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DepthwiseConv2dNativeBackpropFilter", |nd| {
            nd.add_input(input);
            nd.add_input(filter_sizes);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.explicit_paddings {
                nd.set_attr_int_list("explicit_paddings", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DepthwiseConv2dNativeBackpropFilter::new().build(input, filter_sizes, out_backprop, scope)`.
pub fn depthwise_conv2d_native_backprop_filter<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter_sizes: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DepthwiseConv2dNativeBackpropFilter::new().build(input, filter_sizes, out_backprop, scope)
}
/// Builder for the `DepthwiseConv2dNativeBackpropInput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DepthwiseConv2dNativeBackpropInput {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    explicit_paddings: ::std::option::Option<::std::vec::Vec<i64>>,
    data_format: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DepthwiseConv2dNativeBackpropInput {
    /// Creates a new `DepthwiseConv2dNativeBackpropInput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `explicit_paddings` attribute.
    pub fn explicit_paddings<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.explicit_paddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DepthwiseConv2dNativeBackpropInput` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_sizes: O0,
        filter: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_sizes.into(),
            filter.into(),
            out_backprop.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_sizes: crate::Output,
        filter: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DepthwiseConv2dNativeBackpropInput", |nd| {
            nd.add_input(input_sizes);
            nd.add_input(filter);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.explicit_paddings {
                nd.set_attr_int_list("explicit_paddings", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DepthwiseConv2dNativeBackpropInput::new().build(input_sizes, filter, out_backprop, scope)`.
pub fn depthwise_conv2d_native_backprop_input<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_sizes: O0,
    filter: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DepthwiseConv2dNativeBackpropInput::new().build(input_sizes, filter, out_backprop, scope)
}
/// Builder for the `Dequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dequantize {
    T: ::std::option::Option<crate::DataType>,
    mode: ::std::option::Option<::std::string::String>,
    narrow_range: ::std::option::Option<bool>,
    axis: ::std::option::Option<i64>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Dequantize {
    /// Creates a new `Dequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `mode` attribute.
    pub fn mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `axis` attribute.
    pub fn axis<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.axis = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Dequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        min_range: O1,
        max_range: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), min_range.into(), max_range.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        min_range: crate::Output,
        max_range: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Dequantize", |nd| {
            nd.add_input(input);
            nd.add_input(min_range);
            nd.add_input(max_range);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.mode {
                nd.set_attr_string("mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.axis {
                nd.set_attr_int("axis", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Dequantize::new().build(input, min_range, max_range, scope)`.
pub fn dequantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    min_range: O1,
    max_range: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Dequantize::new().build(input, min_range, max_range, scope)
}
/// Builder for the `DeserializeIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeserializeIterator {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeserializeIterator {
    /// Creates a new `DeserializeIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeserializeIterator` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource_handle: O0,
        serialized: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource_handle.into(), serialized.into(), scope)
    }

    fn build_impl(
        &self,
        resource_handle: crate::Output,
        serialized: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeserializeIterator", |nd| {
            nd.add_input(resource_handle);
            nd.add_input(serialized);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeserializeIterator::new().build(resource_handle, serialized, scope)`.
pub fn deserialize_iterator<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    resource_handle: O0,
    serialized: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeserializeIterator::new().build(resource_handle, serialized, scope)
}
/// Builder for the `DeserializeManySparse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeserializeManySparse {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeserializeManySparse {
    /// Creates a new `DeserializeManySparse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeserializeManySparse` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        serialized_sparse: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(serialized_sparse.into(), scope)
    }

    fn build_impl(
        &self,
        serialized_sparse: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeserializeManySparse", |nd| {
            nd.add_input(serialized_sparse);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeserializeManySparse::new().build(serialized_sparse, scope)`.
pub fn deserialize_many_sparse<O0: ::std::convert::Into<crate::Output>>(
    serialized_sparse: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeserializeManySparse::new().build(serialized_sparse, scope)
}
/// Builder for the `DeserializeSparse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeserializeSparse {
    dtype: ::std::option::Option<crate::DataType>,
    Tserialized: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeserializeSparse {
    /// Creates a new `DeserializeSparse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tserialized` attribute.
    pub fn Tserialized<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tserialized = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeserializeSparse` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        serialized_sparse: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(serialized_sparse.into(), scope)
    }

    fn build_impl(
        &self,
        serialized_sparse: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DeserializeSparse", |nd| {
            nd.add_input(serialized_sparse);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tserialized {
                nd.set_attr_type("Tserialized", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeserializeSparse::new().build(serialized_sparse, scope)`.
pub fn deserialize_sparse<O0: ::std::convert::Into<crate::Output>>(
    serialized_sparse: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DeserializeSparse::new().build(serialized_sparse, scope)
}
/// Builder for the `DestroyResourceOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DestroyResourceOp {
    ignore_lookup_error: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DestroyResourceOp {
    /// Creates a new `DestroyResourceOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ignore_lookup_error` attribute.
    pub fn ignore_lookup_error<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ignore_lookup_error = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DestroyResourceOp` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DestroyResourceOp", |nd| {
            nd.add_input(resource);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ignore_lookup_error {
                nd.set_attr_bool("ignore_lookup_error", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DestroyResourceOp::new().build(resource, scope)`.
pub fn destroy_resource_op<O0: ::std::convert::Into<crate::Output>>(
    resource: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DestroyResourceOp::new().build(resource, scope)
}
/// Builder for the `DestroyTemporaryVariable` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DestroyTemporaryVariable {
    T: ::std::option::Option<crate::DataType>,
    var_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DestroyTemporaryVariable {
    /// Creates a new `DestroyTemporaryVariable`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `var_name` attribute.
    pub fn var_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.var_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DestroyTemporaryVariable` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        ref_: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DestroyTemporaryVariable", |nd| {
            nd.add_input(ref_);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.var_name {
                nd.set_attr_string("var_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DestroyTemporaryVariable::new().build(ref_, scope)`.
pub fn destroy_temporary_variable<O0: ::std::convert::Into<crate::Output>>(
    ref_: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DestroyTemporaryVariable::new().build(ref_, scope)
}
/// Builder for the `DeviceIndex` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DeviceIndex {
    device_names: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DeviceIndex {
    /// Creates a new `DeviceIndex`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `device_names` attribute.
    pub fn device_names<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.device_names = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DeviceIndex` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("DeviceIndex", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.device_names {
                nd.set_attr_string_list("device_names", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DeviceIndex::new().build(scope)`.
pub fn device_index(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    DeviceIndex::new().build(scope)
}
/// Builder for the `Diag` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Diag {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Diag {
    /// Creates a new `Diag`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Diag` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        diagonal: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(diagonal.into(), scope)
    }

    fn build_impl(
        &self,
        diagonal: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Diag", |nd| {
            nd.add_input(diagonal);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Diag::new().build(diagonal, scope)`.
pub fn diag<O0: ::std::convert::Into<crate::Output>>(
    diagonal: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Diag::new().build(diagonal, scope)
}
/// Builder for the `DiagPart` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DiagPart {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DiagPart {
    /// Creates a new `DiagPart`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DiagPart` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DiagPart", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DiagPart::new().build(input, scope)`.
pub fn diag_part<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DiagPart::new().build(input, scope)
}
/// Builder for the `Digamma` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Digamma {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Digamma {
    /// Creates a new `Digamma`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Digamma` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Digamma", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Digamma::new().build(x, scope)`.
pub fn digamma<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Digamma::new().build(x, scope)
}
/// Builder for the `Dilation2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dilation2D {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    rates: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Dilation2D {
    /// Creates a new `Dilation2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rates` attribute.
    pub fn rates<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rates = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Dilation2D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), filter.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Dilation2D", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rates {
                nd.set_attr_int_list("rates", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Dilation2D::new().build(input, filter, scope)`.
pub fn dilation2_d<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Dilation2D::new().build(input, filter, scope)
}
/// Builder for the `Dilation2DBackpropFilter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dilation2DBackpropFilter {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    rates: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Dilation2DBackpropFilter {
    /// Creates a new `Dilation2DBackpropFilter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rates` attribute.
    pub fn rates<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rates = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Dilation2DBackpropFilter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), filter.into(), out_backprop.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Dilation2DBackpropFilter", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rates {
                nd.set_attr_int_list("rates", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Dilation2DBackpropFilter::new().build(input, filter, out_backprop, scope)`.
pub fn dilation2_dbackprop_filter<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Dilation2DBackpropFilter::new().build(input, filter, out_backprop, scope)
}
/// Builder for the `Dilation2DBackpropInput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Dilation2DBackpropInput {
    T: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    rates: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Dilation2DBackpropInput {
    /// Creates a new `Dilation2DBackpropInput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rates` attribute.
    pub fn rates<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rates = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Dilation2DBackpropInput` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        out_backprop: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), filter.into(), out_backprop.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        out_backprop: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Dilation2DBackpropInput", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(out_backprop);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rates {
                nd.set_attr_int_list("rates", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Dilation2DBackpropInput::new().build(input, filter, out_backprop, scope)`.
pub fn dilation2_dbackprop_input<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    out_backprop: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Dilation2DBackpropInput::new().build(input, filter, out_backprop, scope)
}
/// Builder for the `DirectedInterleaveDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DirectedInterleaveDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DirectedInterleaveDataset {
    /// Creates a new `DirectedInterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DirectedInterleaveDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        selector_input_dataset: O0,
        data_input_datasets: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            selector_input_dataset.into(),
            data_input_datasets.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        selector_input_dataset: crate::Output,
        data_input_datasets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DirectedInterleaveDataset", |nd| {
            nd.add_input(selector_input_dataset);
            nd.add_input(data_input_datasets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DirectedInterleaveDataset::new().build(selector_input_dataset, data_input_datasets, scope)`.
pub fn directed_interleave_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    selector_input_dataset: O0,
    data_input_datasets: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DirectedInterleaveDataset::new().build(selector_input_dataset, data_input_datasets, scope)
}
/// Builder for the `Div` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Div {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Div {
    /// Creates a new `Div`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Div` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Div", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Div::new().build(x, y, scope)`.
pub fn div<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Div::new().build(x, y, scope)
}
/// Builder for the `DivNoNan` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DivNoNan {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DivNoNan {
    /// Creates a new `DivNoNan`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DivNoNan` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DivNoNan", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DivNoNan::new().build(x, y, scope)`.
pub fn div_no_nan<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DivNoNan::new().build(x, y, scope)
}
/// Builder for the `DrawBoundingBoxes` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DrawBoundingBoxes {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DrawBoundingBoxes {
    /// Creates a new `DrawBoundingBoxes`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DrawBoundingBoxes` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        boxes: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), boxes.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        boxes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DrawBoundingBoxes", |nd| {
            nd.add_input(images);
            nd.add_input(boxes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DrawBoundingBoxes::new().build(images, boxes, scope)`.
pub fn draw_bounding_boxes<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    boxes: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DrawBoundingBoxes::new().build(images, boxes, scope)
}
/// Builder for the `DrawBoundingBoxesV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DrawBoundingBoxesV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DrawBoundingBoxesV2 {
    /// Creates a new `DrawBoundingBoxesV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DrawBoundingBoxesV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        boxes: O1,
        colors: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), boxes.into(), colors.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        boxes: crate::Output,
        colors: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DrawBoundingBoxesV2", |nd| {
            nd.add_input(images);
            nd.add_input(boxes);
            nd.add_input(colors);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DrawBoundingBoxesV2::new().build(images, boxes, colors, scope)`.
pub fn draw_bounding_boxes_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    boxes: O1,
    colors: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DrawBoundingBoxesV2::new().build(images, boxes, colors, scope)
}
/// Builder for the `DummyIterationCounter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DummyIterationCounter {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DummyIterationCounter {
    /// Creates a new `DummyIterationCounter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DummyIterationCounter` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("DummyIterationCounter", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DummyIterationCounter::new().build(scope)`.
pub fn dummy_iteration_counter(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    DummyIterationCounter::new().build(scope)
}
/// Builder for the `DummyMemoryCache` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DummyMemoryCache {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DummyMemoryCache {
    /// Creates a new `DummyMemoryCache`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DummyMemoryCache` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("DummyMemoryCache", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DummyMemoryCache::new().build(scope)`.
pub fn dummy_memory_cache(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    DummyMemoryCache::new().build(scope)
}
/// Builder for the `DummySeedGenerator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DummySeedGenerator {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DummySeedGenerator {
    /// Creates a new `DummySeedGenerator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DummySeedGenerator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("DummySeedGenerator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DummySeedGenerator::new().build(scope)`.
pub fn dummy_seed_generator(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    DummySeedGenerator::new().build(scope)
}
/// Builder for the `DynamicPartition` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DynamicPartition {
    num_partitions: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DynamicPartition {
    /// Creates a new `DynamicPartition`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_partitions` attribute.
    pub fn num_partitions<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_partitions = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DynamicPartition` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        partitions: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), partitions.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        partitions: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DynamicPartition", |nd| {
            nd.add_input(data);
            nd.add_input(partitions);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_partitions {
                nd.set_attr_int("num_partitions", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DynamicPartition::new().build(data, partitions, scope)`.
pub fn dynamic_partition<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    partitions: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DynamicPartition::new().build(data, partitions, scope)
}
/// Builder for the `DynamicStitch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct DynamicStitch {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl DynamicStitch {
    /// Creates a new `DynamicStitch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `DynamicStitch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        data: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), data.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("DynamicStitch", |nd| {
            nd.add_input(indices);
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `DynamicStitch::new().build(indices, data, scope)`.
pub fn dynamic_stitch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    data: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    DynamicStitch::new().build(indices, data, scope)
}
/// Builder for the `EagerPyFunc` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EagerPyFunc {
    token: ::std::option::Option<::std::string::String>,
    is_async: ::std::option::Option<bool>,
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EagerPyFunc {
    /// Creates a new `EagerPyFunc`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `token` attribute.
    pub fn token<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.token = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_async` attribute.
    pub fn is_async<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_async = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EagerPyFunc` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EagerPyFunc", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.token {
                nd.set_attr_string("token", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_async {
                nd.set_attr_bool("is_async", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EagerPyFunc::new().build(input, scope)`.
pub fn eager_py_func<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EagerPyFunc::new().build(input, scope)
}
/// Builder for the `EditDistance` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EditDistance {
    normalize: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EditDistance {
    /// Creates a new `EditDistance`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `normalize` attribute.
    pub fn normalize<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.normalize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EditDistance` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        hypothesis_indices: O0,
        hypothesis_values: O1,
        hypothesis_shape: O2,
        truth_indices: O3,
        truth_values: O4,
        truth_shape: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            hypothesis_indices.into(),
            hypothesis_values.into(),
            hypothesis_shape.into(),
            truth_indices.into(),
            truth_values.into(),
            truth_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        hypothesis_indices: crate::Output,
        hypothesis_values: crate::Output,
        hypothesis_shape: crate::Output,
        truth_indices: crate::Output,
        truth_values: crate::Output,
        truth_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EditDistance", |nd| {
            nd.add_input(hypothesis_indices);
            nd.add_input(hypothesis_values);
            nd.add_input(hypothesis_shape);
            nd.add_input(truth_indices);
            nd.add_input(truth_values);
            nd.add_input(truth_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.normalize {
                nd.set_attr_bool("normalize", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EditDistance::new().build(hypothesis_indices, hypothesis_values, hypothesis_shape, truth_indices, truth_values, truth_shape, scope)`.
pub fn edit_distance<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    hypothesis_indices: O0,
    hypothesis_values: O1,
    hypothesis_shape: O2,
    truth_indices: O3,
    truth_values: O4,
    truth_shape: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EditDistance::new().build(
        hypothesis_indices,
        hypothesis_values,
        hypothesis_shape,
        truth_indices,
        truth_values,
        truth_shape,
        scope,
    )
}
/// Builder for the `Eig` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Eig {
    compute_v: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Eig {
    /// Creates a new `Eig`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `compute_v` attribute.
    pub fn compute_v<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.compute_v = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Eig` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Eig", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.compute_v {
                nd.set_attr_bool("compute_v", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Eig::new().build(input, scope)`.
pub fn eig<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Eig::new().build(input, scope)
}
/// Builder for the `Einsum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Einsum {
    equation: ::std::option::Option<::std::string::String>,
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Einsum {
    /// Creates a new `Einsum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `equation` attribute.
    pub fn equation<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.equation = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Einsum` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Einsum", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.equation {
                nd.set_attr_string("equation", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Einsum::new().build(inputs, scope)`.
pub fn einsum<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Einsum::new().build(inputs, scope)
}
/// Builder for the `Elu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Elu {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Elu {
    /// Creates a new `Elu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Elu` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        features: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Elu", |nd| {
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Elu::new().build(features, scope)`.
pub fn elu<O0: ::std::convert::Into<crate::Output>>(
    features: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Elu::new().build(features, scope)
}
/// Builder for the `EluGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EluGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EluGrad {
    /// Creates a new `EluGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EluGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        outputs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(gradients.into(), outputs.into(), scope)
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        outputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EluGrad", |nd| {
            nd.add_input(gradients);
            nd.add_input(outputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EluGrad::new().build(gradients, outputs, scope)`.
pub fn elu_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    outputs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EluGrad::new().build(gradients, outputs, scope)
}
/// Builder for the `Empty` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Empty {
    dtype: ::std::option::Option<crate::DataType>,
    init: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Empty {
    /// Creates a new `Empty`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `init` attribute.
    pub fn init<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.init = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Empty` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        shape: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Empty", |nd| {
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.init {
                nd.set_attr_bool("init", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Empty::new().build(shape, scope)`.
pub fn empty<O0: ::std::convert::Into<crate::Output>>(
    shape: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Empty::new().build(shape, scope)
}
/// Builder for the `EmptyTensorList` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EmptyTensorList {
    element_dtype: ::std::option::Option<crate::DataType>,
    shape_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EmptyTensorList {
    /// Creates a new `EmptyTensorList`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_type` attribute.
    pub fn shape_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EmptyTensorList` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        element_shape: O0,
        max_num_elements: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(element_shape.into(), max_num_elements.into(), scope)
    }

    fn build_impl(
        &self,
        element_shape: crate::Output,
        max_num_elements: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EmptyTensorList", |nd| {
            nd.add_input(element_shape);
            nd.add_input(max_num_elements);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_type {
                nd.set_attr_type("shape_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EmptyTensorList::new().build(element_shape, max_num_elements, scope)`.
pub fn empty_tensor_list<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    element_shape: O0,
    max_num_elements: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EmptyTensorList::new().build(element_shape, max_num_elements, scope)
}
/// Builder for the `EncodeBase64` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeBase64 {
    pad: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EncodeBase64 {
    /// Creates a new `EncodeBase64`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `pad` attribute.
    pub fn pad<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.pad = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EncodeBase64` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EncodeBase64", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.pad {
                nd.set_attr_bool("pad", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EncodeBase64::new().build(input, scope)`.
pub fn encode_base64<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EncodeBase64::new().build(input, scope)
}
/// Builder for the `EncodeJpeg` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeJpeg {
    format: ::std::option::Option<::std::string::String>,
    quality: ::std::option::Option<i64>,
    progressive: ::std::option::Option<bool>,
    optimize_size: ::std::option::Option<bool>,
    chroma_downsampling: ::std::option::Option<bool>,
    density_unit: ::std::option::Option<::std::string::String>,
    x_density: ::std::option::Option<i64>,
    y_density: ::std::option::Option<i64>,
    xmp_metadata: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EncodeJpeg {
    /// Creates a new `EncodeJpeg`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `format` attribute.
    pub fn format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `quality` attribute.
    pub fn quality<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.quality = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `progressive` attribute.
    pub fn progressive<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.progressive = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `optimize_size` attribute.
    pub fn optimize_size<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.optimize_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `chroma_downsampling` attribute.
    pub fn chroma_downsampling<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.chroma_downsampling = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `density_unit` attribute.
    pub fn density_unit<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.density_unit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `x_density` attribute.
    pub fn x_density<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.x_density = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `y_density` attribute.
    pub fn y_density<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.y_density = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `xmp_metadata` attribute.
    pub fn xmp_metadata<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.xmp_metadata = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EncodeJpeg` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        image: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(image.into(), scope)
    }

    fn build_impl(
        &self,
        image: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EncodeJpeg", |nd| {
            nd.add_input(image);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.format {
                nd.set_attr_string("format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.quality {
                nd.set_attr_int("quality", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.progressive {
                nd.set_attr_bool("progressive", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.optimize_size {
                nd.set_attr_bool("optimize_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.chroma_downsampling {
                nd.set_attr_bool("chroma_downsampling", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.density_unit {
                nd.set_attr_string("density_unit", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.x_density {
                nd.set_attr_int("x_density", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.y_density {
                nd.set_attr_int("y_density", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.xmp_metadata {
                nd.set_attr_string("xmp_metadata", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EncodeJpeg::new().build(image, scope)`.
pub fn encode_jpeg<O0: ::std::convert::Into<crate::Output>>(
    image: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EncodeJpeg::new().build(image, scope)
}
/// Builder for the `EncodeJpegVariableQuality` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeJpegVariableQuality {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EncodeJpegVariableQuality {
    /// Creates a new `EncodeJpegVariableQuality`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EncodeJpegVariableQuality` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        quality: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), quality.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        quality: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EncodeJpegVariableQuality", |nd| {
            nd.add_input(images);
            nd.add_input(quality);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EncodeJpegVariableQuality::new().build(images, quality, scope)`.
pub fn encode_jpeg_variable_quality<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    quality: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EncodeJpegVariableQuality::new().build(images, quality, scope)
}
/// Builder for the `EncodePng` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodePng {
    compression: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EncodePng {
    /// Creates a new `EncodePng`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `compression` attribute.
    pub fn compression<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.compression = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EncodePng` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        image: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(image.into(), scope)
    }

    fn build_impl(
        &self,
        image: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EncodePng", |nd| {
            nd.add_input(image);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.compression {
                nd.set_attr_int("compression", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EncodePng::new().build(image, scope)`.
pub fn encode_png<O0: ::std::convert::Into<crate::Output>>(
    image: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EncodePng::new().build(image, scope)
}
/// Builder for the `EncodeProto` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeProto {
    field_names: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    message_type: ::std::option::Option<::std::string::String>,
    descriptor_source: ::std::option::Option<::std::string::String>,
    Tinput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EncodeProto {
    /// Creates a new `EncodeProto`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `field_names` attribute.
    pub fn field_names<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.field_names = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `message_type` attribute.
    pub fn message_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.message_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `descriptor_source` attribute.
    pub fn descriptor_source<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.descriptor_source = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tinput_types` attribute.
    pub fn Tinput_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EncodeProto` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sizes: O0,
        values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(sizes.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        sizes: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EncodeProto", |nd| {
            nd.add_input(sizes);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.field_names {
                nd.set_attr_string_list("field_names", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.message_type {
                nd.set_attr_string("message_type", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.descriptor_source {
                nd.set_attr_string("descriptor_source", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tinput_types {
                nd.set_attr_type_list("Tinput_types", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EncodeProto::new().build(sizes, values, scope)`.
pub fn encode_proto<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    sizes: O0,
    values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EncodeProto::new().build(sizes, values, scope)
}
/// Builder for the `EncodeWav` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EncodeWav {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EncodeWav {
    /// Creates a new `EncodeWav`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EncodeWav` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        audio: O0,
        sample_rate: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(audio.into(), sample_rate.into(), scope)
    }

    fn build_impl(
        &self,
        audio: crate::Output,
        sample_rate: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EncodeWav", |nd| {
            nd.add_input(audio);
            nd.add_input(sample_rate);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EncodeWav::new().build(audio, sample_rate, scope)`.
pub fn encode_wav<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    audio: O0,
    sample_rate: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EncodeWav::new().build(audio, sample_rate, scope)
}
/// Builder for the `EnqueueTPUEmbeddingIntegerBatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnqueueTPUEmbeddingIntegerBatch {
    N: ::std::option::Option<i64>,
    device_ordinal: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EnqueueTPUEmbeddingIntegerBatch {
    /// Creates a new `EnqueueTPUEmbeddingIntegerBatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EnqueueTPUEmbeddingIntegerBatch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        batch: O0,
        mode_override: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(batch.into(), mode_override.into(), scope)
    }

    fn build_impl(
        &self,
        batch: crate::Output,
        mode_override: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EnqueueTPUEmbeddingIntegerBatch", |nd| {
            nd.add_input(batch);
            nd.add_input(mode_override);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EnqueueTPUEmbeddingIntegerBatch::new().build(batch, mode_override, scope)`.
pub fn enqueue_tpuembedding_integer_batch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    batch: O0,
    mode_override: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EnqueueTPUEmbeddingIntegerBatch::new().build(batch, mode_override, scope)
}
/// Builder for the `EnqueueTPUEmbeddingRaggedTensorBatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnqueueTPUEmbeddingRaggedTensorBatch {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    T3: ::std::option::Option<crate::DataType>,
    N: ::std::option::Option<i64>,
    device_ordinal: ::std::option::Option<i64>,
    combiners: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    table_ids: ::std::option::Option<::std::vec::Vec<i64>>,
    max_sequence_lengths: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EnqueueTPUEmbeddingRaggedTensorBatch {
    /// Creates a new `EnqueueTPUEmbeddingRaggedTensorBatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T3` attribute.
    pub fn T3<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T3 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `combiners` attribute.
    pub fn combiners<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.combiners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_ids` attribute.
    pub fn table_ids<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_ids = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_sequence_lengths` attribute.
    pub fn max_sequence_lengths<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.max_sequence_lengths = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EnqueueTPUEmbeddingRaggedTensorBatch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sample_splits: O0,
        embedding_indices: O1,
        aggregation_weights: O2,
        mode_override: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sample_splits.into(),
            embedding_indices.into(),
            aggregation_weights.into(),
            mode_override.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sample_splits: crate::Output,
        embedding_indices: crate::Output,
        aggregation_weights: crate::Output,
        mode_override: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EnqueueTPUEmbeddingRaggedTensorBatch", |nd| {
            nd.add_input(sample_splits);
            nd.add_input(embedding_indices);
            nd.add_input(aggregation_weights);
            nd.add_input(mode_override);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T3 {
                nd.set_attr_type("T3", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.combiners {
                nd.set_attr_string_list("combiners", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_ids {
                nd.set_attr_int_list("table_ids", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_sequence_lengths {
                nd.set_attr_int_list("max_sequence_lengths", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EnqueueTPUEmbeddingRaggedTensorBatch::new().build(sample_splits, embedding_indices, aggregation_weights, mode_override, scope)`.
pub fn enqueue_tpuembedding_ragged_tensor_batch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    sample_splits: O0,
    embedding_indices: O1,
    aggregation_weights: O2,
    mode_override: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EnqueueTPUEmbeddingRaggedTensorBatch::new().build(
        sample_splits,
        embedding_indices,
        aggregation_weights,
        mode_override,
        scope,
    )
}
/// Builder for the `EnqueueTPUEmbeddingSparseBatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnqueueTPUEmbeddingSparseBatch {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    T3: ::std::option::Option<crate::DataType>,
    N: ::std::option::Option<i64>,
    device_ordinal: ::std::option::Option<i64>,
    combiners: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EnqueueTPUEmbeddingSparseBatch {
    /// Creates a new `EnqueueTPUEmbeddingSparseBatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T3` attribute.
    pub fn T3<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T3 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `combiners` attribute.
    pub fn combiners<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.combiners = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EnqueueTPUEmbeddingSparseBatch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sample_indices: O0,
        embedding_indices: O1,
        aggregation_weights: O2,
        mode_override: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sample_indices.into(),
            embedding_indices.into(),
            aggregation_weights.into(),
            mode_override.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sample_indices: crate::Output,
        embedding_indices: crate::Output,
        aggregation_weights: crate::Output,
        mode_override: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EnqueueTPUEmbeddingSparseBatch", |nd| {
            nd.add_input(sample_indices);
            nd.add_input(embedding_indices);
            nd.add_input(aggregation_weights);
            nd.add_input(mode_override);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T3 {
                nd.set_attr_type("T3", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.combiners {
                nd.set_attr_string_list("combiners", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EnqueueTPUEmbeddingSparseBatch::new().build(sample_indices, embedding_indices, aggregation_weights, mode_override, scope)`.
pub fn enqueue_tpuembedding_sparse_batch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    sample_indices: O0,
    embedding_indices: O1,
    aggregation_weights: O2,
    mode_override: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EnqueueTPUEmbeddingSparseBatch::new().build(
        sample_indices,
        embedding_indices,
        aggregation_weights,
        mode_override,
        scope,
    )
}
/// Builder for the `EnqueueTPUEmbeddingSparseTensorBatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnqueueTPUEmbeddingSparseTensorBatch {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    T3: ::std::option::Option<crate::DataType>,
    N: ::std::option::Option<i64>,
    device_ordinal: ::std::option::Option<i64>,
    combiners: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    table_ids: ::std::option::Option<::std::vec::Vec<i64>>,
    max_sequence_lengths: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EnqueueTPUEmbeddingSparseTensorBatch {
    /// Creates a new `EnqueueTPUEmbeddingSparseTensorBatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T3` attribute.
    pub fn T3<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T3 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `combiners` attribute.
    pub fn combiners<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.combiners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_ids` attribute.
    pub fn table_ids<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_ids = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_sequence_lengths` attribute.
    pub fn max_sequence_lengths<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.max_sequence_lengths = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EnqueueTPUEmbeddingSparseTensorBatch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sample_indices: O0,
        embedding_indices: O1,
        aggregation_weights: O2,
        mode_override: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sample_indices.into(),
            embedding_indices.into(),
            aggregation_weights.into(),
            mode_override.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sample_indices: crate::Output,
        embedding_indices: crate::Output,
        aggregation_weights: crate::Output,
        mode_override: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EnqueueTPUEmbeddingSparseTensorBatch", |nd| {
            nd.add_input(sample_indices);
            nd.add_input(embedding_indices);
            nd.add_input(aggregation_weights);
            nd.add_input(mode_override);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T3 {
                nd.set_attr_type("T3", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.combiners {
                nd.set_attr_string_list("combiners", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_ids {
                nd.set_attr_int_list("table_ids", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_sequence_lengths {
                nd.set_attr_int_list("max_sequence_lengths", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EnqueueTPUEmbeddingSparseTensorBatch::new().build(sample_indices, embedding_indices, aggregation_weights, mode_override, scope)`.
pub fn enqueue_tpuembedding_sparse_tensor_batch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    sample_indices: O0,
    embedding_indices: O1,
    aggregation_weights: O2,
    mode_override: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EnqueueTPUEmbeddingSparseTensorBatch::new().build(
        sample_indices,
        embedding_indices,
        aggregation_weights,
        mode_override,
        scope,
    )
}
/// Builder for the `EnsureShape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EnsureShape {
    shape: ::std::option::Option<crate::Shape>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EnsureShape {
    /// Creates a new `EnsureShape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EnsureShape` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EnsureShape", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EnsureShape::new().build(input, scope)`.
pub fn ensure_shape<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EnsureShape::new().build(input, scope)
}
/// Builder for the `Enter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Enter {
    T: ::std::option::Option<crate::DataType>,
    frame_name: ::std::option::Option<::std::string::String>,
    is_constant: ::std::option::Option<bool>,
    parallel_iterations: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Enter {
    /// Creates a new `Enter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `frame_name` attribute.
    pub fn frame_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.frame_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_constant` attribute.
    pub fn is_constant<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_constant = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `parallel_iterations` attribute.
    pub fn parallel_iterations<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.parallel_iterations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Enter` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        data: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Enter", |nd| {
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.frame_name {
                nd.set_attr_string("frame_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_constant {
                nd.set_attr_bool("is_constant", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.parallel_iterations {
                nd.set_attr_int("parallel_iterations", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Enter::new().build(data, scope)`.
pub fn enter<O0: ::std::convert::Into<crate::Output>>(
    data: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Enter::new().build(data, scope)
}
/// Builder for the `Equal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Equal {
    T: ::std::option::Option<crate::DataType>,
    incompatible_shape_error: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Equal {
    /// Creates a new `Equal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `incompatible_shape_error` attribute.
    pub fn incompatible_shape_error<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.incompatible_shape_error = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Equal` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Equal", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.incompatible_shape_error {
                nd.set_attr_bool("incompatible_shape_error", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Equal::new().build(x, y, scope)`.
pub fn equal<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Equal::new().build(x, y, scope)
}
/// Builder for the `Erf` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Erf {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Erf {
    /// Creates a new `Erf`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Erf` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Erf", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Erf::new().build(x, scope)`.
pub fn erf<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Erf::new().build(x, scope)
}
/// Builder for the `Erfc` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Erfc {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Erfc {
    /// Creates a new `Erfc`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Erfc` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Erfc", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Erfc::new().build(x, scope)`.
pub fn erfc<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Erfc::new().build(x, scope)
}
/// Builder for the `Erfinv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Erfinv {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Erfinv {
    /// Creates a new `Erfinv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Erfinv` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Erfinv", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Erfinv::new().build(x, scope)`.
pub fn erfinv<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Erfinv::new().build(x, scope)
}
/// Builder for the `EuclideanNorm` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct EuclideanNorm {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl EuclideanNorm {
    /// Creates a new `EuclideanNorm`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `EuclideanNorm` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("EuclideanNorm", |nd| {
            nd.add_input(input);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `EuclideanNorm::new().build(input, reduction_indices, scope)`.
pub fn euclidean_norm<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    EuclideanNorm::new().build(input, reduction_indices, scope)
}
/// Builder for the `Exit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Exit {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Exit {
    /// Creates a new `Exit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Exit` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        data: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Exit", |nd| {
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Exit::new().build(data, scope)`.
pub fn exit<O0: ::std::convert::Into<crate::Output>>(
    data: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Exit::new().build(data, scope)
}
/// Builder for the `Exp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Exp {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Exp {
    /// Creates a new `Exp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Exp` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Exp", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Exp::new().build(x, scope)`.
pub fn exp<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Exp::new().build(x, scope)
}
/// Builder for the `ExpandDims` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExpandDims {
    T: ::std::option::Option<crate::DataType>,
    Tdim: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExpandDims {
    /// Creates a new `ExpandDims`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tdim` attribute.
    pub fn Tdim<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tdim = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExpandDims` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        dim: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), dim.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        dim: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExpandDims", |nd| {
            nd.add_input(input);
            nd.add_input(dim);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tdim {
                nd.set_attr_type("Tdim", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExpandDims::new().build(input, dim, scope)`.
pub fn expand_dims<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    dim: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExpandDims::new().build(input, dim, scope)
}
/// Builder for the `ExperimentalAssertNextDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalAssertNextDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalAssertNextDataset {
    /// Creates a new `ExperimentalAssertNextDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalAssertNextDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        transformations: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), transformations.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        transformations: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalAssertNextDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(transformations);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalAssertNextDataset::new().build(input_dataset, transformations, scope)`.
pub fn experimental_assert_next_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    transformations: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalAssertNextDataset::new().build(input_dataset, transformations, scope)
}
/// Builder for the `ExperimentalAutoShardDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalAutoShardDataset {
    auto_shard_policy: ::std::option::Option<i64>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalAutoShardDataset {
    /// Creates a new `ExperimentalAutoShardDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `auto_shard_policy` attribute.
    pub fn auto_shard_policy<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.auto_shard_policy = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalAutoShardDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_workers: O1,
        index: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            num_workers.into(),
            index.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_workers: crate::Output,
        index: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalAutoShardDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_workers);
            nd.add_input(index);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.auto_shard_policy {
                nd.set_attr_int("auto_shard_policy", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalAutoShardDataset::new().build(input_dataset, num_workers, index, scope)`.
pub fn experimental_auto_shard_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_workers: O1,
    index: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalAutoShardDataset::new().build(input_dataset, num_workers, index, scope)
}
/// Builder for the `ExperimentalBytesProducedStatsDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalBytesProducedStatsDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalBytesProducedStatsDataset {
    /// Creates a new `ExperimentalBytesProducedStatsDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalBytesProducedStatsDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        tag: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), tag.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        tag: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalBytesProducedStatsDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(tag);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalBytesProducedStatsDataset::new().build(input_dataset, tag, scope)`.
pub fn experimental_bytes_produced_stats_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    tag: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalBytesProducedStatsDataset::new().build(input_dataset, tag, scope)
}
/// Builder for the `ExperimentalCSVDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalCSVDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalCSVDataset {
    /// Creates a new `ExperimentalCSVDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalCSVDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filenames: O0,
        compression_type: O1,
        buffer_size: O2,
        header: O3,
        field_delim: O4,
        use_quote_delim: O5,
        na_value: O6,
        select_cols: O7,
        record_defaults: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            filenames.into(),
            compression_type.into(),
            buffer_size.into(),
            header.into(),
            field_delim.into(),
            use_quote_delim.into(),
            na_value.into(),
            select_cols.into(),
            record_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        filenames: crate::Output,
        compression_type: crate::Output,
        buffer_size: crate::Output,
        header: crate::Output,
        field_delim: crate::Output,
        use_quote_delim: crate::Output,
        na_value: crate::Output,
        select_cols: crate::Output,
        record_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalCSVDataset", |nd| {
            nd.add_input(filenames);
            nd.add_input(compression_type);
            nd.add_input(buffer_size);
            nd.add_input(header);
            nd.add_input(field_delim);
            nd.add_input(use_quote_delim);
            nd.add_input(na_value);
            nd.add_input(select_cols);
            nd.add_input(record_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalCSVDataset::new().build(filenames, compression_type, buffer_size, header, field_delim, use_quote_delim, na_value, select_cols, record_defaults, scope)`.
pub fn experimental_csvdataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    filenames: O0,
    compression_type: O1,
    buffer_size: O2,
    header: O3,
    field_delim: O4,
    use_quote_delim: O5,
    na_value: O6,
    select_cols: O7,
    record_defaults: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalCSVDataset::new().build(
        filenames,
        compression_type,
        buffer_size,
        header,
        field_delim,
        use_quote_delim,
        na_value,
        select_cols,
        record_defaults,
        scope,
    )
}
/// Builder for the `ExperimentalChooseFastestDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalChooseFastestDataset {
    N: ::std::option::Option<i64>,
    num_experiments: ::std::option::Option<i64>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalChooseFastestDataset {
    /// Creates a new `ExperimentalChooseFastestDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_experiments` attribute.
    pub fn num_experiments<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_experiments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalChooseFastestDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_datasets: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_datasets.into(), scope)
    }

    fn build_impl(
        &self,
        input_datasets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalChooseFastestDataset", |nd| {
            nd.add_input(input_datasets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_experiments {
                nd.set_attr_int("num_experiments", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalChooseFastestDataset::new().build(input_datasets, scope)`.
pub fn experimental_choose_fastest_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_datasets: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalChooseFastestDataset::new().build(input_datasets, scope)
}
/// Builder for the `ExperimentalDatasetCardinality` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalDatasetCardinality {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalDatasetCardinality {
    /// Creates a new `ExperimentalDatasetCardinality`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalDatasetCardinality` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalDatasetCardinality", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalDatasetCardinality::new().build(input_dataset, scope)`.
pub fn experimental_dataset_cardinality<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalDatasetCardinality::new().build(input_dataset, scope)
}
/// Builder for the `ExperimentalDatasetToTFRecord` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalDatasetToTFRecord {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalDatasetToTFRecord {
    /// Creates a new `ExperimentalDatasetToTFRecord`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalDatasetToTFRecord` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        filename: O1,
        compression_type: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            filename.into(),
            compression_type.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        filename: crate::Output,
        compression_type: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalDatasetToTFRecord", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(filename);
            nd.add_input(compression_type);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalDatasetToTFRecord::new().build(input_dataset, filename, compression_type, scope)`.
pub fn experimental_dataset_to_tfrecord<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    filename: O1,
    compression_type: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalDatasetToTFRecord::new().build(input_dataset, filename, compression_type, scope)
}
/// Builder for the `ExperimentalDenseToSparseBatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalDenseToSparseBatchDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalDenseToSparseBatchDataset {
    /// Creates a new `ExperimentalDenseToSparseBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalDenseToSparseBatchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        batch_size: O1,
        row_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            batch_size.into(),
            row_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        batch_size: crate::Output,
        row_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalDenseToSparseBatchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(batch_size);
            nd.add_input(row_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalDenseToSparseBatchDataset::new().build(input_dataset, batch_size, row_shape, scope)`.
pub fn experimental_dense_to_sparse_batch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    batch_size: O1,
    row_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalDenseToSparseBatchDataset::new().build(input_dataset, batch_size, row_shape, scope)
}
/// Builder for the `ExperimentalDirectedInterleaveDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalDirectedInterleaveDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalDirectedInterleaveDataset {
    /// Creates a new `ExperimentalDirectedInterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalDirectedInterleaveDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        selector_input_dataset: O0,
        data_input_datasets: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            selector_input_dataset.into(),
            data_input_datasets.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        selector_input_dataset: crate::Output,
        data_input_datasets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalDirectedInterleaveDataset", |nd| {
            nd.add_input(selector_input_dataset);
            nd.add_input(data_input_datasets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalDirectedInterleaveDataset::new().build(selector_input_dataset, data_input_datasets, scope)`.
pub fn experimental_directed_interleave_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    selector_input_dataset: O0,
    data_input_datasets: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalDirectedInterleaveDataset::new().build(
        selector_input_dataset,
        data_input_datasets,
        scope,
    )
}
/// Builder for the `ExperimentalGroupByReducerDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalGroupByReducerDataset {
    key_func: ::std::option::Option<::std::string::String>,
    init_func: ::std::option::Option<::std::string::String>,
    reduce_func: ::std::option::Option<::std::string::String>,
    finalize_func: ::std::option::Option<::std::string::String>,
    Tkey_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tinit_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Treduce_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tfinalize_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalGroupByReducerDataset {
    /// Creates a new `ExperimentalGroupByReducerDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `key_func` attribute.
    pub fn key_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `init_func` attribute.
    pub fn init_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.init_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reduce_func` attribute.
    pub fn reduce_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduce_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `finalize_func` attribute.
    pub fn finalize_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.finalize_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tkey_func_other_arguments` attribute.
    pub fn Tkey_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tkey_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tinit_func_other_arguments` attribute.
    pub fn Tinit_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinit_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Treduce_func_other_arguments` attribute.
    pub fn Treduce_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Treduce_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfinalize_func_other_arguments` attribute.
    pub fn Tfinalize_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfinalize_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalGroupByReducerDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        key_func_other_arguments: O1,
        init_func_other_arguments: O2,
        reduce_func_other_arguments: O3,
        finalize_func_other_arguments: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            key_func_other_arguments.into(),
            init_func_other_arguments.into(),
            reduce_func_other_arguments.into(),
            finalize_func_other_arguments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        key_func_other_arguments: crate::Output,
        init_func_other_arguments: crate::Output,
        reduce_func_other_arguments: crate::Output,
        finalize_func_other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalGroupByReducerDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(key_func_other_arguments);
            nd.add_input(init_func_other_arguments);
            nd.add_input(reduce_func_other_arguments);
            nd.add_input(finalize_func_other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.key_func {
                nd.set_attr_string("key_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.init_func {
                nd.set_attr_string("init_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reduce_func {
                nd.set_attr_string("reduce_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.finalize_func {
                nd.set_attr_string("finalize_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tkey_func_other_arguments {
                nd.set_attr_type_list("Tkey_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tinit_func_other_arguments {
                nd.set_attr_type_list("Tinit_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Treduce_func_other_arguments {
                nd.set_attr_type_list("Treduce_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfinalize_func_other_arguments {
                nd.set_attr_type_list("Tfinalize_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalGroupByReducerDataset::new().build(input_dataset, key_func_other_arguments, init_func_other_arguments, reduce_func_other_arguments, finalize_func_other_arguments, scope)`.
pub fn experimental_group_by_reducer_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    key_func_other_arguments: O1,
    init_func_other_arguments: O2,
    reduce_func_other_arguments: O3,
    finalize_func_other_arguments: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalGroupByReducerDataset::new().build(
        input_dataset,
        key_func_other_arguments,
        init_func_other_arguments,
        reduce_func_other_arguments,
        finalize_func_other_arguments,
        scope,
    )
}
/// Builder for the `ExperimentalGroupByWindowDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalGroupByWindowDataset {
    key_func: ::std::option::Option<::std::string::String>,
    reduce_func: ::std::option::Option<::std::string::String>,
    window_size_func: ::std::option::Option<::std::string::String>,
    Tkey_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Treduce_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Twindow_size_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalGroupByWindowDataset {
    /// Creates a new `ExperimentalGroupByWindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `key_func` attribute.
    pub fn key_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reduce_func` attribute.
    pub fn reduce_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduce_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `window_size_func` attribute.
    pub fn window_size_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.window_size_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tkey_func_other_arguments` attribute.
    pub fn Tkey_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tkey_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Treduce_func_other_arguments` attribute.
    pub fn Treduce_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Treduce_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Twindow_size_func_other_arguments` attribute.
    pub fn Twindow_size_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Twindow_size_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalGroupByWindowDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        key_func_other_arguments: O1,
        reduce_func_other_arguments: O2,
        window_size_func_other_arguments: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            key_func_other_arguments.into(),
            reduce_func_other_arguments.into(),
            window_size_func_other_arguments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        key_func_other_arguments: crate::Output,
        reduce_func_other_arguments: crate::Output,
        window_size_func_other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalGroupByWindowDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(key_func_other_arguments);
            nd.add_input(reduce_func_other_arguments);
            nd.add_input(window_size_func_other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.key_func {
                nd.set_attr_string("key_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reduce_func {
                nd.set_attr_string("reduce_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.window_size_func {
                nd.set_attr_string("window_size_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tkey_func_other_arguments {
                nd.set_attr_type_list("Tkey_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Treduce_func_other_arguments {
                nd.set_attr_type_list("Treduce_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Twindow_size_func_other_arguments {
                nd.set_attr_type_list("Twindow_size_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalGroupByWindowDataset::new().build(input_dataset, key_func_other_arguments, reduce_func_other_arguments, window_size_func_other_arguments, scope)`.
pub fn experimental_group_by_window_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    key_func_other_arguments: O1,
    reduce_func_other_arguments: O2,
    window_size_func_other_arguments: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalGroupByWindowDataset::new().build(
        input_dataset,
        key_func_other_arguments,
        reduce_func_other_arguments,
        window_size_func_other_arguments,
        scope,
    )
}
/// Builder for the `ExperimentalIgnoreErrorsDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalIgnoreErrorsDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalIgnoreErrorsDataset {
    /// Creates a new `ExperimentalIgnoreErrorsDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalIgnoreErrorsDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalIgnoreErrorsDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalIgnoreErrorsDataset::new().build(input_dataset, scope)`.
pub fn experimental_ignore_errors_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalIgnoreErrorsDataset::new().build(input_dataset, scope)
}
/// Builder for the `ExperimentalIteratorGetDevice` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalIteratorGetDevice {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalIteratorGetDevice {
    /// Creates a new `ExperimentalIteratorGetDevice`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalIteratorGetDevice` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalIteratorGetDevice", |nd| {
            nd.add_input(resource);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalIteratorGetDevice::new().build(resource, scope)`.
pub fn experimental_iterator_get_device<O0: ::std::convert::Into<crate::Output>>(
    resource: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalIteratorGetDevice::new().build(resource, scope)
}
/// Builder for the `ExperimentalLMDBDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalLMDBDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalLMDBDataset {
    /// Creates a new `ExperimentalLMDBDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalLMDBDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        filenames: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(filenames.into(), scope)
    }

    fn build_impl(
        &self,
        filenames: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalLMDBDataset", |nd| {
            nd.add_input(filenames);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalLMDBDataset::new().build(filenames, scope)`.
pub fn experimental_lmdbdataset<O0: ::std::convert::Into<crate::Output>>(
    filenames: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalLMDBDataset::new().build(filenames, scope)
}
/// Builder for the `ExperimentalLatencyStatsDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalLatencyStatsDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalLatencyStatsDataset {
    /// Creates a new `ExperimentalLatencyStatsDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalLatencyStatsDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        tag: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), tag.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        tag: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalLatencyStatsDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(tag);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalLatencyStatsDataset::new().build(input_dataset, tag, scope)`.
pub fn experimental_latency_stats_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    tag: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalLatencyStatsDataset::new().build(input_dataset, tag, scope)
}
/// Builder for the `ExperimentalMapAndBatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalMapAndBatchDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    preserve_cardinality: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalMapAndBatchDataset {
    /// Creates a new `ExperimentalMapAndBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_cardinality` attribute.
    pub fn preserve_cardinality<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_cardinality = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalMapAndBatchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        batch_size: O2,
        num_parallel_calls: O3,
        drop_remainder: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            batch_size.into(),
            num_parallel_calls.into(),
            drop_remainder.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        batch_size: crate::Output,
        num_parallel_calls: crate::Output,
        drop_remainder: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalMapAndBatchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(batch_size);
            nd.add_input(num_parallel_calls);
            nd.add_input(drop_remainder);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_cardinality {
                nd.set_attr_bool("preserve_cardinality", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalMapAndBatchDataset::new().build(input_dataset, other_arguments, batch_size, num_parallel_calls, drop_remainder, scope)`.
pub fn experimental_map_and_batch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    batch_size: O2,
    num_parallel_calls: O3,
    drop_remainder: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalMapAndBatchDataset::new().build(
        input_dataset,
        other_arguments,
        batch_size,
        num_parallel_calls,
        drop_remainder,
        scope,
    )
}
/// Builder for the `ExperimentalMapDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalMapDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    use_inter_op_parallelism: ::std::option::Option<bool>,
    preserve_cardinality: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalMapDataset {
    /// Creates a new `ExperimentalMapDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_inter_op_parallelism` attribute.
    pub fn use_inter_op_parallelism<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_inter_op_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_cardinality` attribute.
    pub fn preserve_cardinality<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_cardinality = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalMapDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), other_arguments.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalMapDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_inter_op_parallelism {
                nd.set_attr_bool("use_inter_op_parallelism", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_cardinality {
                nd.set_attr_bool("preserve_cardinality", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalMapDataset::new().build(input_dataset, other_arguments, scope)`.
pub fn experimental_map_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalMapDataset::new().build(input_dataset, other_arguments, scope)
}
/// Builder for the `ExperimentalMatchingFilesDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalMatchingFilesDataset {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalMatchingFilesDataset {
    /// Creates a new `ExperimentalMatchingFilesDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalMatchingFilesDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        patterns: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(patterns.into(), scope)
    }

    fn build_impl(
        &self,
        patterns: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalMatchingFilesDataset", |nd| {
            nd.add_input(patterns);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalMatchingFilesDataset::new().build(patterns, scope)`.
pub fn experimental_matching_files_dataset<O0: ::std::convert::Into<crate::Output>>(
    patterns: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalMatchingFilesDataset::new().build(patterns, scope)
}
/// Builder for the `ExperimentalMaxIntraOpParallelismDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalMaxIntraOpParallelismDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalMaxIntraOpParallelismDataset {
    /// Creates a new `ExperimentalMaxIntraOpParallelismDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalMaxIntraOpParallelismDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        max_intra_op_parallelism: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), max_intra_op_parallelism.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        max_intra_op_parallelism: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalMaxIntraOpParallelismDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(max_intra_op_parallelism);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalMaxIntraOpParallelismDataset::new().build(input_dataset, max_intra_op_parallelism, scope)`.
pub fn experimental_max_intra_op_parallelism_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    max_intra_op_parallelism: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalMaxIntraOpParallelismDataset::new().build(
        input_dataset,
        max_intra_op_parallelism,
        scope,
    )
}
/// Builder for the `ExperimentalNonSerializableDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalNonSerializableDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalNonSerializableDataset {
    /// Creates a new `ExperimentalNonSerializableDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalNonSerializableDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalNonSerializableDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalNonSerializableDataset::new().build(input_dataset, scope)`.
pub fn experimental_non_serializable_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalNonSerializableDataset::new().build(input_dataset, scope)
}
/// Builder for the `ExperimentalParallelInterleaveDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalParallelInterleaveDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalParallelInterleaveDataset {
    /// Creates a new `ExperimentalParallelInterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalParallelInterleaveDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        cycle_length: O2,
        block_length: O3,
        sloppy: O4,
        buffer_output_elements: O5,
        prefetch_input_elements: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            cycle_length.into(),
            block_length.into(),
            sloppy.into(),
            buffer_output_elements.into(),
            prefetch_input_elements.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        cycle_length: crate::Output,
        block_length: crate::Output,
        sloppy: crate::Output,
        buffer_output_elements: crate::Output,
        prefetch_input_elements: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalParallelInterleaveDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(cycle_length);
            nd.add_input(block_length);
            nd.add_input(sloppy);
            nd.add_input(buffer_output_elements);
            nd.add_input(prefetch_input_elements);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalParallelInterleaveDataset::new().build(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, scope)`.
pub fn experimental_parallel_interleave_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    cycle_length: O2,
    block_length: O3,
    sloppy: O4,
    buffer_output_elements: O5,
    prefetch_input_elements: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalParallelInterleaveDataset::new().build(
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        sloppy,
        buffer_output_elements,
        prefetch_input_elements,
        scope,
    )
}
/// Builder for the `ExperimentalParseExampleDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalParseExampleDataset {
    sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    sloppy: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalParseExampleDataset {
    /// Creates a new `ExperimentalParseExampleDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `sparse_keys` attribute.
    pub fn sparse_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_keys` attribute.
    pub fn dense_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tdense` attribute.
    pub fn Tdense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tdense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_shapes` attribute.
    pub fn dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sloppy` attribute.
    pub fn sloppy<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.sloppy = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalParseExampleDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_parallel_calls: O1,
        dense_defaults: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            num_parallel_calls.into(),
            dense_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_parallel_calls: crate::Output,
        dense_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalParseExampleDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_parallel_calls);
            nd.add_input(dense_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.sparse_keys {
                nd.set_attr_string_list("sparse_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_keys {
                nd.set_attr_string_list("dense_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tdense {
                nd.set_attr_type_list("Tdense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_shapes {
                nd.set_attr_shape_list("dense_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sloppy {
                nd.set_attr_bool("sloppy", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalParseExampleDataset::new().build(input_dataset, num_parallel_calls, dense_defaults, scope)`.
pub fn experimental_parse_example_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_parallel_calls: O1,
    dense_defaults: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalParseExampleDataset::new().build(
        input_dataset,
        num_parallel_calls,
        dense_defaults,
        scope,
    )
}
/// Builder for the `ExperimentalPrivateThreadPoolDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalPrivateThreadPoolDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalPrivateThreadPoolDataset {
    /// Creates a new `ExperimentalPrivateThreadPoolDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalPrivateThreadPoolDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_threads: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), num_threads.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_threads: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalPrivateThreadPoolDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_threads);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalPrivateThreadPoolDataset::new().build(input_dataset, num_threads, scope)`.
pub fn experimental_private_thread_pool_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_threads: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalPrivateThreadPoolDataset::new().build(input_dataset, num_threads, scope)
}
/// Builder for the `ExperimentalRandomDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalRandomDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalRandomDataset {
    /// Creates a new `ExperimentalRandomDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalRandomDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        seed: O0,
        seed2: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(seed.into(), seed2.into(), scope)
    }

    fn build_impl(
        &self,
        seed: crate::Output,
        seed2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalRandomDataset", |nd| {
            nd.add_input(seed);
            nd.add_input(seed2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalRandomDataset::new().build(seed, seed2, scope)`.
pub fn experimental_random_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    seed: O0,
    seed2: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalRandomDataset::new().build(seed, seed2, scope)
}
/// Builder for the `ExperimentalRebatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalRebatchDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    use_fallback: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalRebatchDataset {
    /// Creates a new `ExperimentalRebatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_fallback` attribute.
    pub fn use_fallback<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_fallback = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalRebatchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_replicas: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), num_replicas.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_replicas: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalRebatchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_replicas);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_fallback {
                nd.set_attr_bool("use_fallback", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalRebatchDataset::new().build(input_dataset, num_replicas, scope)`.
pub fn experimental_rebatch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_replicas: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalRebatchDataset::new().build(input_dataset, num_replicas, scope)
}
/// Builder for the `ExperimentalScanDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalScanDataset {
    f: ::std::option::Option<::std::string::String>,
    Tstate: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    preserve_cardinality: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalScanDataset {
    /// Creates a new `ExperimentalScanDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tstate` attribute.
    pub fn Tstate<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tstate = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_cardinality` attribute.
    pub fn preserve_cardinality<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_cardinality = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalScanDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        initial_state: O1,
        other_arguments: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            initial_state.into(),
            other_arguments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        initial_state: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalScanDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(initial_state);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tstate {
                nd.set_attr_type_list("Tstate", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_cardinality {
                nd.set_attr_bool("preserve_cardinality", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalScanDataset::new().build(input_dataset, initial_state, other_arguments, scope)`.
pub fn experimental_scan_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    initial_state: O1,
    other_arguments: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalScanDataset::new().build(input_dataset, initial_state, other_arguments, scope)
}
/// Builder for the `ExperimentalSetStatsAggregatorDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalSetStatsAggregatorDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalSetStatsAggregatorDataset {
    /// Creates a new `ExperimentalSetStatsAggregatorDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalSetStatsAggregatorDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        stats_aggregator: O1,
        tag: O2,
        counter_prefix: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            stats_aggregator.into(),
            tag.into(),
            counter_prefix.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        stats_aggregator: crate::Output,
        tag: crate::Output,
        counter_prefix: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalSetStatsAggregatorDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(stats_aggregator);
            nd.add_input(tag);
            nd.add_input(counter_prefix);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalSetStatsAggregatorDataset::new().build(input_dataset, stats_aggregator, tag, counter_prefix, scope)`.
pub fn experimental_set_stats_aggregator_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    stats_aggregator: O1,
    tag: O2,
    counter_prefix: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalSetStatsAggregatorDataset::new().build(
        input_dataset,
        stats_aggregator,
        tag,
        counter_prefix,
        scope,
    )
}
/// Builder for the `ExperimentalSleepDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalSleepDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalSleepDataset {
    /// Creates a new `ExperimentalSleepDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalSleepDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        sleep_microseconds: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), sleep_microseconds.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        sleep_microseconds: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalSleepDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(sleep_microseconds);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalSleepDataset::new().build(input_dataset, sleep_microseconds, scope)`.
pub fn experimental_sleep_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    sleep_microseconds: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalSleepDataset::new().build(input_dataset, sleep_microseconds, scope)
}
/// Builder for the `ExperimentalSlidingWindowDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalSlidingWindowDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalSlidingWindowDataset {
    /// Creates a new `ExperimentalSlidingWindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalSlidingWindowDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        window_size: O1,
        window_shift: O2,
        window_stride: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            window_size.into(),
            window_shift.into(),
            window_stride.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        window_size: crate::Output,
        window_shift: crate::Output,
        window_stride: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalSlidingWindowDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(window_size);
            nd.add_input(window_shift);
            nd.add_input(window_stride);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalSlidingWindowDataset::new().build(input_dataset, window_size, window_shift, window_stride, scope)`.
pub fn experimental_sliding_window_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    window_size: O1,
    window_shift: O2,
    window_stride: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalSlidingWindowDataset::new().build(
        input_dataset,
        window_size,
        window_shift,
        window_stride,
        scope,
    )
}
/// Builder for the `ExperimentalSqlDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalSqlDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalSqlDataset {
    /// Creates a new `ExperimentalSqlDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalSqlDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        driver_name: O0,
        data_source_name: O1,
        query: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            driver_name.into(),
            data_source_name.into(),
            query.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        driver_name: crate::Output,
        data_source_name: crate::Output,
        query: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalSqlDataset", |nd| {
            nd.add_input(driver_name);
            nd.add_input(data_source_name);
            nd.add_input(query);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalSqlDataset::new().build(driver_name, data_source_name, query, scope)`.
pub fn experimental_sql_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    driver_name: O0,
    data_source_name: O1,
    query: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalSqlDataset::new().build(driver_name, data_source_name, query, scope)
}
/// Builder for the `ExperimentalStatsAggregatorHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalStatsAggregatorHandle {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalStatsAggregatorHandle {
    /// Creates a new `ExperimentalStatsAggregatorHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalStatsAggregatorHandle` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalStatsAggregatorHandle", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalStatsAggregatorHandle::new().build(scope)`.
pub fn experimental_stats_aggregator_handle(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalStatsAggregatorHandle::new().build(scope)
}
/// Builder for the `ExperimentalStatsAggregatorSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalStatsAggregatorSummary {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalStatsAggregatorSummary {
    /// Creates a new `ExperimentalStatsAggregatorSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalStatsAggregatorSummary` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        iterator: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(iterator.into(), scope)
    }

    fn build_impl(
        &self,
        iterator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalStatsAggregatorSummary", |nd| {
            nd.add_input(iterator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalStatsAggregatorSummary::new().build(iterator, scope)`.
pub fn experimental_stats_aggregator_summary<O0: ::std::convert::Into<crate::Output>>(
    iterator: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalStatsAggregatorSummary::new().build(iterator, scope)
}
/// Builder for the `ExperimentalTakeWhileDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalTakeWhileDataset {
    predicate: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalTakeWhileDataset {
    /// Creates a new `ExperimentalTakeWhileDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `predicate` attribute.
    pub fn predicate<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.predicate = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalTakeWhileDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), other_arguments.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalTakeWhileDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.predicate {
                nd.set_attr_string("predicate", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalTakeWhileDataset::new().build(input_dataset, other_arguments, scope)`.
pub fn experimental_take_while_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalTakeWhileDataset::new().build(input_dataset, other_arguments, scope)
}
/// Builder for the `ExperimentalThreadPoolDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalThreadPoolDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalThreadPoolDataset {
    /// Creates a new `ExperimentalThreadPoolDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalThreadPoolDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        thread_pool: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), thread_pool.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        thread_pool: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalThreadPoolDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(thread_pool);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalThreadPoolDataset::new().build(input_dataset, thread_pool, scope)`.
pub fn experimental_thread_pool_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    thread_pool: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalThreadPoolDataset::new().build(input_dataset, thread_pool, scope)
}
/// Builder for the `ExperimentalThreadPoolHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalThreadPoolHandle {
    num_threads: ::std::option::Option<i64>,
    max_intra_op_parallelism: ::std::option::Option<i64>,
    display_name: ::std::option::Option<::std::string::String>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalThreadPoolHandle {
    /// Creates a new `ExperimentalThreadPoolHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_threads` attribute.
    pub fn num_threads<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_threads = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_intra_op_parallelism` attribute.
    pub fn max_intra_op_parallelism<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.max_intra_op_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `display_name` attribute.
    pub fn display_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.display_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalThreadPoolHandle` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalThreadPoolHandle", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_threads {
                nd.set_attr_int("num_threads", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_intra_op_parallelism {
                nd.set_attr_int("max_intra_op_parallelism", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.display_name {
                nd.set_attr_string("display_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalThreadPoolHandle::new().build(scope)`.
pub fn experimental_thread_pool_handle(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalThreadPoolHandle::new().build(scope)
}
/// Builder for the `ExperimentalUnbatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalUnbatchDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalUnbatchDataset {
    /// Creates a new `ExperimentalUnbatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalUnbatchDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalUnbatchDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalUnbatchDataset::new().build(input_dataset, scope)`.
pub fn experimental_unbatch_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalUnbatchDataset::new().build(input_dataset, scope)
}
/// Builder for the `ExperimentalUniqueDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExperimentalUniqueDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExperimentalUniqueDataset {
    /// Creates a new `ExperimentalUniqueDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExperimentalUniqueDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExperimentalUniqueDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExperimentalUniqueDataset::new().build(input_dataset, scope)`.
pub fn experimental_unique_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExperimentalUniqueDataset::new().build(input_dataset, scope)
}
/// Builder for the `Expint` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Expint {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Expint {
    /// Creates a new `Expint`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Expint` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Expint", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Expint::new().build(x, scope)`.
pub fn expint<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Expint::new().build(x, scope)
}
/// Builder for the `Expm1` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Expm1 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Expm1 {
    /// Creates a new `Expm1`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Expm1` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Expm1", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Expm1::new().build(x, scope)`.
pub fn expm1<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Expm1::new().build(x, scope)
}
/// Builder for the `ExtractGlimpse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractGlimpse {
    centered: ::std::option::Option<bool>,
    normalized: ::std::option::Option<bool>,
    uniform_noise: ::std::option::Option<bool>,
    noise: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExtractGlimpse {
    /// Creates a new `ExtractGlimpse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `centered` attribute.
    pub fn centered<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.centered = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `normalized` attribute.
    pub fn normalized<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.normalized = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `uniform_noise` attribute.
    pub fn uniform_noise<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.uniform_noise = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `noise` attribute.
    pub fn noise<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.noise = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExtractGlimpse` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        size: O1,
        offsets: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), size.into(), offsets.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        size: crate::Output,
        offsets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExtractGlimpse", |nd| {
            nd.add_input(input);
            nd.add_input(size);
            nd.add_input(offsets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.centered {
                nd.set_attr_bool("centered", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.normalized {
                nd.set_attr_bool("normalized", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.uniform_noise {
                nd.set_attr_bool("uniform_noise", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.noise {
                nd.set_attr_string("noise", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExtractGlimpse::new().build(input, size, offsets, scope)`.
pub fn extract_glimpse<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    size: O1,
    offsets: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExtractGlimpse::new().build(input, size, offsets, scope)
}
/// Builder for the `ExtractGlimpseV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractGlimpseV2 {
    centered: ::std::option::Option<bool>,
    normalized: ::std::option::Option<bool>,
    uniform_noise: ::std::option::Option<bool>,
    noise: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExtractGlimpseV2 {
    /// Creates a new `ExtractGlimpseV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `centered` attribute.
    pub fn centered<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.centered = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `normalized` attribute.
    pub fn normalized<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.normalized = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `uniform_noise` attribute.
    pub fn uniform_noise<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.uniform_noise = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `noise` attribute.
    pub fn noise<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.noise = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExtractGlimpseV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        size: O1,
        offsets: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), size.into(), offsets.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        size: crate::Output,
        offsets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExtractGlimpseV2", |nd| {
            nd.add_input(input);
            nd.add_input(size);
            nd.add_input(offsets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.centered {
                nd.set_attr_bool("centered", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.normalized {
                nd.set_attr_bool("normalized", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.uniform_noise {
                nd.set_attr_bool("uniform_noise", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.noise {
                nd.set_attr_string("noise", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExtractGlimpseV2::new().build(input, size, offsets, scope)`.
pub fn extract_glimpse_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    size: O1,
    offsets: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExtractGlimpseV2::new().build(input, size, offsets, scope)
}
/// Builder for the `ExtractImagePatches` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractImagePatches {
    ksizes: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    rates: ::std::option::Option<::std::vec::Vec<i64>>,
    T: ::std::option::Option<crate::DataType>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExtractImagePatches {
    /// Creates a new `ExtractImagePatches`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksizes` attribute.
    pub fn ksizes<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksizes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rates` attribute.
    pub fn rates<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rates = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExtractImagePatches` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        images: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExtractImagePatches", |nd| {
            nd.add_input(images);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksizes {
                nd.set_attr_int_list("ksizes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rates {
                nd.set_attr_int_list("rates", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExtractImagePatches::new().build(images, scope)`.
pub fn extract_image_patches<O0: ::std::convert::Into<crate::Output>>(
    images: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExtractImagePatches::new().build(images, scope)
}
/// Builder for the `ExtractJpegShape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractJpegShape {
    output_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExtractJpegShape {
    /// Creates a new `ExtractJpegShape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_type` attribute.
    pub fn output_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExtractJpegShape` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        contents: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(contents.into(), scope)
    }

    fn build_impl(
        &self,
        contents: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExtractJpegShape", |nd| {
            nd.add_input(contents);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_type {
                nd.set_attr_type("output_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExtractJpegShape::new().build(contents, scope)`.
pub fn extract_jpeg_shape<O0: ::std::convert::Into<crate::Output>>(
    contents: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExtractJpegShape::new().build(contents, scope)
}
/// Builder for the `ExtractVolumePatches` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ExtractVolumePatches {
    ksizes: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    T: ::std::option::Option<crate::DataType>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ExtractVolumePatches {
    /// Creates a new `ExtractVolumePatches`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksizes` attribute.
    pub fn ksizes<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksizes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ExtractVolumePatches` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ExtractVolumePatches", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksizes {
                nd.set_attr_int_list("ksizes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ExtractVolumePatches::new().build(input, scope)`.
pub fn extract_volume_patches<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ExtractVolumePatches::new().build(input, scope)
}
/// Builder for the `FFT` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FFT {
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FFT {
    /// Creates a new `FFT`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FFT` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FFT", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FFT::new().build(input, scope)`.
pub fn fft<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FFT::new().build(input, scope)
}
/// Builder for the `FFT2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FFT2D {
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FFT2D {
    /// Creates a new `FFT2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FFT2D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FFT2D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FFT2D::new().build(input, scope)`.
pub fn fft2_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FFT2D::new().build(input, scope)
}
/// Builder for the `FFT3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FFT3D {
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FFT3D {
    /// Creates a new `FFT3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FFT3D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FFT3D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FFT3D::new().build(input, scope)`.
pub fn fft3_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FFT3D::new().build(input, scope)
}
/// Builder for the `FIFOQueue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FIFOQueue {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FIFOQueue {
    /// Creates a new `FIFOQueue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FIFOQueue` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("FIFOQueue", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FIFOQueue::new().build(scope)`.
pub fn fifoqueue(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    FIFOQueue::new().build(scope)
}
/// Builder for the `FIFOQueueV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FIFOQueueV2 {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FIFOQueueV2 {
    /// Creates a new `FIFOQueueV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FIFOQueueV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("FIFOQueueV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FIFOQueueV2::new().build(scope)`.
pub fn fifoqueue_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    FIFOQueueV2::new().build(scope)
}
/// Builder for the `Fact` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Fact {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Fact {
    /// Creates a new `Fact`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Fact` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Fact", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Fact::new().build(scope)`.
pub fn fact(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Fact::new().build(scope)
}
/// Builder for the `FakeParam` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeParam {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FakeParam {
    /// Creates a new `FakeParam`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FakeParam` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("FakeParam", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FakeParam::new().build(scope)`.
pub fn fake_param(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    FakeParam::new().build(scope)
}
/// Builder for the `FakeQuantWithMinMaxArgs` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxArgs {
    min: ::std::option::Option<f32>,
    max: ::std::option::Option<f32>,
    num_bits: ::std::option::Option<i64>,
    narrow_range: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FakeQuantWithMinMaxArgs {
    /// Creates a new `FakeQuantWithMinMaxArgs`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `min` attribute.
    pub fn min<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.min = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max` attribute.
    pub fn max<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_bits` attribute.
    pub fn num_bits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_bits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FakeQuantWithMinMaxArgs` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FakeQuantWithMinMaxArgs", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.min {
                nd.set_attr_float("min", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max {
                nd.set_attr_float("max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_bits {
                nd.set_attr_int("num_bits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FakeQuantWithMinMaxArgs::new().build(inputs, scope)`.
pub fn fake_quant_with_min_max_args<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FakeQuantWithMinMaxArgs::new().build(inputs, scope)
}
/// Builder for the `FakeQuantWithMinMaxArgsGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxArgsGradient {
    min: ::std::option::Option<f32>,
    max: ::std::option::Option<f32>,
    num_bits: ::std::option::Option<i64>,
    narrow_range: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FakeQuantWithMinMaxArgsGradient {
    /// Creates a new `FakeQuantWithMinMaxArgsGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `min` attribute.
    pub fn min<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.min = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max` attribute.
    pub fn max<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_bits` attribute.
    pub fn num_bits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_bits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FakeQuantWithMinMaxArgsGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        inputs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(gradients.into(), inputs.into(), scope)
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FakeQuantWithMinMaxArgsGradient", |nd| {
            nd.add_input(gradients);
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.min {
                nd.set_attr_float("min", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max {
                nd.set_attr_float("max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_bits {
                nd.set_attr_int("num_bits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FakeQuantWithMinMaxArgsGradient::new().build(gradients, inputs, scope)`.
pub fn fake_quant_with_min_max_args_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    inputs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FakeQuantWithMinMaxArgsGradient::new().build(gradients, inputs, scope)
}
/// Builder for the `FakeQuantWithMinMaxVars` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxVars {
    num_bits: ::std::option::Option<i64>,
    narrow_range: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FakeQuantWithMinMaxVars {
    /// Creates a new `FakeQuantWithMinMaxVars`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_bits` attribute.
    pub fn num_bits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_bits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FakeQuantWithMinMaxVars` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        min: O1,
        max: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), min.into(), max.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        min: crate::Output,
        max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FakeQuantWithMinMaxVars", |nd| {
            nd.add_input(inputs);
            nd.add_input(min);
            nd.add_input(max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_bits {
                nd.set_attr_int("num_bits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FakeQuantWithMinMaxVars::new().build(inputs, min, max, scope)`.
pub fn fake_quant_with_min_max_vars<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    min: O1,
    max: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FakeQuantWithMinMaxVars::new().build(inputs, min, max, scope)
}
/// Builder for the `FakeQuantWithMinMaxVarsGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxVarsGradient {
    num_bits: ::std::option::Option<i64>,
    narrow_range: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FakeQuantWithMinMaxVarsGradient {
    /// Creates a new `FakeQuantWithMinMaxVarsGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_bits` attribute.
    pub fn num_bits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_bits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FakeQuantWithMinMaxVarsGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        inputs: O1,
        min: O2,
        max: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            gradients.into(),
            inputs.into(),
            min.into(),
            max.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        inputs: crate::Output,
        min: crate::Output,
        max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FakeQuantWithMinMaxVarsGradient", |nd| {
            nd.add_input(gradients);
            nd.add_input(inputs);
            nd.add_input(min);
            nd.add_input(max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_bits {
                nd.set_attr_int("num_bits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FakeQuantWithMinMaxVarsGradient::new().build(gradients, inputs, min, max, scope)`.
pub fn fake_quant_with_min_max_vars_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    inputs: O1,
    min: O2,
    max: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FakeQuantWithMinMaxVarsGradient::new().build(gradients, inputs, min, max, scope)
}
/// Builder for the `FakeQuantWithMinMaxVarsPerChannel` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxVarsPerChannel {
    num_bits: ::std::option::Option<i64>,
    narrow_range: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FakeQuantWithMinMaxVarsPerChannel {
    /// Creates a new `FakeQuantWithMinMaxVarsPerChannel`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_bits` attribute.
    pub fn num_bits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_bits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FakeQuantWithMinMaxVarsPerChannel` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        min: O1,
        max: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), min.into(), max.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        min: crate::Output,
        max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FakeQuantWithMinMaxVarsPerChannel", |nd| {
            nd.add_input(inputs);
            nd.add_input(min);
            nd.add_input(max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_bits {
                nd.set_attr_int("num_bits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FakeQuantWithMinMaxVarsPerChannel::new().build(inputs, min, max, scope)`.
pub fn fake_quant_with_min_max_vars_per_channel<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    min: O1,
    max: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FakeQuantWithMinMaxVarsPerChannel::new().build(inputs, min, max, scope)
}
/// Builder for the `FakeQuantWithMinMaxVarsPerChannelGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQuantWithMinMaxVarsPerChannelGradient {
    num_bits: ::std::option::Option<i64>,
    narrow_range: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FakeQuantWithMinMaxVarsPerChannelGradient {
    /// Creates a new `FakeQuantWithMinMaxVarsPerChannelGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_bits` attribute.
    pub fn num_bits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_bits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FakeQuantWithMinMaxVarsPerChannelGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        inputs: O1,
        min: O2,
        max: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            gradients.into(),
            inputs.into(),
            min.into(),
            max.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        inputs: crate::Output,
        min: crate::Output,
        max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FakeQuantWithMinMaxVarsPerChannelGradient", |nd| {
            nd.add_input(gradients);
            nd.add_input(inputs);
            nd.add_input(min);
            nd.add_input(max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_bits {
                nd.set_attr_int("num_bits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FakeQuantWithMinMaxVarsPerChannelGradient::new().build(gradients, inputs, min, max, scope)`.
pub fn fake_quant_with_min_max_vars_per_channel_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    inputs: O1,
    min: O2,
    max: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FakeQuantWithMinMaxVarsPerChannelGradient::new().build(gradients, inputs, min, max, scope)
}
/// Builder for the `FakeQueue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FakeQueue {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FakeQueue {
    /// Creates a new `FakeQueue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FakeQueue` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FakeQueue", |nd| {
            nd.add_input(resource);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FakeQueue::new().build(resource, scope)`.
pub fn fake_queue<O0: ::std::convert::Into<crate::Output>>(
    resource: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FakeQueue::new().build(resource, scope)
}
/// Builder for the `Fill` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Fill {
    T: ::std::option::Option<crate::DataType>,
    index_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Fill {
    /// Creates a new `Fill`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `index_type` attribute.
    pub fn index_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.index_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Fill` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        dims: O0,
        value: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(dims.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        dims: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Fill", |nd| {
            nd.add_input(dims);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.index_type {
                nd.set_attr_type("index_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Fill::new().build(dims, value, scope)`.
pub fn fill<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    dims: O0,
    value: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Fill::new().build(dims, value, scope)
}
/// Builder for the `FilterByLastComponentDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FilterByLastComponentDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FilterByLastComponentDataset {
    /// Creates a new `FilterByLastComponentDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FilterByLastComponentDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FilterByLastComponentDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FilterByLastComponentDataset::new().build(input_dataset, scope)`.
pub fn filter_by_last_component_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FilterByLastComponentDataset::new().build(input_dataset, scope)
}
/// Builder for the `FilterDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FilterDataset {
    predicate: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FilterDataset {
    /// Creates a new `FilterDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `predicate` attribute.
    pub fn predicate<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.predicate = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FilterDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), other_arguments.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FilterDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.predicate {
                nd.set_attr_string("predicate", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FilterDataset::new().build(input_dataset, other_arguments, scope)`.
pub fn filter_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FilterDataset::new().build(input_dataset, other_arguments, scope)
}
/// Builder for the `Fingerprint` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Fingerprint {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Fingerprint {
    /// Creates a new `Fingerprint`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Fingerprint` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        method: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), method.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        method: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Fingerprint", |nd| {
            nd.add_input(data);
            nd.add_input(method);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Fingerprint::new().build(data, method, scope)`.
pub fn fingerprint<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    method: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Fingerprint::new().build(data, method, scope)
}
/// Builder for the `FixedLengthRecordDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedLengthRecordDataset {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FixedLengthRecordDataset {
    /// Creates a new `FixedLengthRecordDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FixedLengthRecordDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filenames: O0,
        header_bytes: O1,
        record_bytes: O2,
        footer_bytes: O3,
        buffer_size: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            filenames.into(),
            header_bytes.into(),
            record_bytes.into(),
            footer_bytes.into(),
            buffer_size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        filenames: crate::Output,
        header_bytes: crate::Output,
        record_bytes: crate::Output,
        footer_bytes: crate::Output,
        buffer_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FixedLengthRecordDataset", |nd| {
            nd.add_input(filenames);
            nd.add_input(header_bytes);
            nd.add_input(record_bytes);
            nd.add_input(footer_bytes);
            nd.add_input(buffer_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FixedLengthRecordDataset::new().build(filenames, header_bytes, record_bytes, footer_bytes, buffer_size, scope)`.
pub fn fixed_length_record_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    filenames: O0,
    header_bytes: O1,
    record_bytes: O2,
    footer_bytes: O3,
    buffer_size: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FixedLengthRecordDataset::new().build(
        filenames,
        header_bytes,
        record_bytes,
        footer_bytes,
        buffer_size,
        scope,
    )
}
/// Builder for the `FixedLengthRecordDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedLengthRecordDatasetV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FixedLengthRecordDatasetV2 {
    /// Creates a new `FixedLengthRecordDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FixedLengthRecordDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filenames: O0,
        header_bytes: O1,
        record_bytes: O2,
        footer_bytes: O3,
        buffer_size: O4,
        compression_type: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            filenames.into(),
            header_bytes.into(),
            record_bytes.into(),
            footer_bytes.into(),
            buffer_size.into(),
            compression_type.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        filenames: crate::Output,
        header_bytes: crate::Output,
        record_bytes: crate::Output,
        footer_bytes: crate::Output,
        buffer_size: crate::Output,
        compression_type: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FixedLengthRecordDatasetV2", |nd| {
            nd.add_input(filenames);
            nd.add_input(header_bytes);
            nd.add_input(record_bytes);
            nd.add_input(footer_bytes);
            nd.add_input(buffer_size);
            nd.add_input(compression_type);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FixedLengthRecordDatasetV2::new().build(filenames, header_bytes, record_bytes, footer_bytes, buffer_size, compression_type, scope)`.
pub fn fixed_length_record_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    filenames: O0,
    header_bytes: O1,
    record_bytes: O2,
    footer_bytes: O3,
    buffer_size: O4,
    compression_type: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FixedLengthRecordDatasetV2::new().build(
        filenames,
        header_bytes,
        record_bytes,
        footer_bytes,
        buffer_size,
        compression_type,
        scope,
    )
}
/// Builder for the `FixedLengthRecordReader` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedLengthRecordReader {
    header_bytes: ::std::option::Option<i64>,
    record_bytes: ::std::option::Option<i64>,
    footer_bytes: ::std::option::Option<i64>,
    hop_bytes: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FixedLengthRecordReader {
    /// Creates a new `FixedLengthRecordReader`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `header_bytes` attribute.
    pub fn header_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.header_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `record_bytes` attribute.
    pub fn record_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.record_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `footer_bytes` attribute.
    pub fn footer_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.footer_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `hop_bytes` attribute.
    pub fn hop_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.hop_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FixedLengthRecordReader` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("FixedLengthRecordReader", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.header_bytes {
                nd.set_attr_int("header_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.record_bytes {
                nd.set_attr_int("record_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.footer_bytes {
                nd.set_attr_int("footer_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.hop_bytes {
                nd.set_attr_int("hop_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FixedLengthRecordReader::new().build(scope)`.
pub fn fixed_length_record_reader(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    FixedLengthRecordReader::new().build(scope)
}
/// Builder for the `FixedLengthRecordReaderV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedLengthRecordReaderV2 {
    header_bytes: ::std::option::Option<i64>,
    record_bytes: ::std::option::Option<i64>,
    footer_bytes: ::std::option::Option<i64>,
    hop_bytes: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    encoding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FixedLengthRecordReaderV2 {
    /// Creates a new `FixedLengthRecordReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `header_bytes` attribute.
    pub fn header_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.header_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `record_bytes` attribute.
    pub fn record_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.record_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `footer_bytes` attribute.
    pub fn footer_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.footer_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `hop_bytes` attribute.
    pub fn hop_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.hop_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `encoding` attribute.
    pub fn encoding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.encoding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FixedLengthRecordReaderV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("FixedLengthRecordReaderV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.header_bytes {
                nd.set_attr_int("header_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.record_bytes {
                nd.set_attr_int("record_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.footer_bytes {
                nd.set_attr_int("footer_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.hop_bytes {
                nd.set_attr_int("hop_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.encoding {
                nd.set_attr_string("encoding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FixedLengthRecordReaderV2::new().build(scope)`.
pub fn fixed_length_record_reader_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    FixedLengthRecordReaderV2::new().build(scope)
}
/// Builder for the `FixedUnigramCandidateSampler` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FixedUnigramCandidateSampler {
    num_true: ::std::option::Option<i64>,
    num_sampled: ::std::option::Option<i64>,
    unique: ::std::option::Option<bool>,
    range_max: ::std::option::Option<i64>,
    vocab_file: ::std::option::Option<::std::string::String>,
    distortion: ::std::option::Option<f32>,
    num_reserved_ids: ::std::option::Option<i64>,
    num_shards: ::std::option::Option<i64>,
    shard: ::std::option::Option<i64>,
    unigrams: ::std::option::Option<::std::vec::Vec<f32>>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FixedUnigramCandidateSampler {
    /// Creates a new `FixedUnigramCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_true` attribute.
    pub fn num_true<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_true = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sampled` attribute.
    pub fn num_sampled<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_sampled = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `unique` attribute.
    pub fn unique<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.unique = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `range_max` attribute.
    pub fn range_max<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.range_max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `vocab_file` attribute.
    pub fn vocab_file<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.vocab_file = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `distortion` attribute.
    pub fn distortion<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.distortion = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_reserved_ids` attribute.
    pub fn num_reserved_ids<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_reserved_ids = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard` attribute.
    pub fn shard<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `unigrams` attribute.
    pub fn unigrams<ArgType: ::std::convert::Into<::std::vec::Vec<f32>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.unigrams = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FixedUnigramCandidateSampler` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        true_classes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(true_classes.into(), scope)
    }

    fn build_impl(
        &self,
        true_classes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FixedUnigramCandidateSampler", |nd| {
            nd.add_input(true_classes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_true {
                nd.set_attr_int("num_true", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sampled {
                nd.set_attr_int("num_sampled", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.unique {
                nd.set_attr_bool("unique", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.range_max {
                nd.set_attr_int("range_max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.vocab_file {
                nd.set_attr_string("vocab_file", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.distortion {
                nd.set_attr_float("distortion", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_reserved_ids {
                nd.set_attr_int("num_reserved_ids", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard {
                nd.set_attr_int("shard", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.unigrams {
                nd.set_attr_float_list("unigrams", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FixedUnigramCandidateSampler::new().build(true_classes, scope)`.
pub fn fixed_unigram_candidate_sampler<O0: ::std::convert::Into<crate::Output>>(
    true_classes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FixedUnigramCandidateSampler::new().build(true_classes, scope)
}
/// Builder for the `FlatMapDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FlatMapDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FlatMapDataset {
    /// Creates a new `FlatMapDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FlatMapDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), other_arguments.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FlatMapDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FlatMapDataset::new().build(input_dataset, other_arguments, scope)`.
pub fn flat_map_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FlatMapDataset::new().build(input_dataset, other_arguments, scope)
}
/// Builder for the `Floor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Floor {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Floor {
    /// Creates a new `Floor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Floor` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Floor", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Floor::new().build(x, scope)`.
pub fn floor<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Floor::new().build(x, scope)
}
/// Builder for the `FloorDiv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FloorDiv {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FloorDiv {
    /// Creates a new `FloorDiv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FloorDiv` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FloorDiv", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FloorDiv::new().build(x, y, scope)`.
pub fn floor_div<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FloorDiv::new().build(x, y, scope)
}
/// Builder for the `FloorMod` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FloorMod {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FloorMod {
    /// Creates a new `FloorMod`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FloorMod` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FloorMod", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FloorMod::new().build(x, y, scope)`.
pub fn floor_mod<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FloorMod::new().build(x, y, scope)
}
/// Builder for the `FlushSummaryWriter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FlushSummaryWriter {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FlushSummaryWriter {
    /// Creates a new `FlushSummaryWriter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FlushSummaryWriter` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        writer: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(writer.into(), scope)
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FlushSummaryWriter", |nd| {
            nd.add_input(writer);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FlushSummaryWriter::new().build(writer, scope)`.
pub fn flush_summary_writer<O0: ::std::convert::Into<crate::Output>>(
    writer: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FlushSummaryWriter::new().build(writer, scope)
}
/// Builder for the `For` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct For {
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    body: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl For {
    /// Creates a new `For`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `body` attribute.
    pub fn body<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.body = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `For` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        start: O0,
        limit: O1,
        delta: O2,
        input: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            start.into(),
            limit.into(),
            delta.into(),
            input.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        start: crate::Output,
        limit: crate::Output,
        delta: crate::Output,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("For", |nd| {
            nd.add_input(start);
            nd.add_input(limit);
            nd.add_input(delta);
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.body {
                nd.set_attr_string("body", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `For::new().build(start, limit, delta, input, scope)`.
pub fn for_<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    start: O0,
    limit: O1,
    delta: O2,
    input: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    For::new().build(start, limit, delta, input, scope)
}
/// Builder for the `FractionalAvgPool` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FractionalAvgPool {
    pooling_ratio: ::std::option::Option<::std::vec::Vec<f32>>,
    pseudo_random: ::std::option::Option<bool>,
    overlapping: ::std::option::Option<bool>,
    deterministic: ::std::option::Option<bool>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FractionalAvgPool {
    /// Creates a new `FractionalAvgPool`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `pooling_ratio` attribute.
    pub fn pooling_ratio<ArgType: ::std::convert::Into<::std::vec::Vec<f32>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.pooling_ratio = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `pseudo_random` attribute.
    pub fn pseudo_random<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.pseudo_random = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `overlapping` attribute.
    pub fn overlapping<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.overlapping = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `deterministic` attribute.
    pub fn deterministic<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.deterministic = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FractionalAvgPool` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        value: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FractionalAvgPool", |nd| {
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.pooling_ratio {
                nd.set_attr_float_list("pooling_ratio", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.pseudo_random {
                nd.set_attr_bool("pseudo_random", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.overlapping {
                nd.set_attr_bool("overlapping", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.deterministic {
                nd.set_attr_bool("deterministic", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FractionalAvgPool::new().build(value, scope)`.
pub fn fractional_avg_pool<O0: ::std::convert::Into<crate::Output>>(
    value: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FractionalAvgPool::new().build(value, scope)
}
/// Builder for the `FractionalAvgPoolGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FractionalAvgPoolGrad {
    overlapping: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FractionalAvgPoolGrad {
    /// Creates a new `FractionalAvgPoolGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `overlapping` attribute.
    pub fn overlapping<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.overlapping = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FractionalAvgPoolGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input_tensor_shape: O0,
        out_backprop: O1,
        row_pooling_sequence: O2,
        col_pooling_sequence: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            orig_input_tensor_shape.into(),
            out_backprop.into(),
            row_pooling_sequence.into(),
            col_pooling_sequence.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        orig_input_tensor_shape: crate::Output,
        out_backprop: crate::Output,
        row_pooling_sequence: crate::Output,
        col_pooling_sequence: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FractionalAvgPoolGrad", |nd| {
            nd.add_input(orig_input_tensor_shape);
            nd.add_input(out_backprop);
            nd.add_input(row_pooling_sequence);
            nd.add_input(col_pooling_sequence);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.overlapping {
                nd.set_attr_bool("overlapping", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FractionalAvgPoolGrad::new().build(orig_input_tensor_shape, out_backprop, row_pooling_sequence, col_pooling_sequence, scope)`.
pub fn fractional_avg_pool_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    orig_input_tensor_shape: O0,
    out_backprop: O1,
    row_pooling_sequence: O2,
    col_pooling_sequence: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FractionalAvgPoolGrad::new().build(
        orig_input_tensor_shape,
        out_backprop,
        row_pooling_sequence,
        col_pooling_sequence,
        scope,
    )
}
/// Builder for the `FractionalMaxPool` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FractionalMaxPool {
    pooling_ratio: ::std::option::Option<::std::vec::Vec<f32>>,
    pseudo_random: ::std::option::Option<bool>,
    overlapping: ::std::option::Option<bool>,
    deterministic: ::std::option::Option<bool>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FractionalMaxPool {
    /// Creates a new `FractionalMaxPool`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `pooling_ratio` attribute.
    pub fn pooling_ratio<ArgType: ::std::convert::Into<::std::vec::Vec<f32>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.pooling_ratio = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `pseudo_random` attribute.
    pub fn pseudo_random<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.pseudo_random = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `overlapping` attribute.
    pub fn overlapping<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.overlapping = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `deterministic` attribute.
    pub fn deterministic<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.deterministic = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FractionalMaxPool` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        value: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FractionalMaxPool", |nd| {
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.pooling_ratio {
                nd.set_attr_float_list("pooling_ratio", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.pseudo_random {
                nd.set_attr_bool("pseudo_random", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.overlapping {
                nd.set_attr_bool("overlapping", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.deterministic {
                nd.set_attr_bool("deterministic", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FractionalMaxPool::new().build(value, scope)`.
pub fn fractional_max_pool<O0: ::std::convert::Into<crate::Output>>(
    value: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FractionalMaxPool::new().build(value, scope)
}
/// Builder for the `FractionalMaxPoolGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FractionalMaxPoolGrad {
    overlapping: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FractionalMaxPoolGrad {
    /// Creates a new `FractionalMaxPoolGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `overlapping` attribute.
    pub fn overlapping<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.overlapping = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FractionalMaxPoolGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input: O0,
        orig_output: O1,
        out_backprop: O2,
        row_pooling_sequence: O3,
        col_pooling_sequence: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            orig_input.into(),
            orig_output.into(),
            out_backprop.into(),
            row_pooling_sequence.into(),
            col_pooling_sequence.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        orig_input: crate::Output,
        orig_output: crate::Output,
        out_backprop: crate::Output,
        row_pooling_sequence: crate::Output,
        col_pooling_sequence: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FractionalMaxPoolGrad", |nd| {
            nd.add_input(orig_input);
            nd.add_input(orig_output);
            nd.add_input(out_backprop);
            nd.add_input(row_pooling_sequence);
            nd.add_input(col_pooling_sequence);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.overlapping {
                nd.set_attr_bool("overlapping", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FractionalMaxPoolGrad::new().build(orig_input, orig_output, out_backprop, row_pooling_sequence, col_pooling_sequence, scope)`.
pub fn fractional_max_pool_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    orig_input: O0,
    orig_output: O1,
    out_backprop: O2,
    row_pooling_sequence: O3,
    col_pooling_sequence: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FractionalMaxPoolGrad::new().build(
        orig_input,
        orig_output,
        out_backprop,
        row_pooling_sequence,
        col_pooling_sequence,
        scope,
    )
}
/// Builder for the `FresnelCos` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FresnelCos {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FresnelCos {
    /// Creates a new `FresnelCos`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FresnelCos` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FresnelCos", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FresnelCos::new().build(x, scope)`.
pub fn fresnel_cos<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FresnelCos::new().build(x, scope)
}
/// Builder for the `FresnelSin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FresnelSin {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FresnelSin {
    /// Creates a new `FresnelSin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FresnelSin` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FresnelSin", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FresnelSin::new().build(x, scope)`.
pub fn fresnel_sin<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FresnelSin::new().build(x, scope)
}
/// Builder for the `FusedBatchNorm` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNorm {
    T: ::std::option::Option<crate::DataType>,
    epsilon: ::std::option::Option<f32>,
    exponential_avg_factor: ::std::option::Option<f32>,
    data_format: ::std::option::Option<::std::string::String>,
    is_training: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FusedBatchNorm {
    /// Creates a new `FusedBatchNorm`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `epsilon` attribute.
    pub fn epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `exponential_avg_factor` attribute.
    pub fn exponential_avg_factor<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.exponential_avg_factor = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FusedBatchNorm` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        scale: O1,
        offset: O2,
        mean: O3,
        variance: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            scale.into(),
            offset.into(),
            mean.into(),
            variance.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scale: crate::Output,
        offset: crate::Output,
        mean: crate::Output,
        variance: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FusedBatchNorm", |nd| {
            nd.add_input(x);
            nd.add_input(scale);
            nd.add_input(offset);
            nd.add_input(mean);
            nd.add_input(variance);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.epsilon {
                nd.set_attr_float("epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.exponential_avg_factor {
                nd.set_attr_float("exponential_avg_factor", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FusedBatchNorm::new().build(x, scale, offset, mean, variance, scope)`.
pub fn fused_batch_norm<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    scale: O1,
    offset: O2,
    mean: O3,
    variance: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FusedBatchNorm::new().build(x, scale, offset, mean, variance, scope)
}
/// Builder for the `FusedBatchNormGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormGrad {
    T: ::std::option::Option<crate::DataType>,
    epsilon: ::std::option::Option<f32>,
    data_format: ::std::option::Option<::std::string::String>,
    is_training: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FusedBatchNormGrad {
    /// Creates a new `FusedBatchNormGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `epsilon` attribute.
    pub fn epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FusedBatchNormGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y_backprop: O0,
        x: O1,
        scale: O2,
        reserve_space_1: O3,
        reserve_space_2: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            y_backprop.into(),
            x.into(),
            scale.into(),
            reserve_space_1.into(),
            reserve_space_2.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        y_backprop: crate::Output,
        x: crate::Output,
        scale: crate::Output,
        reserve_space_1: crate::Output,
        reserve_space_2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FusedBatchNormGrad", |nd| {
            nd.add_input(y_backprop);
            nd.add_input(x);
            nd.add_input(scale);
            nd.add_input(reserve_space_1);
            nd.add_input(reserve_space_2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.epsilon {
                nd.set_attr_float("epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FusedBatchNormGrad::new().build(y_backprop, x, scale, reserve_space_1, reserve_space_2, scope)`.
pub fn fused_batch_norm_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    y_backprop: O0,
    x: O1,
    scale: O2,
    reserve_space_1: O3,
    reserve_space_2: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FusedBatchNormGrad::new().build(
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        scope,
    )
}
/// Builder for the `FusedBatchNormGradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormGradV2 {
    T: ::std::option::Option<crate::DataType>,
    U: ::std::option::Option<crate::DataType>,
    epsilon: ::std::option::Option<f32>,
    data_format: ::std::option::Option<::std::string::String>,
    is_training: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FusedBatchNormGradV2 {
    /// Creates a new `FusedBatchNormGradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `U` attribute.
    pub fn U<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.U = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `epsilon` attribute.
    pub fn epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FusedBatchNormGradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y_backprop: O0,
        x: O1,
        scale: O2,
        reserve_space_1: O3,
        reserve_space_2: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            y_backprop.into(),
            x.into(),
            scale.into(),
            reserve_space_1.into(),
            reserve_space_2.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        y_backprop: crate::Output,
        x: crate::Output,
        scale: crate::Output,
        reserve_space_1: crate::Output,
        reserve_space_2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FusedBatchNormGradV2", |nd| {
            nd.add_input(y_backprop);
            nd.add_input(x);
            nd.add_input(scale);
            nd.add_input(reserve_space_1);
            nd.add_input(reserve_space_2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.U {
                nd.set_attr_type("U", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.epsilon {
                nd.set_attr_float("epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FusedBatchNormGradV2::new().build(y_backprop, x, scale, reserve_space_1, reserve_space_2, scope)`.
pub fn fused_batch_norm_grad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    y_backprop: O0,
    x: O1,
    scale: O2,
    reserve_space_1: O3,
    reserve_space_2: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FusedBatchNormGradV2::new().build(
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        scope,
    )
}
/// Builder for the `FusedBatchNormGradV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormGradV3 {
    T: ::std::option::Option<crate::DataType>,
    U: ::std::option::Option<crate::DataType>,
    epsilon: ::std::option::Option<f32>,
    data_format: ::std::option::Option<::std::string::String>,
    is_training: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FusedBatchNormGradV3 {
    /// Creates a new `FusedBatchNormGradV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `U` attribute.
    pub fn U<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.U = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `epsilon` attribute.
    pub fn epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FusedBatchNormGradV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y_backprop: O0,
        x: O1,
        scale: O2,
        reserve_space_1: O3,
        reserve_space_2: O4,
        reserve_space_3: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            y_backprop.into(),
            x.into(),
            scale.into(),
            reserve_space_1.into(),
            reserve_space_2.into(),
            reserve_space_3.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        y_backprop: crate::Output,
        x: crate::Output,
        scale: crate::Output,
        reserve_space_1: crate::Output,
        reserve_space_2: crate::Output,
        reserve_space_3: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FusedBatchNormGradV3", |nd| {
            nd.add_input(y_backprop);
            nd.add_input(x);
            nd.add_input(scale);
            nd.add_input(reserve_space_1);
            nd.add_input(reserve_space_2);
            nd.add_input(reserve_space_3);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.U {
                nd.set_attr_type("U", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.epsilon {
                nd.set_attr_float("epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FusedBatchNormGradV3::new().build(y_backprop, x, scale, reserve_space_1, reserve_space_2, reserve_space_3, scope)`.
pub fn fused_batch_norm_grad_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    y_backprop: O0,
    x: O1,
    scale: O2,
    reserve_space_1: O3,
    reserve_space_2: O4,
    reserve_space_3: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FusedBatchNormGradV3::new().build(
        y_backprop,
        x,
        scale,
        reserve_space_1,
        reserve_space_2,
        reserve_space_3,
        scope,
    )
}
/// Builder for the `FusedBatchNormV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormV2 {
    T: ::std::option::Option<crate::DataType>,
    U: ::std::option::Option<crate::DataType>,
    epsilon: ::std::option::Option<f32>,
    exponential_avg_factor: ::std::option::Option<f32>,
    data_format: ::std::option::Option<::std::string::String>,
    is_training: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FusedBatchNormV2 {
    /// Creates a new `FusedBatchNormV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `U` attribute.
    pub fn U<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.U = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `epsilon` attribute.
    pub fn epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `exponential_avg_factor` attribute.
    pub fn exponential_avg_factor<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.exponential_avg_factor = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FusedBatchNormV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        scale: O1,
        offset: O2,
        mean: O3,
        variance: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            scale.into(),
            offset.into(),
            mean.into(),
            variance.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scale: crate::Output,
        offset: crate::Output,
        mean: crate::Output,
        variance: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FusedBatchNormV2", |nd| {
            nd.add_input(x);
            nd.add_input(scale);
            nd.add_input(offset);
            nd.add_input(mean);
            nd.add_input(variance);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.U {
                nd.set_attr_type("U", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.epsilon {
                nd.set_attr_float("epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.exponential_avg_factor {
                nd.set_attr_float("exponential_avg_factor", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FusedBatchNormV2::new().build(x, scale, offset, mean, variance, scope)`.
pub fn fused_batch_norm_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    scale: O1,
    offset: O2,
    mean: O3,
    variance: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FusedBatchNormV2::new().build(x, scale, offset, mean, variance, scope)
}
/// Builder for the `FusedBatchNormV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedBatchNormV3 {
    T: ::std::option::Option<crate::DataType>,
    U: ::std::option::Option<crate::DataType>,
    epsilon: ::std::option::Option<f32>,
    exponential_avg_factor: ::std::option::Option<f32>,
    data_format: ::std::option::Option<::std::string::String>,
    is_training: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FusedBatchNormV3 {
    /// Creates a new `FusedBatchNormV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `U` attribute.
    pub fn U<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.U = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `epsilon` attribute.
    pub fn epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `exponential_avg_factor` attribute.
    pub fn exponential_avg_factor<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.exponential_avg_factor = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_training` attribute.
    pub fn is_training<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_training = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FusedBatchNormV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        scale: O1,
        offset: O2,
        mean: O3,
        variance: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            scale.into(),
            offset.into(),
            mean.into(),
            variance.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scale: crate::Output,
        offset: crate::Output,
        mean: crate::Output,
        variance: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FusedBatchNormV3", |nd| {
            nd.add_input(x);
            nd.add_input(scale);
            nd.add_input(offset);
            nd.add_input(mean);
            nd.add_input(variance);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.U {
                nd.set_attr_type("U", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.epsilon {
                nd.set_attr_float("epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.exponential_avg_factor {
                nd.set_attr_float("exponential_avg_factor", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_training {
                nd.set_attr_bool("is_training", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FusedBatchNormV3::new().build(x, scale, offset, mean, variance, scope)`.
pub fn fused_batch_norm_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    scale: O1,
    offset: O2,
    mean: O3,
    variance: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FusedBatchNormV3::new().build(x, scale, offset, mean, variance, scope)
}
/// Builder for the `FusedPadConv2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedPadConv2D {
    T: ::std::option::Option<crate::DataType>,
    mode: ::std::option::Option<::std::string::String>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FusedPadConv2D {
    /// Creates a new `FusedPadConv2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `mode` attribute.
    pub fn mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FusedPadConv2D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        paddings: O1,
        filter: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), paddings.into(), filter.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        paddings: crate::Output,
        filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FusedPadConv2D", |nd| {
            nd.add_input(input);
            nd.add_input(paddings);
            nd.add_input(filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.mode {
                nd.set_attr_string("mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FusedPadConv2D::new().build(input, paddings, filter, scope)`.
pub fn fused_pad_conv2_d<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    paddings: O1,
    filter: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FusedPadConv2D::new().build(input, paddings, filter, scope)
}
/// Builder for the `FusedResizeAndPadConv2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct FusedResizeAndPadConv2D {
    T: ::std::option::Option<crate::DataType>,
    resize_align_corners: ::std::option::Option<bool>,
    mode: ::std::option::Option<::std::string::String>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl FusedResizeAndPadConv2D {
    /// Creates a new `FusedResizeAndPadConv2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `resize_align_corners` attribute.
    pub fn resize_align_corners<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.resize_align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `mode` attribute.
    pub fn mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `FusedResizeAndPadConv2D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        size: O1,
        paddings: O2,
        filter: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            size.into(),
            paddings.into(),
            filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        size: crate::Output,
        paddings: crate::Output,
        filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("FusedResizeAndPadConv2D", |nd| {
            nd.add_input(input);
            nd.add_input(size);
            nd.add_input(paddings);
            nd.add_input(filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.resize_align_corners {
                nd.set_attr_bool("resize_align_corners", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.mode {
                nd.set_attr_string("mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `FusedResizeAndPadConv2D::new().build(input, size, paddings, filter, scope)`.
pub fn fused_resize_and_pad_conv2_d<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    size: O1,
    paddings: O2,
    filter: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    FusedResizeAndPadConv2D::new().build(input, size, paddings, filter, scope)
}
/// Builder for the `GRUBlockCell` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GRUBlockCell {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GRUBlockCell {
    /// Creates a new `GRUBlockCell`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GRUBlockCell` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        h_prev: O1,
        w_ru: O2,
        w_c: O3,
        b_ru: O4,
        b_c: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            h_prev.into(),
            w_ru.into(),
            w_c.into(),
            b_ru.into(),
            b_c.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        h_prev: crate::Output,
        w_ru: crate::Output,
        w_c: crate::Output,
        b_ru: crate::Output,
        b_c: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GRUBlockCell", |nd| {
            nd.add_input(x);
            nd.add_input(h_prev);
            nd.add_input(w_ru);
            nd.add_input(w_c);
            nd.add_input(b_ru);
            nd.add_input(b_c);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GRUBlockCell::new().build(x, h_prev, w_ru, w_c, b_ru, b_c, scope)`.
pub fn grublock_cell<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    h_prev: O1,
    w_ru: O2,
    w_c: O3,
    b_ru: O4,
    b_c: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GRUBlockCell::new().build(x, h_prev, w_ru, w_c, b_ru, b_c, scope)
}
/// Builder for the `GRUBlockCellGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GRUBlockCellGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GRUBlockCellGrad {
    /// Creates a new `GRUBlockCellGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GRUBlockCellGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        h_prev: O1,
        w_ru: O2,
        w_c: O3,
        b_ru: O4,
        b_c: O5,
        r: O6,
        u: O7,
        c: O8,
        d_h: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            h_prev.into(),
            w_ru.into(),
            w_c.into(),
            b_ru.into(),
            b_c.into(),
            r.into(),
            u.into(),
            c.into(),
            d_h.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        h_prev: crate::Output,
        w_ru: crate::Output,
        w_c: crate::Output,
        b_ru: crate::Output,
        b_c: crate::Output,
        r: crate::Output,
        u: crate::Output,
        c: crate::Output,
        d_h: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GRUBlockCellGrad", |nd| {
            nd.add_input(x);
            nd.add_input(h_prev);
            nd.add_input(w_ru);
            nd.add_input(w_c);
            nd.add_input(b_ru);
            nd.add_input(b_c);
            nd.add_input(r);
            nd.add_input(u);
            nd.add_input(c);
            nd.add_input(d_h);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GRUBlockCellGrad::new().build(x, h_prev, w_ru, w_c, b_ru, b_c, r, u, c, d_h, scope)`.
pub fn grublock_cell_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    h_prev: O1,
    w_ru: O2,
    w_c: O3,
    b_ru: O4,
    b_c: O5,
    r: O6,
    u: O7,
    c: O8,
    d_h: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GRUBlockCellGrad::new().build(x, h_prev, w_ru, w_c, b_ru, b_c, r, u, c, d_h, scope)
}
/// Builder for the `Gather` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Gather {
    validate_indices: ::std::option::Option<bool>,
    Tparams: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Gather {
    /// Creates a new `Gather`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `validate_indices` attribute.
    pub fn validate_indices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.validate_indices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tparams` attribute.
    pub fn Tparams<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tparams = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Gather` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        params: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(params.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        params: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Gather", |nd| {
            nd.add_input(params);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.validate_indices {
                nd.set_attr_bool("validate_indices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tparams {
                nd.set_attr_type("Tparams", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Gather::new().build(params, indices, scope)`.
pub fn gather<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    params: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Gather::new().build(params, indices, scope)
}
/// Builder for the `GatherNd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GatherNd {
    Tparams: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GatherNd {
    /// Creates a new `GatherNd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tparams` attribute.
    pub fn Tparams<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tparams = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GatherNd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        params: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(params.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        params: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GatherNd", |nd| {
            nd.add_input(params);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tparams {
                nd.set_attr_type("Tparams", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GatherNd::new().build(params, indices, scope)`.
pub fn gather_nd<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    params: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GatherNd::new().build(params, indices, scope)
}
/// Builder for the `GatherV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GatherV2 {
    batch_dims: ::std::option::Option<i64>,
    Tparams: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    Taxis: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GatherV2 {
    /// Creates a new `GatherV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `batch_dims` attribute.
    pub fn batch_dims<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.batch_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tparams` attribute.
    pub fn Tparams<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tparams = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Taxis` attribute.
    pub fn Taxis<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Taxis = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GatherV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        params: O0,
        indices: O1,
        axis: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(params.into(), indices.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        params: crate::Output,
        indices: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GatherV2", |nd| {
            nd.add_input(params);
            nd.add_input(indices);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.batch_dims {
                nd.set_attr_int("batch_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tparams {
                nd.set_attr_type("Tparams", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Taxis {
                nd.set_attr_type("Taxis", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GatherV2::new().build(params, indices, axis, scope)`.
pub fn gather_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    params: O0,
    indices: O1,
    axis: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GatherV2::new().build(params, indices, axis, scope)
}
/// Builder for the `GenerateBoundingBoxProposals` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GenerateBoundingBoxProposals {
    post_nms_topn: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GenerateBoundingBoxProposals {
    /// Creates a new `GenerateBoundingBoxProposals`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `post_nms_topn` attribute.
    pub fn post_nms_topn<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.post_nms_topn = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GenerateBoundingBoxProposals` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        scores: O0,
        bbox_deltas: O1,
        image_info: O2,
        anchors: O3,
        nms_threshold: O4,
        pre_nms_topn: O5,
        min_size: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            scores.into(),
            bbox_deltas.into(),
            image_info.into(),
            anchors.into(),
            nms_threshold.into(),
            pre_nms_topn.into(),
            min_size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        scores: crate::Output,
        bbox_deltas: crate::Output,
        image_info: crate::Output,
        anchors: crate::Output,
        nms_threshold: crate::Output,
        pre_nms_topn: crate::Output,
        min_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GenerateBoundingBoxProposals", |nd| {
            nd.add_input(scores);
            nd.add_input(bbox_deltas);
            nd.add_input(image_info);
            nd.add_input(anchors);
            nd.add_input(nms_threshold);
            nd.add_input(pre_nms_topn);
            nd.add_input(min_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.post_nms_topn {
                nd.set_attr_int("post_nms_topn", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GenerateBoundingBoxProposals::new().build(scores, bbox_deltas, image_info, anchors, nms_threshold, pre_nms_topn, min_size, scope)`.
pub fn generate_bounding_box_proposals<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    scores: O0,
    bbox_deltas: O1,
    image_info: O2,
    anchors: O3,
    nms_threshold: O4,
    pre_nms_topn: O5,
    min_size: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GenerateBoundingBoxProposals::new().build(
        scores,
        bbox_deltas,
        image_info,
        anchors,
        nms_threshold,
        pre_nms_topn,
        min_size,
        scope,
    )
}
/// Builder for the `GenerateVocabRemapping` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GenerateVocabRemapping {
    new_vocab_offset: ::std::option::Option<i64>,
    num_new_vocab: ::std::option::Option<i64>,
    old_vocab_size: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GenerateVocabRemapping {
    /// Creates a new `GenerateVocabRemapping`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `new_vocab_offset` attribute.
    pub fn new_vocab_offset<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.new_vocab_offset = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_new_vocab` attribute.
    pub fn num_new_vocab<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_new_vocab = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `old_vocab_size` attribute.
    pub fn old_vocab_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.old_vocab_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GenerateVocabRemapping` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        new_vocab_file: O0,
        old_vocab_file: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(new_vocab_file.into(), old_vocab_file.into(), scope)
    }

    fn build_impl(
        &self,
        new_vocab_file: crate::Output,
        old_vocab_file: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GenerateVocabRemapping", |nd| {
            nd.add_input(new_vocab_file);
            nd.add_input(old_vocab_file);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.new_vocab_offset {
                nd.set_attr_int("new_vocab_offset", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_new_vocab {
                nd.set_attr_int("num_new_vocab", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.old_vocab_size {
                nd.set_attr_int("old_vocab_size", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GenerateVocabRemapping::new().build(new_vocab_file, old_vocab_file, scope)`.
pub fn generate_vocab_remapping<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    new_vocab_file: O0,
    old_vocab_file: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GenerateVocabRemapping::new().build(new_vocab_file, old_vocab_file, scope)
}
/// Builder for the `GeneratorDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GeneratorDataset {
    init_func: ::std::option::Option<::std::string::String>,
    next_func: ::std::option::Option<::std::string::String>,
    finalize_func: ::std::option::Option<::std::string::String>,
    Tinit_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tnext_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tfinalize_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GeneratorDataset {
    /// Creates a new `GeneratorDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `init_func` attribute.
    pub fn init_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.init_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `next_func` attribute.
    pub fn next_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.next_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `finalize_func` attribute.
    pub fn finalize_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.finalize_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tinit_func_args` attribute.
    pub fn Tinit_func_args<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinit_func_args = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnext_func_args` attribute.
    pub fn Tnext_func_args<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnext_func_args = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfinalize_func_args` attribute.
    pub fn Tfinalize_func_args<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfinalize_func_args = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GeneratorDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        init_func_other_args: O0,
        next_func_other_args: O1,
        finalize_func_other_args: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            init_func_other_args.into(),
            next_func_other_args.into(),
            finalize_func_other_args.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        init_func_other_args: crate::Output,
        next_func_other_args: crate::Output,
        finalize_func_other_args: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GeneratorDataset", |nd| {
            nd.add_input(init_func_other_args);
            nd.add_input(next_func_other_args);
            nd.add_input(finalize_func_other_args);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.init_func {
                nd.set_attr_string("init_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.next_func {
                nd.set_attr_string("next_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.finalize_func {
                nd.set_attr_string("finalize_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tinit_func_args {
                nd.set_attr_type_list("Tinit_func_args", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnext_func_args {
                nd.set_attr_type_list("Tnext_func_args", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfinalize_func_args {
                nd.set_attr_type_list("Tfinalize_func_args", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GeneratorDataset::new().build(init_func_other_args, next_func_other_args, finalize_func_other_args, scope)`.
pub fn generator_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    init_func_other_args: O0,
    next_func_other_args: O1,
    finalize_func_other_args: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GeneratorDataset::new().build(
        init_func_other_args,
        next_func_other_args,
        finalize_func_other_args,
        scope,
    )
}
/// Builder for the `GetSessionHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GetSessionHandle {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GetSessionHandle {
    /// Creates a new `GetSessionHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GetSessionHandle` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        value: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GetSessionHandle", |nd| {
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GetSessionHandle::new().build(value, scope)`.
pub fn get_session_handle<O0: ::std::convert::Into<crate::Output>>(
    value: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GetSessionHandle::new().build(value, scope)
}
/// Builder for the `GetSessionHandleV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GetSessionHandleV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GetSessionHandleV2 {
    /// Creates a new `GetSessionHandleV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GetSessionHandleV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        value: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GetSessionHandleV2", |nd| {
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GetSessionHandleV2::new().build(value, scope)`.
pub fn get_session_handle_v2<O0: ::std::convert::Into<crate::Output>>(
    value: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GetSessionHandleV2::new().build(value, scope)
}
/// Builder for the `GetSessionTensor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GetSessionTensor {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GetSessionTensor {
    /// Creates a new `GetSessionTensor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GetSessionTensor` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GetSessionTensor", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GetSessionTensor::new().build(handle, scope)`.
pub fn get_session_tensor<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GetSessionTensor::new().build(handle, scope)
}
/// Builder for the `Greater` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Greater {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Greater {
    /// Creates a new `Greater`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Greater` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Greater", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Greater::new().build(x, y, scope)`.
pub fn greater<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Greater::new().build(x, y, scope)
}
/// Builder for the `GreaterEqual` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GreaterEqual {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GreaterEqual {
    /// Creates a new `GreaterEqual`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GreaterEqual` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GreaterEqual", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GreaterEqual::new().build(x, y, scope)`.
pub fn greater_equal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GreaterEqual::new().build(x, y, scope)
}
/// Builder for the `GroupByReducerDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GroupByReducerDataset {
    key_func: ::std::option::Option<::std::string::String>,
    init_func: ::std::option::Option<::std::string::String>,
    reduce_func: ::std::option::Option<::std::string::String>,
    finalize_func: ::std::option::Option<::std::string::String>,
    Tkey_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tinit_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Treduce_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tfinalize_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GroupByReducerDataset {
    /// Creates a new `GroupByReducerDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `key_func` attribute.
    pub fn key_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `init_func` attribute.
    pub fn init_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.init_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reduce_func` attribute.
    pub fn reduce_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduce_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `finalize_func` attribute.
    pub fn finalize_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.finalize_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tkey_func_other_arguments` attribute.
    pub fn Tkey_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tkey_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tinit_func_other_arguments` attribute.
    pub fn Tinit_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinit_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Treduce_func_other_arguments` attribute.
    pub fn Treduce_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Treduce_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfinalize_func_other_arguments` attribute.
    pub fn Tfinalize_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfinalize_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GroupByReducerDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        key_func_other_arguments: O1,
        init_func_other_arguments: O2,
        reduce_func_other_arguments: O3,
        finalize_func_other_arguments: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            key_func_other_arguments.into(),
            init_func_other_arguments.into(),
            reduce_func_other_arguments.into(),
            finalize_func_other_arguments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        key_func_other_arguments: crate::Output,
        init_func_other_arguments: crate::Output,
        reduce_func_other_arguments: crate::Output,
        finalize_func_other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GroupByReducerDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(key_func_other_arguments);
            nd.add_input(init_func_other_arguments);
            nd.add_input(reduce_func_other_arguments);
            nd.add_input(finalize_func_other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.key_func {
                nd.set_attr_string("key_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.init_func {
                nd.set_attr_string("init_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reduce_func {
                nd.set_attr_string("reduce_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.finalize_func {
                nd.set_attr_string("finalize_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tkey_func_other_arguments {
                nd.set_attr_type_list("Tkey_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tinit_func_other_arguments {
                nd.set_attr_type_list("Tinit_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Treduce_func_other_arguments {
                nd.set_attr_type_list("Treduce_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfinalize_func_other_arguments {
                nd.set_attr_type_list("Tfinalize_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GroupByReducerDataset::new().build(input_dataset, key_func_other_arguments, init_func_other_arguments, reduce_func_other_arguments, finalize_func_other_arguments, scope)`.
pub fn group_by_reducer_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    key_func_other_arguments: O1,
    init_func_other_arguments: O2,
    reduce_func_other_arguments: O3,
    finalize_func_other_arguments: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GroupByReducerDataset::new().build(
        input_dataset,
        key_func_other_arguments,
        init_func_other_arguments,
        reduce_func_other_arguments,
        finalize_func_other_arguments,
        scope,
    )
}
/// Builder for the `GroupByWindowDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GroupByWindowDataset {
    key_func: ::std::option::Option<::std::string::String>,
    reduce_func: ::std::option::Option<::std::string::String>,
    window_size_func: ::std::option::Option<::std::string::String>,
    Tkey_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Treduce_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Twindow_size_func_other_arguments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GroupByWindowDataset {
    /// Creates a new `GroupByWindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `key_func` attribute.
    pub fn key_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reduce_func` attribute.
    pub fn reduce_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduce_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `window_size_func` attribute.
    pub fn window_size_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.window_size_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tkey_func_other_arguments` attribute.
    pub fn Tkey_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tkey_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Treduce_func_other_arguments` attribute.
    pub fn Treduce_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Treduce_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Twindow_size_func_other_arguments` attribute.
    pub fn Twindow_size_func_other_arguments<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Twindow_size_func_other_arguments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GroupByWindowDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        key_func_other_arguments: O1,
        reduce_func_other_arguments: O2,
        window_size_func_other_arguments: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            key_func_other_arguments.into(),
            reduce_func_other_arguments.into(),
            window_size_func_other_arguments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        key_func_other_arguments: crate::Output,
        reduce_func_other_arguments: crate::Output,
        window_size_func_other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GroupByWindowDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(key_func_other_arguments);
            nd.add_input(reduce_func_other_arguments);
            nd.add_input(window_size_func_other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.key_func {
                nd.set_attr_string("key_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reduce_func {
                nd.set_attr_string("reduce_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.window_size_func {
                nd.set_attr_string("window_size_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tkey_func_other_arguments {
                nd.set_attr_type_list("Tkey_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Treduce_func_other_arguments {
                nd.set_attr_type_list("Treduce_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Twindow_size_func_other_arguments {
                nd.set_attr_type_list("Twindow_size_func_other_arguments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GroupByWindowDataset::new().build(input_dataset, key_func_other_arguments, reduce_func_other_arguments, window_size_func_other_arguments, scope)`.
pub fn group_by_window_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    key_func_other_arguments: O1,
    reduce_func_other_arguments: O2,
    window_size_func_other_arguments: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GroupByWindowDataset::new().build(
        input_dataset,
        key_func_other_arguments,
        reduce_func_other_arguments,
        window_size_func_other_arguments,
        scope,
    )
}
/// Builder for the `GuaranteeConst` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct GuaranteeConst {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl GuaranteeConst {
    /// Creates a new `GuaranteeConst`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `GuaranteeConst` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("GuaranteeConst", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `GuaranteeConst::new().build(input, scope)`.
pub fn guarantee_const<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    GuaranteeConst::new().build(input, scope)
}
/// Builder for the `HSVToRGB` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HSVToRGB {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl HSVToRGB {
    /// Creates a new `HSVToRGB`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `HSVToRGB` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        images: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("HSVToRGB", |nd| {
            nd.add_input(images);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `HSVToRGB::new().build(images, scope)`.
pub fn hsvto_rgb<O0: ::std::convert::Into<crate::Output>>(
    images: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    HSVToRGB::new().build(images, scope)
}
/// Builder for the `HashTable` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HashTable {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    use_node_name_sharing: ::std::option::Option<bool>,
    key_dtype: ::std::option::Option<crate::DataType>,
    value_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl HashTable {
    /// Creates a new `HashTable`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_node_name_sharing` attribute.
    pub fn use_node_name_sharing<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_node_name_sharing = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key_dtype` attribute.
    pub fn key_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_dtype` attribute.
    pub fn value_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `HashTable` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("HashTable", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_node_name_sharing {
                nd.set_attr_bool("use_node_name_sharing", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key_dtype {
                nd.set_attr_type("key_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_dtype {
                nd.set_attr_type("value_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `HashTable::new().build(scope)`.
pub fn hash_table(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    HashTable::new().build(scope)
}
/// Builder for the `HashTableV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HashTableV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    use_node_name_sharing: ::std::option::Option<bool>,
    key_dtype: ::std::option::Option<crate::DataType>,
    value_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl HashTableV2 {
    /// Creates a new `HashTableV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_node_name_sharing` attribute.
    pub fn use_node_name_sharing<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_node_name_sharing = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key_dtype` attribute.
    pub fn key_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_dtype` attribute.
    pub fn value_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `HashTableV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("HashTableV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_node_name_sharing {
                nd.set_attr_bool("use_node_name_sharing", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key_dtype {
                nd.set_attr_type("key_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_dtype {
                nd.set_attr_type("value_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `HashTableV2::new().build(scope)`.
pub fn hash_table_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    HashTableV2::new().build(scope)
}
/// Builder for the `HistogramFixedWidth` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HistogramFixedWidth {
    T: ::std::option::Option<crate::DataType>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl HistogramFixedWidth {
    /// Creates a new `HistogramFixedWidth`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `HistogramFixedWidth` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        values: O0,
        value_range: O1,
        nbins: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(values.into(), value_range.into(), nbins.into(), scope)
    }

    fn build_impl(
        &self,
        values: crate::Output,
        value_range: crate::Output,
        nbins: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("HistogramFixedWidth", |nd| {
            nd.add_input(values);
            nd.add_input(value_range);
            nd.add_input(nbins);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `HistogramFixedWidth::new().build(values, value_range, nbins, scope)`.
pub fn histogram_fixed_width<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    values: O0,
    value_range: O1,
    nbins: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    HistogramFixedWidth::new().build(values, value_range, nbins, scope)
}
/// Builder for the `HistogramSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HistogramSummary {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl HistogramSummary {
    /// Creates a new `HistogramSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `HistogramSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tag: O0,
        values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tag.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        tag: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("HistogramSummary", |nd| {
            nd.add_input(tag);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `HistogramSummary::new().build(tag, values, scope)`.
pub fn histogram_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tag: O0,
    values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    HistogramSummary::new().build(tag, values, scope)
}
/// Builder for the `HostConst` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct HostConst {
    value: ::std::option::Option<::std::boxed::Box<dyn crate::AnyTensor>>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl HostConst {
    /// Creates a new `HostConst`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `value` attribute.
    pub fn value<T: crate::TensorType, ArgType: ::std::convert::Into<crate::Tensor<T>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value = ::std::option::Option::Some(
            (::std::boxed::Box::new(value.into()) as ::std::boxed::Box<dyn crate::AnyTensor>),
        );
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `HostConst` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("HostConst", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.value {
                nd.set_attr_any_tensor("value", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `HostConst::new().build(scope)`.
pub fn host_const(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    HostConst::new().build(scope)
}
/// Builder for the `IFFT` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IFFT {
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IFFT {
    /// Creates a new `IFFT`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IFFT` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IFFT", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IFFT::new().build(input, scope)`.
pub fn ifft<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IFFT::new().build(input, scope)
}
/// Builder for the `IFFT2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IFFT2D {
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IFFT2D {
    /// Creates a new `IFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IFFT2D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IFFT2D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IFFT2D::new().build(input, scope)`.
pub fn ifft2_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IFFT2D::new().build(input, scope)
}
/// Builder for the `IFFT3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IFFT3D {
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IFFT3D {
    /// Creates a new `IFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IFFT3D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IFFT3D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IFFT3D::new().build(input, scope)`.
pub fn ifft3_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IFFT3D::new().build(input, scope)
}
/// Builder for the `IRFFT` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IRFFT {
    Treal: ::std::option::Option<crate::DataType>,
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IRFFT {
    /// Creates a new `IRFFT`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Treal` attribute.
    pub fn Treal<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Treal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IRFFT` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        fft_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), fft_length.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        fft_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IRFFT", |nd| {
            nd.add_input(input);
            nd.add_input(fft_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Treal {
                nd.set_attr_type("Treal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IRFFT::new().build(input, fft_length, scope)`.
pub fn irfft<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    fft_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IRFFT::new().build(input, fft_length, scope)
}
/// Builder for the `IRFFT2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IRFFT2D {
    Treal: ::std::option::Option<crate::DataType>,
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IRFFT2D {
    /// Creates a new `IRFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Treal` attribute.
    pub fn Treal<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Treal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IRFFT2D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        fft_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), fft_length.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        fft_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IRFFT2D", |nd| {
            nd.add_input(input);
            nd.add_input(fft_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Treal {
                nd.set_attr_type("Treal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IRFFT2D::new().build(input, fft_length, scope)`.
pub fn irfft2_d<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    fft_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IRFFT2D::new().build(input, fft_length, scope)
}
/// Builder for the `IRFFT3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IRFFT3D {
    Treal: ::std::option::Option<crate::DataType>,
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IRFFT3D {
    /// Creates a new `IRFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Treal` attribute.
    pub fn Treal<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Treal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IRFFT3D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        fft_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), fft_length.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        fft_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IRFFT3D", |nd| {
            nd.add_input(input);
            nd.add_input(fft_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Treal {
                nd.set_attr_type("Treal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IRFFT3D::new().build(input, fft_length, scope)`.
pub fn irfft3_d<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    fft_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IRFFT3D::new().build(input, fft_length, scope)
}
/// Builder for the `Identity` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Identity {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Identity {
    /// Creates a new `Identity`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Identity` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Identity", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Identity::new().build(input, scope)`.
pub fn identity<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Identity::new().build(input, scope)
}
/// Builder for the `IdentityN` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IdentityN {
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IdentityN {
    /// Creates a new `IdentityN`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IdentityN` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IdentityN", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IdentityN::new().build(input, scope)`.
pub fn identity_n<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IdentityN::new().build(input, scope)
}
/// Builder for the `IdentityReader` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IdentityReader {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IdentityReader {
    /// Creates a new `IdentityReader`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IdentityReader` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("IdentityReader", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IdentityReader::new().build(scope)`.
pub fn identity_reader(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    IdentityReader::new().build(scope)
}
/// Builder for the `IdentityReaderV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IdentityReaderV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IdentityReaderV2 {
    /// Creates a new `IdentityReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IdentityReaderV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("IdentityReaderV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IdentityReaderV2::new().build(scope)`.
pub fn identity_reader_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    IdentityReaderV2::new().build(scope)
}
/// Builder for the `If` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct If {
    Tcond: ::std::option::Option<crate::DataType>,
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    then_branch: ::std::option::Option<::std::string::String>,
    else_branch: ::std::option::Option<::std::string::String>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl If {
    /// Creates a new `If`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcond` attribute.
    pub fn Tcond<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tcond = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `then_branch` attribute.
    pub fn then_branch<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.then_branch = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `else_branch` attribute.
    pub fn else_branch<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.else_branch = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `If` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        cond: O0,
        input: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(cond.into(), input.into(), scope)
    }

    fn build_impl(
        &self,
        cond: crate::Output,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("If", |nd| {
            nd.add_input(cond);
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcond {
                nd.set_attr_type("Tcond", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.then_branch {
                nd.set_attr_string("then_branch", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.else_branch {
                nd.set_attr_string("else_branch", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `If::new().build(cond, input, scope)`.
pub fn if_<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    cond: O0,
    input: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    If::new().build(cond, input, scope)
}
/// Builder for the `Igamma` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Igamma {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Igamma {
    /// Creates a new `Igamma`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Igamma` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        x: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), x.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Igamma", |nd| {
            nd.add_input(a);
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Igamma::new().build(a, x, scope)`.
pub fn igamma<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    a: O0,
    x: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Igamma::new().build(a, x, scope)
}
/// Builder for the `IgammaGradA` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IgammaGradA {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IgammaGradA {
    /// Creates a new `IgammaGradA`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IgammaGradA` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        x: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), x.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IgammaGradA", |nd| {
            nd.add_input(a);
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IgammaGradA::new().build(a, x, scope)`.
pub fn igamma_grad_a<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    x: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IgammaGradA::new().build(a, x, scope)
}
/// Builder for the `Igammac` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Igammac {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Igammac {
    /// Creates a new `Igammac`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Igammac` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        x: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), x.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Igammac", |nd| {
            nd.add_input(a);
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Igammac::new().build(a, x, scope)`.
pub fn igammac<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    a: O0,
    x: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Igammac::new().build(a, x, scope)
}
/// Builder for the `IgnoreErrorsDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IgnoreErrorsDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IgnoreErrorsDataset {
    /// Creates a new `IgnoreErrorsDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IgnoreErrorsDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IgnoreErrorsDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IgnoreErrorsDataset::new().build(input_dataset, scope)`.
pub fn ignore_errors_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IgnoreErrorsDataset::new().build(input_dataset, scope)
}
/// Builder for the `Imag` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Imag {
    T: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Imag {
    /// Creates a new `Imag`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Imag` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Imag", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Imag::new().build(input, scope)`.
pub fn imag<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Imag::new().build(input, scope)
}
/// Builder for the `ImageProjectiveTransformV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImageProjectiveTransformV2 {
    dtype: ::std::option::Option<crate::DataType>,
    interpolation: ::std::option::Option<::std::string::String>,
    fill_mode: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ImageProjectiveTransformV2 {
    /// Creates a new `ImageProjectiveTransformV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `interpolation` attribute.
    pub fn interpolation<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.interpolation = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fill_mode` attribute.
    pub fn fill_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.fill_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ImageProjectiveTransformV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        transforms: O1,
        output_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), transforms.into(), output_shape.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        transforms: crate::Output,
        output_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ImageProjectiveTransformV2", |nd| {
            nd.add_input(images);
            nd.add_input(transforms);
            nd.add_input(output_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.interpolation {
                nd.set_attr_string("interpolation", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fill_mode {
                nd.set_attr_string("fill_mode", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ImageProjectiveTransformV2::new().build(images, transforms, output_shape, scope)`.
pub fn image_projective_transform_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    transforms: O1,
    output_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ImageProjectiveTransformV2::new().build(images, transforms, output_shape, scope)
}
/// Builder for the `ImageSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImageSummary {
    max_images: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    bad_color: ::std::option::Option<::std::boxed::Box<dyn crate::AnyTensor>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ImageSummary {
    /// Creates a new `ImageSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_images` attribute.
    pub fn max_images<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_images = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `bad_color` attribute.
    pub fn bad_color<T: crate::TensorType, ArgType: ::std::convert::Into<crate::Tensor<T>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.bad_color = ::std::option::Option::Some(
            (::std::boxed::Box::new(value.into()) as ::std::boxed::Box<dyn crate::AnyTensor>),
        );
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ImageSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tag: O0,
        tensor: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tag.into(), tensor.into(), scope)
    }

    fn build_impl(
        &self,
        tag: crate::Output,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ImageSummary", |nd| {
            nd.add_input(tag);
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_images {
                nd.set_attr_int("max_images", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.bad_color {
                nd.set_attr_any_tensor("bad_color", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ImageSummary::new().build(tag, tensor, scope)`.
pub fn image_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tag: O0,
    tensor: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ImageSummary::new().build(tag, tensor, scope)
}
/// Builder for the `ImmutableConst` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImmutableConst {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    memory_region_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ImmutableConst {
    /// Creates a new `ImmutableConst`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_region_name` attribute.
    pub fn memory_region_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.memory_region_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ImmutableConst` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ImmutableConst", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_region_name {
                nd.set_attr_string("memory_region_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ImmutableConst::new().build(scope)`.
pub fn immutable_const(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    ImmutableConst::new().build(scope)
}
/// Builder for the `ImportEvent` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ImportEvent {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ImportEvent {
    /// Creates a new `ImportEvent`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ImportEvent` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        event: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(writer.into(), event.into(), scope)
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        event: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ImportEvent", |nd| {
            nd.add_input(writer);
            nd.add_input(event);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ImportEvent::new().build(writer, event, scope)`.
pub fn import_event<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    event: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ImportEvent::new().build(writer, event, scope)
}
/// Builder for the `InTopK` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InTopK {
    k: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InTopK {
    /// Creates a new `InTopK`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `k` attribute.
    pub fn k<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.k = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InTopK` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        predictions: O0,
        targets: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(predictions.into(), targets.into(), scope)
    }

    fn build_impl(
        &self,
        predictions: crate::Output,
        targets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InTopK", |nd| {
            nd.add_input(predictions);
            nd.add_input(targets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.k {
                nd.set_attr_int("k", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InTopK::new().build(predictions, targets, scope)`.
pub fn in_top_k<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    predictions: O0,
    targets: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InTopK::new().build(predictions, targets, scope)
}
/// Builder for the `InTopKV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InTopKV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InTopKV2 {
    /// Creates a new `InTopKV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InTopKV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        predictions: O0,
        targets: O1,
        k: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(predictions.into(), targets.into(), k.into(), scope)
    }

    fn build_impl(
        &self,
        predictions: crate::Output,
        targets: crate::Output,
        k: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InTopKV2", |nd| {
            nd.add_input(predictions);
            nd.add_input(targets);
            nd.add_input(k);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InTopKV2::new().build(predictions, targets, k, scope)`.
pub fn in_top_kv2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    predictions: O0,
    targets: O1,
    k: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InTopKV2::new().build(predictions, targets, k, scope)
}
/// Builder for the `InfeedDequeue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedDequeue {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InfeedDequeue {
    /// Creates a new `InfeedDequeue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InfeedDequeue` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("InfeedDequeue", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InfeedDequeue::new().build(scope)`.
pub fn infeed_dequeue(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    InfeedDequeue::new().build(scope)
}
/// Builder for the `InfeedDequeueTuple` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedDequeueTuple {
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InfeedDequeueTuple {
    /// Creates a new `InfeedDequeueTuple`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InfeedDequeueTuple` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("InfeedDequeueTuple", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InfeedDequeueTuple::new().build(scope)`.
pub fn infeed_dequeue_tuple(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    InfeedDequeueTuple::new().build(scope)
}
/// Builder for the `InfeedEnqueue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedEnqueue {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    layout: ::std::option::Option<::std::vec::Vec<i64>>,
    device_ordinal: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InfeedEnqueue {
    /// Creates a new `InfeedEnqueue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `layout` attribute.
    pub fn layout<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.layout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InfeedEnqueue` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InfeedEnqueue", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.layout {
                nd.set_attr_int_list("layout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InfeedEnqueue::new().build(input, scope)`.
pub fn infeed_enqueue<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InfeedEnqueue::new().build(input, scope)
}
/// Builder for the `InfeedEnqueuePrelinearizedBuffer` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedEnqueuePrelinearizedBuffer {
    device_ordinal: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InfeedEnqueuePrelinearizedBuffer {
    /// Creates a new `InfeedEnqueuePrelinearizedBuffer`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InfeedEnqueuePrelinearizedBuffer` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InfeedEnqueuePrelinearizedBuffer", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InfeedEnqueuePrelinearizedBuffer::new().build(input, scope)`.
pub fn infeed_enqueue_prelinearized_buffer<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InfeedEnqueuePrelinearizedBuffer::new().build(input, scope)
}
/// Builder for the `InfeedEnqueueTuple` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InfeedEnqueueTuple {
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    layouts: ::std::option::Option<::std::vec::Vec<i64>>,
    device_ordinal: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InfeedEnqueueTuple {
    /// Creates a new `InfeedEnqueueTuple`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `layouts` attribute.
    pub fn layouts<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.layouts = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InfeedEnqueueTuple` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InfeedEnqueueTuple", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.layouts {
                nd.set_attr_int_list("layouts", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InfeedEnqueueTuple::new().build(inputs, scope)`.
pub fn infeed_enqueue_tuple<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InfeedEnqueueTuple::new().build(inputs, scope)
}
/// Builder for the `InitializeTable` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTable {
    Tkey: ::std::option::Option<crate::DataType>,
    Tval: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InitializeTable {
    /// Creates a new `InitializeTable`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tkey` attribute.
    pub fn Tkey<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tkey = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tval` attribute.
    pub fn Tval<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tval = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InitializeTable` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), keys.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InitializeTable", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tkey {
                nd.set_attr_type("Tkey", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tval {
                nd.set_attr_type("Tval", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InitializeTable::new().build(table_handle, keys, values, scope)`.
pub fn initialize_table<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InitializeTable::new().build(table_handle, keys, values, scope)
}
/// Builder for the `InitializeTableFromDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTableFromDataset {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InitializeTableFromDataset {
    /// Creates a new `InitializeTableFromDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InitializeTableFromDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        dataset: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), dataset.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InitializeTableFromDataset", |nd| {
            nd.add_input(table_handle);
            nd.add_input(dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InitializeTableFromDataset::new().build(table_handle, dataset, scope)`.
pub fn initialize_table_from_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    dataset: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InitializeTableFromDataset::new().build(table_handle, dataset, scope)
}
/// Builder for the `InitializeTableFromTextFile` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTableFromTextFile {
    key_index: ::std::option::Option<i64>,
    value_index: ::std::option::Option<i64>,
    vocab_size: ::std::option::Option<i64>,
    delimiter: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InitializeTableFromTextFile {
    /// Creates a new `InitializeTableFromTextFile`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `key_index` attribute.
    pub fn key_index<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.key_index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_index` attribute.
    pub fn value_index<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.value_index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `vocab_size` attribute.
    pub fn vocab_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.vocab_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `delimiter` attribute.
    pub fn delimiter<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.delimiter = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InitializeTableFromTextFile` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        filename: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), filename.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        filename: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InitializeTableFromTextFile", |nd| {
            nd.add_input(table_handle);
            nd.add_input(filename);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.key_index {
                nd.set_attr_int("key_index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_index {
                nd.set_attr_int("value_index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.vocab_size {
                nd.set_attr_int("vocab_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.delimiter {
                nd.set_attr_string("delimiter", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InitializeTableFromTextFile::new().build(table_handle, filename, scope)`.
pub fn initialize_table_from_text_file<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    filename: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InitializeTableFromTextFile::new().build(table_handle, filename, scope)
}
/// Builder for the `InitializeTableFromTextFileV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTableFromTextFileV2 {
    key_index: ::std::option::Option<i64>,
    value_index: ::std::option::Option<i64>,
    vocab_size: ::std::option::Option<i64>,
    delimiter: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InitializeTableFromTextFileV2 {
    /// Creates a new `InitializeTableFromTextFileV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `key_index` attribute.
    pub fn key_index<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.key_index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_index` attribute.
    pub fn value_index<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.value_index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `vocab_size` attribute.
    pub fn vocab_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.vocab_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `delimiter` attribute.
    pub fn delimiter<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.delimiter = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InitializeTableFromTextFileV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        filename: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), filename.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        filename: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InitializeTableFromTextFileV2", |nd| {
            nd.add_input(table_handle);
            nd.add_input(filename);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.key_index {
                nd.set_attr_int("key_index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_index {
                nd.set_attr_int("value_index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.vocab_size {
                nd.set_attr_int("vocab_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.delimiter {
                nd.set_attr_string("delimiter", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InitializeTableFromTextFileV2::new().build(table_handle, filename, scope)`.
pub fn initialize_table_from_text_file_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    filename: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InitializeTableFromTextFileV2::new().build(table_handle, filename, scope)
}
/// Builder for the `InitializeTableV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InitializeTableV2 {
    Tkey: ::std::option::Option<crate::DataType>,
    Tval: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InitializeTableV2 {
    /// Creates a new `InitializeTableV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tkey` attribute.
    pub fn Tkey<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tkey = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tval` attribute.
    pub fn Tval<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tval = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InitializeTableV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), keys.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InitializeTableV2", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tkey {
                nd.set_attr_type("Tkey", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tval {
                nd.set_attr_type("Tval", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InitializeTableV2::new().build(table_handle, keys, values, scope)`.
pub fn initialize_table_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InitializeTableV2::new().build(table_handle, keys, values, scope)
}
/// Builder for the `InplaceAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InplaceAdd {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InplaceAdd {
    /// Creates a new `InplaceAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InplaceAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        i: O1,
        v: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), i.into(), v.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        i: crate::Output,
        v: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InplaceAdd", |nd| {
            nd.add_input(x);
            nd.add_input(i);
            nd.add_input(v);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InplaceAdd::new().build(x, i, v, scope)`.
pub fn inplace_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    i: O1,
    v: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InplaceAdd::new().build(x, i, v, scope)
}
/// Builder for the `InplaceSub` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InplaceSub {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InplaceSub {
    /// Creates a new `InplaceSub`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InplaceSub` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        i: O1,
        v: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), i.into(), v.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        i: crate::Output,
        v: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InplaceSub", |nd| {
            nd.add_input(x);
            nd.add_input(i);
            nd.add_input(v);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InplaceSub::new().build(x, i, v, scope)`.
pub fn inplace_sub<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    i: O1,
    v: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InplaceSub::new().build(x, i, v, scope)
}
/// Builder for the `InplaceUpdate` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InplaceUpdate {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InplaceUpdate {
    /// Creates a new `InplaceUpdate`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InplaceUpdate` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        i: O1,
        v: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), i.into(), v.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        i: crate::Output,
        v: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InplaceUpdate", |nd| {
            nd.add_input(x);
            nd.add_input(i);
            nd.add_input(v);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InplaceUpdate::new().build(x, i, v, scope)`.
pub fn inplace_update<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    i: O1,
    v: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InplaceUpdate::new().build(x, i, v, scope)
}
/// Builder for the `InterleaveDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InterleaveDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InterleaveDataset {
    /// Creates a new `InterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InterleaveDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        cycle_length: O2,
        block_length: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            cycle_length.into(),
            block_length.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        cycle_length: crate::Output,
        block_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InterleaveDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(cycle_length);
            nd.add_input(block_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InterleaveDataset::new().build(input_dataset, other_arguments, cycle_length, block_length, scope)`.
pub fn interleave_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    cycle_length: O2,
    block_length: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InterleaveDataset::new().build(
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        scope,
    )
}
/// Builder for the `Inv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Inv {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Inv {
    /// Creates a new `Inv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Inv` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Inv", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Inv::new().build(x, scope)`.
pub fn inv<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Inv::new().build(x, scope)
}
/// Builder for the `InvGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InvGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InvGrad {
    /// Creates a new `InvGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InvGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y: O0,
        dy: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(y.into(), dy.into(), scope)
    }

    fn build_impl(
        &self,
        y: crate::Output,
        dy: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InvGrad", |nd| {
            nd.add_input(y);
            nd.add_input(dy);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InvGrad::new().build(y, dy, scope)`.
pub fn inv_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    y: O0,
    dy: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InvGrad::new().build(y, dy, scope)
}
/// Builder for the `Invert` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Invert {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Invert {
    /// Creates a new `Invert`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Invert` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Invert", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Invert::new().build(x, scope)`.
pub fn invert<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Invert::new().build(x, scope)
}
/// Builder for the `InvertPermutation` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct InvertPermutation {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl InvertPermutation {
    /// Creates a new `InvertPermutation`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `InvertPermutation` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("InvertPermutation", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `InvertPermutation::new().build(x, scope)`.
pub fn invert_permutation<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    InvertPermutation::new().build(x, scope)
}
/// Builder for the `IsBoostedTreesEnsembleInitialized` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsBoostedTreesEnsembleInitialized {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IsBoostedTreesEnsembleInitialized {
    /// Creates a new `IsBoostedTreesEnsembleInitialized`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IsBoostedTreesEnsembleInitialized` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tree_ensemble_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_ensemble_handle.into(), scope)
    }

    fn build_impl(
        &self,
        tree_ensemble_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IsBoostedTreesEnsembleInitialized", |nd| {
            nd.add_input(tree_ensemble_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IsBoostedTreesEnsembleInitialized::new().build(tree_ensemble_handle, scope)`.
pub fn is_boosted_trees_ensemble_initialized<O0: ::std::convert::Into<crate::Output>>(
    tree_ensemble_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IsBoostedTreesEnsembleInitialized::new().build(tree_ensemble_handle, scope)
}
/// Builder for the `IsBoostedTreesQuantileStreamResourceInitialized` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsBoostedTreesQuantileStreamResourceInitialized {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IsBoostedTreesQuantileStreamResourceInitialized {
    /// Creates a new `IsBoostedTreesQuantileStreamResourceInitialized`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IsBoostedTreesQuantileStreamResourceInitialized` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        quantile_stream_resource_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(quantile_stream_resource_handle.into(), scope)
    }

    fn build_impl(
        &self,
        quantile_stream_resource_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IsBoostedTreesQuantileStreamResourceInitialized", |nd| {
            nd.add_input(quantile_stream_resource_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IsBoostedTreesQuantileStreamResourceInitialized::new().build(quantile_stream_resource_handle, scope)`.
pub fn is_boosted_trees_quantile_stream_resource_initialized<
    O0: ::std::convert::Into<crate::Output>,
>(
    quantile_stream_resource_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IsBoostedTreesQuantileStreamResourceInitialized::new()
        .build(quantile_stream_resource_handle, scope)
}
/// Builder for the `IsFinite` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsFinite {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IsFinite {
    /// Creates a new `IsFinite`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IsFinite` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IsFinite", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IsFinite::new().build(x, scope)`.
pub fn is_finite<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IsFinite::new().build(x, scope)
}
/// Builder for the `IsInf` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsInf {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IsInf {
    /// Creates a new `IsInf`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IsInf` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IsInf", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IsInf::new().build(x, scope)`.
pub fn is_inf<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IsInf::new().build(x, scope)
}
/// Builder for the `IsNan` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsNan {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IsNan {
    /// Creates a new `IsNan`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IsNan` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IsNan", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IsNan::new().build(x, scope)`.
pub fn is_nan<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IsNan::new().build(x, scope)
}
/// Builder for the `IsVariableInitialized` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IsVariableInitialized {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IsVariableInitialized {
    /// Creates a new `IsVariableInitialized`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IsVariableInitialized` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        ref_: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IsVariableInitialized", |nd| {
            nd.add_input(ref_);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IsVariableInitialized::new().build(ref_, scope)`.
pub fn is_variable_initialized<O0: ::std::convert::Into<crate::Output>>(
    ref_: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IsVariableInitialized::new().build(ref_, scope)
}
/// Builder for the `Iterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Iterator {
    shared_name: ::std::option::Option<::std::string::String>,
    container: ::std::option::Option<::std::string::String>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Iterator {
    /// Creates a new `Iterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Iterator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Iterator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Iterator::new().build(scope)`.
pub fn iterator(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Iterator::new().build(scope)
}
/// Builder for the `IteratorFromStringHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorFromStringHandle {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IteratorFromStringHandle {
    /// Creates a new `IteratorFromStringHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IteratorFromStringHandle` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        string_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(string_handle.into(), scope)
    }

    fn build_impl(
        &self,
        string_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IteratorFromStringHandle", |nd| {
            nd.add_input(string_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IteratorFromStringHandle::new().build(string_handle, scope)`.
pub fn iterator_from_string_handle<O0: ::std::convert::Into<crate::Output>>(
    string_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IteratorFromStringHandle::new().build(string_handle, scope)
}
/// Builder for the `IteratorFromStringHandleV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorFromStringHandleV2 {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IteratorFromStringHandleV2 {
    /// Creates a new `IteratorFromStringHandleV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IteratorFromStringHandleV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        string_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(string_handle.into(), scope)
    }

    fn build_impl(
        &self,
        string_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IteratorFromStringHandleV2", |nd| {
            nd.add_input(string_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IteratorFromStringHandleV2::new().build(string_handle, scope)`.
pub fn iterator_from_string_handle_v2<O0: ::std::convert::Into<crate::Output>>(
    string_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IteratorFromStringHandleV2::new().build(string_handle, scope)
}
/// Builder for the `IteratorGetDevice` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorGetDevice {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IteratorGetDevice {
    /// Creates a new `IteratorGetDevice`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IteratorGetDevice` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IteratorGetDevice", |nd| {
            nd.add_input(resource);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IteratorGetDevice::new().build(resource, scope)`.
pub fn iterator_get_device<O0: ::std::convert::Into<crate::Output>>(
    resource: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IteratorGetDevice::new().build(resource, scope)
}
/// Builder for the `IteratorGetNext` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorGetNext {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IteratorGetNext {
    /// Creates a new `IteratorGetNext`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IteratorGetNext` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        iterator: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(iterator.into(), scope)
    }

    fn build_impl(
        &self,
        iterator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IteratorGetNext", |nd| {
            nd.add_input(iterator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IteratorGetNext::new().build(iterator, scope)`.
pub fn iterator_get_next<O0: ::std::convert::Into<crate::Output>>(
    iterator: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IteratorGetNext::new().build(iterator, scope)
}
/// Builder for the `IteratorGetNextAsOptional` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorGetNextAsOptional {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IteratorGetNextAsOptional {
    /// Creates a new `IteratorGetNextAsOptional`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IteratorGetNextAsOptional` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        iterator: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(iterator.into(), scope)
    }

    fn build_impl(
        &self,
        iterator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IteratorGetNextAsOptional", |nd| {
            nd.add_input(iterator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IteratorGetNextAsOptional::new().build(iterator, scope)`.
pub fn iterator_get_next_as_optional<O0: ::std::convert::Into<crate::Output>>(
    iterator: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IteratorGetNextAsOptional::new().build(iterator, scope)
}
/// Builder for the `IteratorGetNextSync` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorGetNextSync {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IteratorGetNextSync {
    /// Creates a new `IteratorGetNextSync`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IteratorGetNextSync` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        iterator: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(iterator.into(), scope)
    }

    fn build_impl(
        &self,
        iterator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IteratorGetNextSync", |nd| {
            nd.add_input(iterator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IteratorGetNextSync::new().build(iterator, scope)`.
pub fn iterator_get_next_sync<O0: ::std::convert::Into<crate::Output>>(
    iterator: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IteratorGetNextSync::new().build(iterator, scope)
}
/// Builder for the `IteratorToStringHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorToStringHandle {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IteratorToStringHandle {
    /// Creates a new `IteratorToStringHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IteratorToStringHandle` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource_handle.into(), scope)
    }

    fn build_impl(
        &self,
        resource_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("IteratorToStringHandle", |nd| {
            nd.add_input(resource_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IteratorToStringHandle::new().build(resource_handle, scope)`.
pub fn iterator_to_string_handle<O0: ::std::convert::Into<crate::Output>>(
    resource_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    IteratorToStringHandle::new().build(resource_handle, scope)
}
/// Builder for the `IteratorV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct IteratorV2 {
    shared_name: ::std::option::Option<::std::string::String>,
    container: ::std::option::Option<::std::string::String>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl IteratorV2 {
    /// Creates a new `IteratorV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `IteratorV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("IteratorV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `IteratorV2::new().build(scope)`.
pub fn iterator_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    IteratorV2::new().build(scope)
}
/// Builder for the `KMC2ChainInitialization` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct KMC2ChainInitialization {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl KMC2ChainInitialization {
    /// Creates a new `KMC2ChainInitialization`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `KMC2ChainInitialization` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        distances: O0,
        seed: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(distances.into(), seed.into(), scope)
    }

    fn build_impl(
        &self,
        distances: crate::Output,
        seed: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("KMC2ChainInitialization", |nd| {
            nd.add_input(distances);
            nd.add_input(seed);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `KMC2ChainInitialization::new().build(distances, seed, scope)`.
pub fn kmc2_chain_initialization<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    distances: O0,
    seed: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    KMC2ChainInitialization::new().build(distances, seed, scope)
}
/// Builder for the `KmeansPlusPlusInitialization` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct KmeansPlusPlusInitialization {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl KmeansPlusPlusInitialization {
    /// Creates a new `KmeansPlusPlusInitialization`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `KmeansPlusPlusInitialization` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        points: O0,
        num_to_sample: O1,
        seed: O2,
        num_retries_per_sample: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            points.into(),
            num_to_sample.into(),
            seed.into(),
            num_retries_per_sample.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        points: crate::Output,
        num_to_sample: crate::Output,
        seed: crate::Output,
        num_retries_per_sample: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("KmeansPlusPlusInitialization", |nd| {
            nd.add_input(points);
            nd.add_input(num_to_sample);
            nd.add_input(seed);
            nd.add_input(num_retries_per_sample);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `KmeansPlusPlusInitialization::new().build(points, num_to_sample, seed, num_retries_per_sample, scope)`.
pub fn kmeans_plus_plus_initialization<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    points: O0,
    num_to_sample: O1,
    seed: O2,
    num_retries_per_sample: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    KmeansPlusPlusInitialization::new().build(
        points,
        num_to_sample,
        seed,
        num_retries_per_sample,
        scope,
    )
}
/// Builder for the `L2Loss` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct L2Loss {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl L2Loss {
    /// Creates a new `L2Loss`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `L2Loss` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        t: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(t.into(), scope)
    }

    fn build_impl(
        &self,
        t: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("L2Loss", |nd| {
            nd.add_input(t);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `L2Loss::new().build(t, scope)`.
pub fn l2_loss<O0: ::std::convert::Into<crate::Output>>(
    t: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    L2Loss::new().build(t, scope)
}
/// Builder for the `LMDBDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LMDBDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LMDBDataset {
    /// Creates a new `LMDBDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LMDBDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        filenames: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(filenames.into(), scope)
    }

    fn build_impl(
        &self,
        filenames: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LMDBDataset", |nd| {
            nd.add_input(filenames);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LMDBDataset::new().build(filenames, scope)`.
pub fn lmdbdataset<O0: ::std::convert::Into<crate::Output>>(
    filenames: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LMDBDataset::new().build(filenames, scope)
}
/// Builder for the `LMDBReader` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LMDBReader {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LMDBReader {
    /// Creates a new `LMDBReader`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LMDBReader` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("LMDBReader", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LMDBReader::new().build(scope)`.
pub fn lmdbreader(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    LMDBReader::new().build(scope)
}
/// Builder for the `LRN` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LRN {
    depth_radius: ::std::option::Option<i64>,
    bias: ::std::option::Option<f32>,
    alpha: ::std::option::Option<f32>,
    beta: ::std::option::Option<f32>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LRN {
    /// Creates a new `LRN`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `depth_radius` attribute.
    pub fn depth_radius<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.depth_radius = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `bias` attribute.
    pub fn bias<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.bias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `alpha` attribute.
    pub fn alpha<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.alpha = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `beta` attribute.
    pub fn beta<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.beta = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LRN` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LRN", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.depth_radius {
                nd.set_attr_int("depth_radius", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.bias {
                nd.set_attr_float("bias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.alpha {
                nd.set_attr_float("alpha", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.beta {
                nd.set_attr_float("beta", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LRN::new().build(input, scope)`.
pub fn lrn<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LRN::new().build(input, scope)
}
/// Builder for the `LRNGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LRNGrad {
    depth_radius: ::std::option::Option<i64>,
    bias: ::std::option::Option<f32>,
    alpha: ::std::option::Option<f32>,
    beta: ::std::option::Option<f32>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LRNGrad {
    /// Creates a new `LRNGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `depth_radius` attribute.
    pub fn depth_radius<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.depth_radius = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `bias` attribute.
    pub fn bias<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.bias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `alpha` attribute.
    pub fn alpha<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.alpha = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `beta` attribute.
    pub fn beta<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.beta = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LRNGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_grads: O0,
        input_image: O1,
        output_image: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_grads.into(),
            input_image.into(),
            output_image.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_grads: crate::Output,
        input_image: crate::Output,
        output_image: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LRNGrad", |nd| {
            nd.add_input(input_grads);
            nd.add_input(input_image);
            nd.add_input(output_image);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.depth_radius {
                nd.set_attr_int("depth_radius", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.bias {
                nd.set_attr_float("bias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.alpha {
                nd.set_attr_float("alpha", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.beta {
                nd.set_attr_float("beta", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LRNGrad::new().build(input_grads, input_image, output_image, scope)`.
pub fn lrngrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_grads: O0,
    input_image: O1,
    output_image: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LRNGrad::new().build(input_grads, input_image, output_image, scope)
}
/// Builder for the `LSTMBlockCell` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LSTMBlockCell {
    forget_bias: ::std::option::Option<f32>,
    cell_clip: ::std::option::Option<f32>,
    use_peephole: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LSTMBlockCell {
    /// Creates a new `LSTMBlockCell`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `forget_bias` attribute.
    pub fn forget_bias<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.forget_bias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `cell_clip` attribute.
    pub fn cell_clip<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.cell_clip = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_peephole` attribute.
    pub fn use_peephole<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_peephole = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LSTMBlockCell` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        cs_prev: O1,
        h_prev: O2,
        w: O3,
        wci: O4,
        wcf: O5,
        wco: O6,
        b: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            cs_prev.into(),
            h_prev.into(),
            w.into(),
            wci.into(),
            wcf.into(),
            wco.into(),
            b.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        cs_prev: crate::Output,
        h_prev: crate::Output,
        w: crate::Output,
        wci: crate::Output,
        wcf: crate::Output,
        wco: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LSTMBlockCell", |nd| {
            nd.add_input(x);
            nd.add_input(cs_prev);
            nd.add_input(h_prev);
            nd.add_input(w);
            nd.add_input(wci);
            nd.add_input(wcf);
            nd.add_input(wco);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.forget_bias {
                nd.set_attr_float("forget_bias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.cell_clip {
                nd.set_attr_float("cell_clip", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_peephole {
                nd.set_attr_bool("use_peephole", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LSTMBlockCell::new().build(x, cs_prev, h_prev, w, wci, wcf, wco, b, scope)`.
pub fn lstmblock_cell<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    cs_prev: O1,
    h_prev: O2,
    w: O3,
    wci: O4,
    wcf: O5,
    wco: O6,
    b: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LSTMBlockCell::new().build(x, cs_prev, h_prev, w, wci, wcf, wco, b, scope)
}
/// Builder for the `LSTMBlockCellGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LSTMBlockCellGrad {
    use_peephole: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LSTMBlockCellGrad {
    /// Creates a new `LSTMBlockCellGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `use_peephole` attribute.
    pub fn use_peephole<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_peephole = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LSTMBlockCellGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
        O12: ::std::convert::Into<crate::Output>,
        O13: ::std::convert::Into<crate::Output>,
        O14: ::std::convert::Into<crate::Output>,
        O15: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        cs_prev: O1,
        h_prev: O2,
        w: O3,
        wci: O4,
        wcf: O5,
        wco: O6,
        b: O7,
        i: O8,
        cs: O9,
        f: O10,
        o: O11,
        ci: O12,
        co: O13,
        cs_grad: O14,
        h_grad: O15,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            cs_prev.into(),
            h_prev.into(),
            w.into(),
            wci.into(),
            wcf.into(),
            wco.into(),
            b.into(),
            i.into(),
            cs.into(),
            f.into(),
            o.into(),
            ci.into(),
            co.into(),
            cs_grad.into(),
            h_grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        cs_prev: crate::Output,
        h_prev: crate::Output,
        w: crate::Output,
        wci: crate::Output,
        wcf: crate::Output,
        wco: crate::Output,
        b: crate::Output,
        i: crate::Output,
        cs: crate::Output,
        f: crate::Output,
        o: crate::Output,
        ci: crate::Output,
        co: crate::Output,
        cs_grad: crate::Output,
        h_grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LSTMBlockCellGrad", |nd| {
            nd.add_input(x);
            nd.add_input(cs_prev);
            nd.add_input(h_prev);
            nd.add_input(w);
            nd.add_input(wci);
            nd.add_input(wcf);
            nd.add_input(wco);
            nd.add_input(b);
            nd.add_input(i);
            nd.add_input(cs);
            nd.add_input(f);
            nd.add_input(o);
            nd.add_input(ci);
            nd.add_input(co);
            nd.add_input(cs_grad);
            nd.add_input(h_grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.use_peephole {
                nd.set_attr_bool("use_peephole", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LSTMBlockCellGrad::new().build(x, cs_prev, h_prev, w, wci, wcf, wco, b, i, cs, f, o, ci, co, cs_grad, h_grad, scope)`.
pub fn lstmblock_cell_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
    O12: ::std::convert::Into<crate::Output>,
    O13: ::std::convert::Into<crate::Output>,
    O14: ::std::convert::Into<crate::Output>,
    O15: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    cs_prev: O1,
    h_prev: O2,
    w: O3,
    wci: O4,
    wcf: O5,
    wco: O6,
    b: O7,
    i: O8,
    cs: O9,
    f: O10,
    o: O11,
    ci: O12,
    co: O13,
    cs_grad: O14,
    h_grad: O15,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LSTMBlockCellGrad::new().build(
        x, cs_prev, h_prev, w, wci, wcf, wco, b, i, cs, f, o, ci, co, cs_grad, h_grad, scope,
    )
}
/// Builder for the `LatencyStatsDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LatencyStatsDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LatencyStatsDataset {
    /// Creates a new `LatencyStatsDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LatencyStatsDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        tag: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), tag.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        tag: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LatencyStatsDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(tag);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LatencyStatsDataset::new().build(input_dataset, tag, scope)`.
pub fn latency_stats_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    tag: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LatencyStatsDataset::new().build(input_dataset, tag, scope)
}
/// Builder for the `LeakyRelu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LeakyRelu {
    alpha: ::std::option::Option<f32>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LeakyRelu {
    /// Creates a new `LeakyRelu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `alpha` attribute.
    pub fn alpha<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.alpha = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LeakyRelu` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        features: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LeakyRelu", |nd| {
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.alpha {
                nd.set_attr_float("alpha", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LeakyRelu::new().build(features, scope)`.
pub fn leaky_relu<O0: ::std::convert::Into<crate::Output>>(
    features: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LeakyRelu::new().build(features, scope)
}
/// Builder for the `LeakyReluGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LeakyReluGrad {
    alpha: ::std::option::Option<f32>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LeakyReluGrad {
    /// Creates a new `LeakyReluGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `alpha` attribute.
    pub fn alpha<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.alpha = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LeakyReluGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        features: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(gradients.into(), features.into(), scope)
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LeakyReluGrad", |nd| {
            nd.add_input(gradients);
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.alpha {
                nd.set_attr_float("alpha", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LeakyReluGrad::new().build(gradients, features, scope)`.
pub fn leaky_relu_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    features: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LeakyReluGrad::new().build(gradients, features, scope)
}
/// Builder for the `LearnedUnigramCandidateSampler` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LearnedUnigramCandidateSampler {
    num_true: ::std::option::Option<i64>,
    num_sampled: ::std::option::Option<i64>,
    unique: ::std::option::Option<bool>,
    range_max: ::std::option::Option<i64>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LearnedUnigramCandidateSampler {
    /// Creates a new `LearnedUnigramCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_true` attribute.
    pub fn num_true<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_true = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sampled` attribute.
    pub fn num_sampled<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_sampled = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `unique` attribute.
    pub fn unique<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.unique = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `range_max` attribute.
    pub fn range_max<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.range_max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LearnedUnigramCandidateSampler` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        true_classes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(true_classes.into(), scope)
    }

    fn build_impl(
        &self,
        true_classes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LearnedUnigramCandidateSampler", |nd| {
            nd.add_input(true_classes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_true {
                nd.set_attr_int("num_true", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sampled {
                nd.set_attr_int("num_sampled", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.unique {
                nd.set_attr_bool("unique", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.range_max {
                nd.set_attr_int("range_max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LearnedUnigramCandidateSampler::new().build(true_classes, scope)`.
pub fn learned_unigram_candidate_sampler<O0: ::std::convert::Into<crate::Output>>(
    true_classes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LearnedUnigramCandidateSampler::new().build(true_classes, scope)
}
/// Builder for the `LeftShift` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LeftShift {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LeftShift {
    /// Creates a new `LeftShift`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LeftShift` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LeftShift", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LeftShift::new().build(x, y, scope)`.
pub fn left_shift<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LeftShift::new().build(x, y, scope)
}
/// Builder for the `LegacyParallelInterleaveDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LegacyParallelInterleaveDatasetV2 {
    f: ::std::option::Option<::std::string::String>,
    deterministic: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LegacyParallelInterleaveDatasetV2 {
    /// Creates a new `LegacyParallelInterleaveDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `deterministic` attribute.
    pub fn deterministic<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.deterministic = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LegacyParallelInterleaveDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        cycle_length: O2,
        block_length: O3,
        buffer_output_elements: O4,
        prefetch_input_elements: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            cycle_length.into(),
            block_length.into(),
            buffer_output_elements.into(),
            prefetch_input_elements.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        cycle_length: crate::Output,
        block_length: crate::Output,
        buffer_output_elements: crate::Output,
        prefetch_input_elements: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LegacyParallelInterleaveDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(cycle_length);
            nd.add_input(block_length);
            nd.add_input(buffer_output_elements);
            nd.add_input(prefetch_input_elements);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.deterministic {
                nd.set_attr_string("deterministic", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LegacyParallelInterleaveDatasetV2::new().build(input_dataset, other_arguments, cycle_length, block_length, buffer_output_elements, prefetch_input_elements, scope)`.
pub fn legacy_parallel_interleave_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    cycle_length: O2,
    block_length: O3,
    buffer_output_elements: O4,
    prefetch_input_elements: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LegacyParallelInterleaveDatasetV2::new().build(
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        buffer_output_elements,
        prefetch_input_elements,
        scope,
    )
}
/// Builder for the `Less` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Less {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Less {
    /// Creates a new `Less`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Less` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Less", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Less::new().build(x, y, scope)`.
pub fn less<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Less::new().build(x, y, scope)
}
/// Builder for the `LessEqual` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LessEqual {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LessEqual {
    /// Creates a new `LessEqual`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LessEqual` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LessEqual", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LessEqual::new().build(x, y, scope)`.
pub fn less_equal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LessEqual::new().build(x, y, scope)
}
/// Builder for the `Lgamma` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Lgamma {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Lgamma {
    /// Creates a new `Lgamma`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Lgamma` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Lgamma", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Lgamma::new().build(x, scope)`.
pub fn lgamma<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Lgamma::new().build(x, scope)
}
/// Builder for the `LinSpace` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LinSpace {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LinSpace {
    /// Creates a new `LinSpace`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LinSpace` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        start: O0,
        stop: O1,
        num: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(start.into(), stop.into(), num.into(), scope)
    }

    fn build_impl(
        &self,
        start: crate::Output,
        stop: crate::Output,
        num: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LinSpace", |nd| {
            nd.add_input(start);
            nd.add_input(stop);
            nd.add_input(num);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LinSpace::new().build(start, stop, num, scope)`.
pub fn lin_space<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    start: O0,
    stop: O1,
    num: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LinSpace::new().build(start, stop, num, scope)
}
/// Builder for the `ListDiff` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ListDiff {
    T: ::std::option::Option<crate::DataType>,
    out_idx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ListDiff {
    /// Creates a new `ListDiff`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_idx` attribute.
    pub fn out_idx<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_idx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ListDiff` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ListDiff", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_idx {
                nd.set_attr_type("out_idx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ListDiff::new().build(x, y, scope)`.
pub fn list_diff<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ListDiff::new().build(x, y, scope)
}
/// Builder for the `LoadAndRemapMatrix` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadAndRemapMatrix {
    num_rows: ::std::option::Option<i64>,
    num_cols: ::std::option::Option<i64>,
    max_rows_in_memory: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadAndRemapMatrix {
    /// Creates a new `LoadAndRemapMatrix`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_rows` attribute.
    pub fn num_rows<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_rows = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_cols` attribute.
    pub fn num_cols<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_cols = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_rows_in_memory` attribute.
    pub fn max_rows_in_memory<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.max_rows_in_memory = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadAndRemapMatrix` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ckpt_path: O0,
        old_tensor_name: O1,
        row_remapping: O2,
        col_remapping: O3,
        initializing_values: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            ckpt_path.into(),
            old_tensor_name.into(),
            row_remapping.into(),
            col_remapping.into(),
            initializing_values.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        ckpt_path: crate::Output,
        old_tensor_name: crate::Output,
        row_remapping: crate::Output,
        col_remapping: crate::Output,
        initializing_values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadAndRemapMatrix", |nd| {
            nd.add_input(ckpt_path);
            nd.add_input(old_tensor_name);
            nd.add_input(row_remapping);
            nd.add_input(col_remapping);
            nd.add_input(initializing_values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_rows {
                nd.set_attr_int("num_rows", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_cols {
                nd.set_attr_int("num_cols", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_rows_in_memory {
                nd.set_attr_int("max_rows_in_memory", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadAndRemapMatrix::new().build(ckpt_path, old_tensor_name, row_remapping, col_remapping, initializing_values, scope)`.
pub fn load_and_remap_matrix<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    ckpt_path: O0,
    old_tensor_name: O1,
    row_remapping: O2,
    col_remapping: O3,
    initializing_values: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadAndRemapMatrix::new().build(
        ckpt_path,
        old_tensor_name,
        row_remapping,
        col_remapping,
        initializing_values,
        scope,
    )
}
/// Builder for the `LoadDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    compression: ::std::option::Option<::std::string::String>,
    reader_func: ::std::option::Option<::std::string::String>,
    Treader_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadDataset {
    /// Creates a new `LoadDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `compression` attribute.
    pub fn compression<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compression = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reader_func` attribute.
    pub fn reader_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reader_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Treader_func_args` attribute.
    pub fn Treader_func_args<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Treader_func_args = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        path: O0,
        reader_func_other_args: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(path.into(), reader_func_other_args.into(), scope)
    }

    fn build_impl(
        &self,
        path: crate::Output,
        reader_func_other_args: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadDataset", |nd| {
            nd.add_input(path);
            nd.add_input(reader_func_other_args);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.compression {
                nd.set_attr_string("compression", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reader_func {
                nd.set_attr_string("reader_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Treader_func_args {
                nd.set_attr_type_list("Treader_func_args", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadDataset::new().build(path, reader_func_other_args, scope)`.
pub fn load_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    path: O0,
    reader_func_other_args: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadDataset::new().build(path, reader_func_other_args, scope)
}
/// Builder for the `LoadTPUEmbeddingADAMParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingADAMParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingADAMParameters {
    /// Creates a new `LoadTPUEmbeddingADAMParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingADAMParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        momenta: O1,
        velocities: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), momenta.into(), velocities.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        momenta: crate::Output,
        velocities: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingADAMParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(momenta);
            nd.add_input(velocities);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingADAMParameters::new().build(parameters, momenta, velocities, scope)`.
pub fn load_tpuembedding_adamparameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    momenta: O1,
    velocities: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingADAMParameters::new().build(parameters, momenta, velocities, scope)
}
/// Builder for the `LoadTPUEmbeddingADAMParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingADAMParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingADAMParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingADAMParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingADAMParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        momenta: O1,
        velocities: O2,
        gradient_accumulators: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            momenta.into(),
            velocities.into(),
            gradient_accumulators.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        momenta: crate::Output,
        velocities: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingADAMParametersGradAccumDebug", |nd| {
            nd.add_input(parameters);
            nd.add_input(momenta);
            nd.add_input(velocities);
            nd.add_input(gradient_accumulators);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingADAMParametersGradAccumDebug::new().build(parameters, momenta, velocities, gradient_accumulators, scope)`.
pub fn load_tpuembedding_adamparameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    momenta: O1,
    velocities: O2,
    gradient_accumulators: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingADAMParametersGradAccumDebug::new().build(
        parameters,
        momenta,
        velocities,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingAdadeltaParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingAdadeltaParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingAdadeltaParameters {
    /// Creates a new `LoadTPUEmbeddingAdadeltaParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingAdadeltaParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            accumulators.into(),
            updates.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingAdadeltaParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(accumulators);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingAdadeltaParameters::new().build(parameters, accumulators, updates, scope)`.
pub fn load_tpuembedding_adadelta_parameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingAdadeltaParameters::new().build(parameters, accumulators, updates, scope)
}
/// Builder for the `LoadTPUEmbeddingAdadeltaParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingAdadeltaParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingAdadeltaParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingAdadeltaParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        updates: O2,
        gradient_accumulators: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            accumulators.into(),
            updates.into(),
            gradient_accumulators.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        updates: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", |nd| {
            nd.add_input(parameters);
            nd.add_input(accumulators);
            nd.add_input(updates);
            nd.add_input(gradient_accumulators);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingAdadeltaParametersGradAccumDebug::new().build(parameters, accumulators, updates, gradient_accumulators, scope)`.
pub fn load_tpuembedding_adadelta_parameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    updates: O2,
    gradient_accumulators: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingAdadeltaParametersGradAccumDebug::new().build(
        parameters,
        accumulators,
        updates,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingAdagradParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingAdagradParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingAdagradParameters {
    /// Creates a new `LoadTPUEmbeddingAdagradParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingAdagradParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), accumulators.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingAdagradParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(accumulators);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingAdagradParameters::new().build(parameters, accumulators, scope)`.
pub fn load_tpuembedding_adagrad_parameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingAdagradParameters::new().build(parameters, accumulators, scope)
}
/// Builder for the `LoadTPUEmbeddingAdagradParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingAdagradParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingAdagradParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingAdagradParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        gradient_accumulators: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            accumulators.into(),
            gradient_accumulators.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingAdagradParametersGradAccumDebug", |nd| {
            nd.add_input(parameters);
            nd.add_input(accumulators);
            nd.add_input(gradient_accumulators);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingAdagradParametersGradAccumDebug::new().build(parameters, accumulators, gradient_accumulators, scope)`.
pub fn load_tpuembedding_adagrad_parameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    gradient_accumulators: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingAdagradParametersGradAccumDebug::new().build(
        parameters,
        accumulators,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingCenteredRMSPropParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingCenteredRMSPropParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingCenteredRMSPropParameters {
    /// Creates a new `LoadTPUEmbeddingCenteredRMSPropParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingCenteredRMSPropParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        ms: O1,
        mom: O2,
        mg: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), ms.into(), mom.into(), mg.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        mg: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingCenteredRMSPropParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(mg);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingCenteredRMSPropParameters::new().build(parameters, ms, mom, mg, scope)`.
pub fn load_tpuembedding_centered_rmsprop_parameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    ms: O1,
    mom: O2,
    mg: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingCenteredRMSPropParameters::new().build(parameters, ms, mom, mg, scope)
}
/// Builder for the `LoadTPUEmbeddingFTRLParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingFTRLParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingFTRLParameters {
    /// Creates a new `LoadTPUEmbeddingFTRLParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingFTRLParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        linears: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            accumulators.into(),
            linears.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        linears: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingFTRLParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(accumulators);
            nd.add_input(linears);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingFTRLParameters::new().build(parameters, accumulators, linears, scope)`.
pub fn load_tpuembedding_ftrlparameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    linears: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingFTRLParameters::new().build(parameters, accumulators, linears, scope)
}
/// Builder for the `LoadTPUEmbeddingFTRLParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingFTRLParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingFTRLParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingFTRLParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        linears: O2,
        gradient_accumulators: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            accumulators.into(),
            linears.into(),
            gradient_accumulators.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        linears: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingFTRLParametersGradAccumDebug", |nd| {
            nd.add_input(parameters);
            nd.add_input(accumulators);
            nd.add_input(linears);
            nd.add_input(gradient_accumulators);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingFTRLParametersGradAccumDebug::new().build(parameters, accumulators, linears, gradient_accumulators, scope)`.
pub fn load_tpuembedding_ftrlparameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    linears: O2,
    gradient_accumulators: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingFTRLParametersGradAccumDebug::new().build(
        parameters,
        accumulators,
        linears,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingMDLAdagradLightParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingMDLAdagradLightParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingMDLAdagradLightParameters {
    /// Creates a new `LoadTPUEmbeddingMDLAdagradLightParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingMDLAdagradLightParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        weights: O2,
        benefits: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            accumulators.into(),
            weights.into(),
            benefits.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        weights: crate::Output,
        benefits: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingMDLAdagradLightParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(accumulators);
            nd.add_input(weights);
            nd.add_input(benefits);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingMDLAdagradLightParameters::new().build(parameters, accumulators, weights, benefits, scope)`.
pub fn load_tpuembedding_mdladagrad_light_parameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    weights: O2,
    benefits: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingMDLAdagradLightParameters::new().build(
        parameters,
        accumulators,
        weights,
        benefits,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingMomentumParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingMomentumParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingMomentumParameters {
    /// Creates a new `LoadTPUEmbeddingMomentumParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingMomentumParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        momenta: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), momenta.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        momenta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingMomentumParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(momenta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingMomentumParameters::new().build(parameters, momenta, scope)`.
pub fn load_tpuembedding_momentum_parameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    momenta: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingMomentumParameters::new().build(parameters, momenta, scope)
}
/// Builder for the `LoadTPUEmbeddingMomentumParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingMomentumParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingMomentumParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingMomentumParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        momenta: O1,
        gradient_accumulators: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            momenta.into(),
            gradient_accumulators.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        momenta: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingMomentumParametersGradAccumDebug", |nd| {
            nd.add_input(parameters);
            nd.add_input(momenta);
            nd.add_input(gradient_accumulators);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingMomentumParametersGradAccumDebug::new().build(parameters, momenta, gradient_accumulators, scope)`.
pub fn load_tpuembedding_momentum_parameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    momenta: O1,
    gradient_accumulators: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingMomentumParametersGradAccumDebug::new().build(
        parameters,
        momenta,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingProximalAdagradParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingProximalAdagradParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingProximalAdagradParameters {
    /// Creates a new `LoadTPUEmbeddingProximalAdagradParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingProximalAdagradParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), accumulators.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingProximalAdagradParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(accumulators);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingProximalAdagradParameters::new().build(parameters, accumulators, scope)`.
pub fn load_tpuembedding_proximal_adagrad_parameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingProximalAdagradParameters::new().build(parameters, accumulators, scope)
}
/// Builder for the `LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        accumulators: O1,
        gradient_accumulators: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            accumulators.into(),
            gradient_accumulators.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        accumulators: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug",
            |nd| {
                nd.add_input(parameters);
                nd.add_input(accumulators);
                nd.add_input(gradient_accumulators);
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug::new().build(parameters, accumulators, gradient_accumulators, scope)`.
pub fn load_tpuembedding_proximal_adagrad_parameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    accumulators: O1,
    gradient_accumulators: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug::new().build(
        parameters,
        accumulators,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingProximalYogiParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingProximalYogiParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingProximalYogiParameters {
    /// Creates a new `LoadTPUEmbeddingProximalYogiParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingProximalYogiParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        v: O1,
        m: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), v.into(), m.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        v: crate::Output,
        m: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingProximalYogiParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(v);
            nd.add_input(m);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingProximalYogiParameters::new().build(parameters, v, m, scope)`.
pub fn load_tpuembedding_proximal_yogi_parameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    v: O1,
    m: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingProximalYogiParameters::new().build(parameters, v, m, scope)
}
/// Builder for the `LoadTPUEmbeddingProximalYogiParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingProximalYogiParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingProximalYogiParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingProximalYogiParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingProximalYogiParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        v: O1,
        m: O2,
        gradient_accumulators: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            v.into(),
            m.into(),
            gradient_accumulators.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        v: crate::Output,
        m: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "LoadTPUEmbeddingProximalYogiParametersGradAccumDebug",
            |nd| {
                nd.add_input(parameters);
                nd.add_input(v);
                nd.add_input(m);
                nd.add_input(gradient_accumulators);
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `LoadTPUEmbeddingProximalYogiParametersGradAccumDebug::new().build(parameters, v, m, gradient_accumulators, scope)`.
pub fn load_tpuembedding_proximal_yogi_parameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    v: O1,
    m: O2,
    gradient_accumulators: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingProximalYogiParametersGradAccumDebug::new().build(
        parameters,
        v,
        m,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingRMSPropParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingRMSPropParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingRMSPropParameters {
    /// Creates a new `LoadTPUEmbeddingRMSPropParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingRMSPropParameters` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        ms: O1,
        mom: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), ms.into(), mom.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingRMSPropParameters", |nd| {
            nd.add_input(parameters);
            nd.add_input(ms);
            nd.add_input(mom);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingRMSPropParameters::new().build(parameters, ms, mom, scope)`.
pub fn load_tpuembedding_rmsprop_parameters<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    ms: O1,
    mom: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingRMSPropParameters::new().build(parameters, ms, mom, scope)
}
/// Builder for the `LoadTPUEmbeddingRMSPropParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingRMSPropParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingRMSPropParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingRMSPropParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        ms: O1,
        mom: O2,
        gradient_accumulators: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            parameters.into(),
            ms.into(),
            mom.into(),
            gradient_accumulators.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoadTPUEmbeddingRMSPropParametersGradAccumDebug", |nd| {
            nd.add_input(parameters);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(gradient_accumulators);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoadTPUEmbeddingRMSPropParametersGradAccumDebug::new().build(parameters, ms, mom, gradient_accumulators, scope)`.
pub fn load_tpuembedding_rmsprop_parameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    ms: O1,
    mom: O2,
    gradient_accumulators: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingRMSPropParametersGradAccumDebug::new().build(
        parameters,
        ms,
        mom,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `LoadTPUEmbeddingStochasticGradientDescentParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingStochasticGradientDescentParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingStochasticGradientDescentParameters {
    /// Creates a new `LoadTPUEmbeddingStochasticGradientDescentParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingStochasticGradientDescentParameters` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        parameters: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "LoadTPUEmbeddingStochasticGradientDescentParameters",
            |nd| {
                nd.add_input(parameters);
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `LoadTPUEmbeddingStochasticGradientDescentParameters::new().build(parameters, scope)`.
pub fn load_tpuembedding_stochastic_gradient_descent_parameters<
    O0: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingStochasticGradientDescentParameters::new().build(parameters, scope)
}
/// Builder for the `LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug {
    /// Creates a new `LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        parameters: O0,
        gradient_accumulators: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(parameters.into(), gradient_accumulators.into(), scope)
    }

    fn build_impl(
        &self,
        parameters: crate::Output,
        gradient_accumulators: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug",
            |nd| {
                nd.add_input(parameters);
                nd.add_input(gradient_accumulators);
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug::new().build(parameters, gradient_accumulators, scope)`.
pub fn load_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    parameters: O0,
    gradient_accumulators: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug::new().build(
        parameters,
        gradient_accumulators,
        scope,
    )
}
/// Builder for the `Log` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Log {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Log {
    /// Creates a new `Log`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Log` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Log", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Log::new().build(x, scope)`.
pub fn log<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Log::new().build(x, scope)
}
/// Builder for the `Log1p` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Log1p {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Log1p {
    /// Creates a new `Log1p`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Log1p` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Log1p", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Log1p::new().build(x, scope)`.
pub fn log1p<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Log1p::new().build(x, scope)
}
/// Builder for the `LogMatrixDeterminant` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogMatrixDeterminant {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LogMatrixDeterminant {
    /// Creates a new `LogMatrixDeterminant`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LogMatrixDeterminant` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LogMatrixDeterminant", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LogMatrixDeterminant::new().build(input, scope)`.
pub fn log_matrix_determinant<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LogMatrixDeterminant::new().build(input, scope)
}
/// Builder for the `LogSoftmax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogSoftmax {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LogSoftmax {
    /// Creates a new `LogSoftmax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LogSoftmax` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        logits: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(logits.into(), scope)
    }

    fn build_impl(
        &self,
        logits: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LogSoftmax", |nd| {
            nd.add_input(logits);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LogSoftmax::new().build(logits, scope)`.
pub fn log_softmax<O0: ::std::convert::Into<crate::Output>>(
    logits: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LogSoftmax::new().build(logits, scope)
}
/// Builder for the `LogUniformCandidateSampler` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogUniformCandidateSampler {
    num_true: ::std::option::Option<i64>,
    num_sampled: ::std::option::Option<i64>,
    unique: ::std::option::Option<bool>,
    range_max: ::std::option::Option<i64>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LogUniformCandidateSampler {
    /// Creates a new `LogUniformCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_true` attribute.
    pub fn num_true<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_true = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sampled` attribute.
    pub fn num_sampled<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_sampled = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `unique` attribute.
    pub fn unique<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.unique = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `range_max` attribute.
    pub fn range_max<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.range_max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LogUniformCandidateSampler` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        true_classes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(true_classes.into(), scope)
    }

    fn build_impl(
        &self,
        true_classes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LogUniformCandidateSampler", |nd| {
            nd.add_input(true_classes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_true {
                nd.set_attr_int("num_true", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sampled {
                nd.set_attr_int("num_sampled", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.unique {
                nd.set_attr_bool("unique", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.range_max {
                nd.set_attr_int("range_max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LogUniformCandidateSampler::new().build(true_classes, scope)`.
pub fn log_uniform_candidate_sampler<O0: ::std::convert::Into<crate::Output>>(
    true_classes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LogUniformCandidateSampler::new().build(true_classes, scope)
}
/// Builder for the `LogicalAnd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogicalAnd {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LogicalAnd {
    /// Creates a new `LogicalAnd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LogicalAnd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LogicalAnd", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LogicalAnd::new().build(x, y, scope)`.
pub fn logical_and<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LogicalAnd::new().build(x, y, scope)
}
/// Builder for the `LogicalNot` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogicalNot {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LogicalNot {
    /// Creates a new `LogicalNot`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LogicalNot` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LogicalNot", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LogicalNot::new().build(x, scope)`.
pub fn logical_not<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LogicalNot::new().build(x, scope)
}
/// Builder for the `LogicalOr` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LogicalOr {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LogicalOr {
    /// Creates a new `LogicalOr`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LogicalOr` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LogicalOr", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LogicalOr::new().build(x, y, scope)`.
pub fn logical_or<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LogicalOr::new().build(x, y, scope)
}
/// Builder for the `LookupTableExport` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableExport {
    Tkeys: ::std::option::Option<crate::DataType>,
    Tvalues: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableExport {
    /// Creates a new `LookupTableExport`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tkeys` attribute.
    pub fn Tkeys<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tkeys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tvalues` attribute.
    pub fn Tvalues<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tvalues = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableExport` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        table_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableExport", |nd| {
            nd.add_input(table_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tkeys {
                nd.set_attr_type("Tkeys", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tvalues {
                nd.set_attr_type("Tvalues", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableExport::new().build(table_handle, scope)`.
pub fn lookup_table_export<O0: ::std::convert::Into<crate::Output>>(
    table_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableExport::new().build(table_handle, scope)
}
/// Builder for the `LookupTableExportV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableExportV2 {
    Tkeys: ::std::option::Option<crate::DataType>,
    Tvalues: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableExportV2 {
    /// Creates a new `LookupTableExportV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tkeys` attribute.
    pub fn Tkeys<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tkeys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tvalues` attribute.
    pub fn Tvalues<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tvalues = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableExportV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        table_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableExportV2", |nd| {
            nd.add_input(table_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tkeys {
                nd.set_attr_type("Tkeys", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tvalues {
                nd.set_attr_type("Tvalues", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableExportV2::new().build(table_handle, scope)`.
pub fn lookup_table_export_v2<O0: ::std::convert::Into<crate::Output>>(
    table_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableExportV2::new().build(table_handle, scope)
}
/// Builder for the `LookupTableFind` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableFind {
    Tin: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableFind {
    /// Creates a new `LookupTableFind`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableFind` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        default_value: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            table_handle.into(),
            keys.into(),
            default_value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        default_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableFind", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            nd.add_input(default_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type("Tin", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableFind::new().build(table_handle, keys, default_value, scope)`.
pub fn lookup_table_find<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    default_value: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableFind::new().build(table_handle, keys, default_value, scope)
}
/// Builder for the `LookupTableFindV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableFindV2 {
    Tin: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableFindV2 {
    /// Creates a new `LookupTableFindV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableFindV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        default_value: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            table_handle.into(),
            keys.into(),
            default_value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        default_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableFindV2", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            nd.add_input(default_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type("Tin", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableFindV2::new().build(table_handle, keys, default_value, scope)`.
pub fn lookup_table_find_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    default_value: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableFindV2::new().build(table_handle, keys, default_value, scope)
}
/// Builder for the `LookupTableImport` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableImport {
    Tin: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableImport {
    /// Creates a new `LookupTableImport`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableImport` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), keys.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableImport", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type("Tin", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableImport::new().build(table_handle, keys, values, scope)`.
pub fn lookup_table_import<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableImport::new().build(table_handle, keys, values, scope)
}
/// Builder for the `LookupTableImportV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableImportV2 {
    Tin: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableImportV2 {
    /// Creates a new `LookupTableImportV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableImportV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), keys.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableImportV2", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type("Tin", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableImportV2::new().build(table_handle, keys, values, scope)`.
pub fn lookup_table_import_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableImportV2::new().build(table_handle, keys, values, scope)
}
/// Builder for the `LookupTableInsert` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableInsert {
    Tin: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableInsert {
    /// Creates a new `LookupTableInsert`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableInsert` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), keys.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableInsert", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type("Tin", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableInsert::new().build(table_handle, keys, values, scope)`.
pub fn lookup_table_insert<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableInsert::new().build(table_handle, keys, values, scope)
}
/// Builder for the `LookupTableInsertV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableInsertV2 {
    Tin: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableInsertV2 {
    /// Creates a new `LookupTableInsertV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableInsertV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), keys.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableInsertV2", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type("Tin", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableInsertV2::new().build(table_handle, keys, values, scope)`.
pub fn lookup_table_insert_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableInsertV2::new().build(table_handle, keys, values, scope)
}
/// Builder for the `LookupTableRemoveV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableRemoveV2 {
    Tin: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableRemoveV2 {
    /// Creates a new `LookupTableRemoveV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableRemoveV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        table_handle: O0,
        keys: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), keys.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        keys: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableRemoveV2", |nd| {
            nd.add_input(table_handle);
            nd.add_input(keys);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type("Tin", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableRemoveV2::new().build(table_handle, keys, scope)`.
pub fn lookup_table_remove_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    table_handle: O0,
    keys: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableRemoveV2::new().build(table_handle, keys, scope)
}
/// Builder for the `LookupTableSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableSize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableSize {
    /// Creates a new `LookupTableSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableSize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        table_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableSize", |nd| {
            nd.add_input(table_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableSize::new().build(table_handle, scope)`.
pub fn lookup_table_size<O0: ::std::convert::Into<crate::Output>>(
    table_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableSize::new().build(table_handle, scope)
}
/// Builder for the `LookupTableSizeV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LookupTableSizeV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LookupTableSizeV2 {
    /// Creates a new `LookupTableSizeV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LookupTableSizeV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        table_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(table_handle.into(), scope)
    }

    fn build_impl(
        &self,
        table_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LookupTableSizeV2", |nd| {
            nd.add_input(table_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LookupTableSizeV2::new().build(table_handle, scope)`.
pub fn lookup_table_size_v2<O0: ::std::convert::Into<crate::Output>>(
    table_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LookupTableSizeV2::new().build(table_handle, scope)
}
/// Builder for the `LoopCond` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LoopCond {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LoopCond {
    /// Creates a new `LoopCond`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LoopCond` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LoopCond", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LoopCond::new().build(input, scope)`.
pub fn loop_cond<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LoopCond::new().build(input, scope)
}
/// Builder for the `LowerBound` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct LowerBound {
    T: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl LowerBound {
    /// Creates a new `LowerBound`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `LowerBound` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sorted_inputs: O0,
        values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(sorted_inputs.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        sorted_inputs: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("LowerBound", |nd| {
            nd.add_input(sorted_inputs);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `LowerBound::new().build(sorted_inputs, values, scope)`.
pub fn lower_bound<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    sorted_inputs: O0,
    values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    LowerBound::new().build(sorted_inputs, values, scope)
}
/// Builder for the `Lu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Lu {
    T: ::std::option::Option<crate::DataType>,
    output_idx_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Lu {
    /// Creates a new `Lu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_idx_type` attribute.
    pub fn output_idx_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_idx_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Lu` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Lu", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_idx_type {
                nd.set_attr_type("output_idx_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Lu::new().build(input, scope)`.
pub fn lu<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Lu::new().build(input, scope)
}
/// Builder for the `MakeIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MakeIterator {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MakeIterator {
    /// Creates a new `MakeIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MakeIterator` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        dataset: O0,
        iterator: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(dataset.into(), iterator.into(), scope)
    }

    fn build_impl(
        &self,
        dataset: crate::Output,
        iterator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MakeIterator", |nd| {
            nd.add_input(dataset);
            nd.add_input(iterator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MakeIterator::new().build(dataset, iterator, scope)`.
pub fn make_iterator<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    dataset: O0,
    iterator: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MakeIterator::new().build(dataset, iterator, scope)
}
/// Builder for the `MapAndBatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapAndBatchDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    preserve_cardinality: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapAndBatchDataset {
    /// Creates a new `MapAndBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_cardinality` attribute.
    pub fn preserve_cardinality<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_cardinality = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapAndBatchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        batch_size: O2,
        num_parallel_calls: O3,
        drop_remainder: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            batch_size.into(),
            num_parallel_calls.into(),
            drop_remainder.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        batch_size: crate::Output,
        num_parallel_calls: crate::Output,
        drop_remainder: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MapAndBatchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(batch_size);
            nd.add_input(num_parallel_calls);
            nd.add_input(drop_remainder);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_cardinality {
                nd.set_attr_bool("preserve_cardinality", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapAndBatchDataset::new().build(input_dataset, other_arguments, batch_size, num_parallel_calls, drop_remainder, scope)`.
pub fn map_and_batch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    batch_size: O2,
    num_parallel_calls: O3,
    drop_remainder: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MapAndBatchDataset::new().build(
        input_dataset,
        other_arguments,
        batch_size,
        num_parallel_calls,
        drop_remainder,
        scope,
    )
}
/// Builder for the `MapClear` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapClear {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapClear {
    /// Creates a new `MapClear`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapClear` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MapClear", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapClear::new().build(scope)`.
pub fn map_clear(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    MapClear::new().build(scope)
}
/// Builder for the `MapDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    use_inter_op_parallelism: ::std::option::Option<bool>,
    preserve_cardinality: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapDataset {
    /// Creates a new `MapDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_inter_op_parallelism` attribute.
    pub fn use_inter_op_parallelism<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_inter_op_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_cardinality` attribute.
    pub fn preserve_cardinality<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_cardinality = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), other_arguments.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MapDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_inter_op_parallelism {
                nd.set_attr_bool("use_inter_op_parallelism", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_cardinality {
                nd.set_attr_bool("preserve_cardinality", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapDataset::new().build(input_dataset, other_arguments, scope)`.
pub fn map_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MapDataset::new().build(input_dataset, other_arguments, scope)
}
/// Builder for the `MapDefun` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapDefun {
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tcaptured: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    f: ::std::option::Option<::std::string::String>,
    max_intra_op_parallelism: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapDefun {
    /// Creates a new `MapDefun`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcaptured` attribute.
    pub fn Tcaptured<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcaptured = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_intra_op_parallelism` attribute.
    pub fn max_intra_op_parallelism<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.max_intra_op_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapDefun` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        arguments: O0,
        captured_inputs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(arguments.into(), captured_inputs.into(), scope)
    }

    fn build_impl(
        &self,
        arguments: crate::Output,
        captured_inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MapDefun", |nd| {
            nd.add_input(arguments);
            nd.add_input(captured_inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcaptured {
                nd.set_attr_type_list("Tcaptured", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_intra_op_parallelism {
                nd.set_attr_int("max_intra_op_parallelism", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapDefun::new().build(arguments, captured_inputs, scope)`.
pub fn map_defun<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    arguments: O0,
    captured_inputs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MapDefun::new().build(arguments, captured_inputs, scope)
}
/// Builder for the `MapIncompleteSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapIncompleteSize {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapIncompleteSize {
    /// Creates a new `MapIncompleteSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapIncompleteSize` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MapIncompleteSize", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapIncompleteSize::new().build(scope)`.
pub fn map_incomplete_size(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    MapIncompleteSize::new().build(scope)
}
/// Builder for the `MapPeek` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapPeek {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapPeek {
    /// Creates a new `MapPeek`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapPeek` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        key: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(key.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        key: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MapPeek", |nd| {
            nd.add_input(key);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapPeek::new().build(key, indices, scope)`.
pub fn map_peek<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    key: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MapPeek::new().build(key, indices, scope)
}
/// Builder for the `MapSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapSize {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapSize {
    /// Creates a new `MapSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapSize` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MapSize", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapSize::new().build(scope)`.
pub fn map_size(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    MapSize::new().build(scope)
}
/// Builder for the `MapStage` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapStage {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    fake_dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapStage {
    /// Creates a new `MapStage`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fake_dtypes` attribute.
    pub fn fake_dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.fake_dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapStage` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        key: O0,
        indices: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(key.into(), indices.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        key: crate::Output,
        indices: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MapStage", |nd| {
            nd.add_input(key);
            nd.add_input(indices);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fake_dtypes {
                nd.set_attr_type_list("fake_dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapStage::new().build(key, indices, values, scope)`.
pub fn map_stage<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    key: O0,
    indices: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MapStage::new().build(key, indices, values, scope)
}
/// Builder for the `MapUnstage` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapUnstage {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapUnstage {
    /// Creates a new `MapUnstage`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapUnstage` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        key: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(key.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        key: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MapUnstage", |nd| {
            nd.add_input(key);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapUnstage::new().build(key, indices, scope)`.
pub fn map_unstage<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    key: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MapUnstage::new().build(key, indices, scope)
}
/// Builder for the `MapUnstageNoKey` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MapUnstageNoKey {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MapUnstageNoKey {
    /// Creates a new `MapUnstageNoKey`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MapUnstageNoKey` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        indices: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MapUnstageNoKey", |nd| {
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MapUnstageNoKey::new().build(indices, scope)`.
pub fn map_unstage_no_key<O0: ::std::convert::Into<crate::Output>>(
    indices: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MapUnstageNoKey::new().build(indices, scope)
}
/// Builder for the `MatMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatMul {
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatMul {
    /// Creates a new `MatMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), b.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatMul", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatMul::new().build(a, b, scope)`.
pub fn mat_mul<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    a: O0,
    b: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatMul::new().build(a, b, scope)
}
/// Builder for the `MatchingFiles` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatchingFiles {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatchingFiles {
    /// Creates a new `MatchingFiles`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatchingFiles` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        pattern: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(pattern.into(), scope)
    }

    fn build_impl(
        &self,
        pattern: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatchingFiles", |nd| {
            nd.add_input(pattern);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatchingFiles::new().build(pattern, scope)`.
pub fn matching_files<O0: ::std::convert::Into<crate::Output>>(
    pattern: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatchingFiles::new().build(pattern, scope)
}
/// Builder for the `MatchingFilesDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatchingFilesDataset {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatchingFilesDataset {
    /// Creates a new `MatchingFilesDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatchingFilesDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        patterns: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(patterns.into(), scope)
    }

    fn build_impl(
        &self,
        patterns: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatchingFilesDataset", |nd| {
            nd.add_input(patterns);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatchingFilesDataset::new().build(patterns, scope)`.
pub fn matching_files_dataset<O0: ::std::convert::Into<crate::Output>>(
    patterns: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatchingFilesDataset::new().build(patterns, scope)
}
/// Builder for the `MatrixBandPart` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixBandPart {
    T: ::std::option::Option<crate::DataType>,
    Tindex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixBandPart {
    /// Creates a new `MatrixBandPart`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindex` attribute.
    pub fn Tindex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixBandPart` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        num_lower: O1,
        num_upper: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), num_lower.into(), num_upper.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        num_lower: crate::Output,
        num_upper: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixBandPart", |nd| {
            nd.add_input(input);
            nd.add_input(num_lower);
            nd.add_input(num_upper);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindex {
                nd.set_attr_type("Tindex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixBandPart::new().build(input, num_lower, num_upper, scope)`.
pub fn matrix_band_part<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    num_lower: O1,
    num_upper: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixBandPart::new().build(input, num_lower, num_upper, scope)
}
/// Builder for the `MatrixDeterminant` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDeterminant {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixDeterminant {
    /// Creates a new `MatrixDeterminant`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixDeterminant` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixDeterminant", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixDeterminant::new().build(input, scope)`.
pub fn matrix_determinant<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixDeterminant::new().build(input, scope)
}
/// Builder for the `MatrixDiag` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiag {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixDiag {
    /// Creates a new `MatrixDiag`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixDiag` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        diagonal: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(diagonal.into(), scope)
    }

    fn build_impl(
        &self,
        diagonal: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixDiag", |nd| {
            nd.add_input(diagonal);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixDiag::new().build(diagonal, scope)`.
pub fn matrix_diag<O0: ::std::convert::Into<crate::Output>>(
    diagonal: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixDiag::new().build(diagonal, scope)
}
/// Builder for the `MatrixDiagPart` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagPart {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixDiagPart {
    /// Creates a new `MatrixDiagPart`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixDiagPart` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixDiagPart", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixDiagPart::new().build(input, scope)`.
pub fn matrix_diag_part<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixDiagPart::new().build(input, scope)
}
/// Builder for the `MatrixDiagPartV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagPartV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixDiagPartV2 {
    /// Creates a new `MatrixDiagPartV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixDiagPartV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        k: O1,
        padding_value: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), k.into(), padding_value.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        k: crate::Output,
        padding_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixDiagPartV2", |nd| {
            nd.add_input(input);
            nd.add_input(k);
            nd.add_input(padding_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixDiagPartV2::new().build(input, k, padding_value, scope)`.
pub fn matrix_diag_part_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    k: O1,
    padding_value: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixDiagPartV2::new().build(input, k, padding_value, scope)
}
/// Builder for the `MatrixDiagPartV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagPartV3 {
    T: ::std::option::Option<crate::DataType>,
    align: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixDiagPartV3 {
    /// Creates a new `MatrixDiagPartV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align` attribute.
    pub fn align<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.align = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixDiagPartV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        k: O1,
        padding_value: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), k.into(), padding_value.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        k: crate::Output,
        padding_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixDiagPartV3", |nd| {
            nd.add_input(input);
            nd.add_input(k);
            nd.add_input(padding_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align {
                nd.set_attr_string("align", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixDiagPartV3::new().build(input, k, padding_value, scope)`.
pub fn matrix_diag_part_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    k: O1,
    padding_value: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixDiagPartV3::new().build(input, k, padding_value, scope)
}
/// Builder for the `MatrixDiagV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixDiagV2 {
    /// Creates a new `MatrixDiagV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixDiagV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        diagonal: O0,
        k: O1,
        num_rows: O2,
        num_cols: O3,
        padding_value: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            diagonal.into(),
            k.into(),
            num_rows.into(),
            num_cols.into(),
            padding_value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        diagonal: crate::Output,
        k: crate::Output,
        num_rows: crate::Output,
        num_cols: crate::Output,
        padding_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixDiagV2", |nd| {
            nd.add_input(diagonal);
            nd.add_input(k);
            nd.add_input(num_rows);
            nd.add_input(num_cols);
            nd.add_input(padding_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixDiagV2::new().build(diagonal, k, num_rows, num_cols, padding_value, scope)`.
pub fn matrix_diag_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    diagonal: O0,
    k: O1,
    num_rows: O2,
    num_cols: O3,
    padding_value: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixDiagV2::new().build(diagonal, k, num_rows, num_cols, padding_value, scope)
}
/// Builder for the `MatrixDiagV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixDiagV3 {
    T: ::std::option::Option<crate::DataType>,
    align: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixDiagV3 {
    /// Creates a new `MatrixDiagV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align` attribute.
    pub fn align<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.align = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixDiagV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        diagonal: O0,
        k: O1,
        num_rows: O2,
        num_cols: O3,
        padding_value: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            diagonal.into(),
            k.into(),
            num_rows.into(),
            num_cols.into(),
            padding_value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        diagonal: crate::Output,
        k: crate::Output,
        num_rows: crate::Output,
        num_cols: crate::Output,
        padding_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixDiagV3", |nd| {
            nd.add_input(diagonal);
            nd.add_input(k);
            nd.add_input(num_rows);
            nd.add_input(num_cols);
            nd.add_input(padding_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align {
                nd.set_attr_string("align", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixDiagV3::new().build(diagonal, k, num_rows, num_cols, padding_value, scope)`.
pub fn matrix_diag_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    diagonal: O0,
    k: O1,
    num_rows: O2,
    num_cols: O3,
    padding_value: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixDiagV3::new().build(diagonal, k, num_rows, num_cols, padding_value, scope)
}
/// Builder for the `MatrixExponential` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixExponential {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixExponential {
    /// Creates a new `MatrixExponential`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixExponential` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixExponential", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixExponential::new().build(input, scope)`.
pub fn matrix_exponential<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixExponential::new().build(input, scope)
}
/// Builder for the `MatrixInverse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixInverse {
    adjoint: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixInverse {
    /// Creates a new `MatrixInverse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `adjoint` attribute.
    pub fn adjoint<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixInverse` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixInverse", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.adjoint {
                nd.set_attr_bool("adjoint", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixInverse::new().build(input, scope)`.
pub fn matrix_inverse<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixInverse::new().build(input, scope)
}
/// Builder for the `MatrixLogarithm` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixLogarithm {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixLogarithm {
    /// Creates a new `MatrixLogarithm`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixLogarithm` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixLogarithm", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixLogarithm::new().build(input, scope)`.
pub fn matrix_logarithm<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixLogarithm::new().build(input, scope)
}
/// Builder for the `MatrixSetDiag` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSetDiag {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixSetDiag {
    /// Creates a new `MatrixSetDiag`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixSetDiag` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        diagonal: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), diagonal.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        diagonal: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixSetDiag", |nd| {
            nd.add_input(input);
            nd.add_input(diagonal);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixSetDiag::new().build(input, diagonal, scope)`.
pub fn matrix_set_diag<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    diagonal: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixSetDiag::new().build(input, diagonal, scope)
}
/// Builder for the `MatrixSetDiagV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSetDiagV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixSetDiagV2 {
    /// Creates a new `MatrixSetDiagV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixSetDiagV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        diagonal: O1,
        k: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), diagonal.into(), k.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        diagonal: crate::Output,
        k: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixSetDiagV2", |nd| {
            nd.add_input(input);
            nd.add_input(diagonal);
            nd.add_input(k);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixSetDiagV2::new().build(input, diagonal, k, scope)`.
pub fn matrix_set_diag_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    diagonal: O1,
    k: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixSetDiagV2::new().build(input, diagonal, k, scope)
}
/// Builder for the `MatrixSetDiagV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSetDiagV3 {
    T: ::std::option::Option<crate::DataType>,
    align: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixSetDiagV3 {
    /// Creates a new `MatrixSetDiagV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align` attribute.
    pub fn align<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.align = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixSetDiagV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        diagonal: O1,
        k: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), diagonal.into(), k.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        diagonal: crate::Output,
        k: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixSetDiagV3", |nd| {
            nd.add_input(input);
            nd.add_input(diagonal);
            nd.add_input(k);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align {
                nd.set_attr_string("align", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixSetDiagV3::new().build(input, diagonal, k, scope)`.
pub fn matrix_set_diag_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    diagonal: O1,
    k: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixSetDiagV3::new().build(input, diagonal, k, scope)
}
/// Builder for the `MatrixSolve` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSolve {
    adjoint: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixSolve {
    /// Creates a new `MatrixSolve`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `adjoint` attribute.
    pub fn adjoint<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixSolve` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        matrix: O0,
        rhs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(matrix.into(), rhs.into(), scope)
    }

    fn build_impl(
        &self,
        matrix: crate::Output,
        rhs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixSolve", |nd| {
            nd.add_input(matrix);
            nd.add_input(rhs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.adjoint {
                nd.set_attr_bool("adjoint", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixSolve::new().build(matrix, rhs, scope)`.
pub fn matrix_solve<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    matrix: O0,
    rhs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixSolve::new().build(matrix, rhs, scope)
}
/// Builder for the `MatrixSolveLs` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSolveLs {
    T: ::std::option::Option<crate::DataType>,
    fast: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixSolveLs {
    /// Creates a new `MatrixSolveLs`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fast` attribute.
    pub fn fast<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.fast = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixSolveLs` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        matrix: O0,
        rhs: O1,
        l2_regularizer: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(matrix.into(), rhs.into(), l2_regularizer.into(), scope)
    }

    fn build_impl(
        &self,
        matrix: crate::Output,
        rhs: crate::Output,
        l2_regularizer: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixSolveLs", |nd| {
            nd.add_input(matrix);
            nd.add_input(rhs);
            nd.add_input(l2_regularizer);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fast {
                nd.set_attr_bool("fast", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixSolveLs::new().build(matrix, rhs, l2_regularizer, scope)`.
pub fn matrix_solve_ls<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    matrix: O0,
    rhs: O1,
    l2_regularizer: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixSolveLs::new().build(matrix, rhs, l2_regularizer, scope)
}
/// Builder for the `MatrixSquareRoot` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixSquareRoot {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixSquareRoot {
    /// Creates a new `MatrixSquareRoot`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixSquareRoot` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixSquareRoot", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixSquareRoot::new().build(input, scope)`.
pub fn matrix_square_root<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixSquareRoot::new().build(input, scope)
}
/// Builder for the `MatrixTriangularSolve` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MatrixTriangularSolve {
    lower: ::std::option::Option<bool>,
    adjoint: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MatrixTriangularSolve {
    /// Creates a new `MatrixTriangularSolve`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `lower` attribute.
    pub fn lower<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.lower = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint` attribute.
    pub fn adjoint<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MatrixTriangularSolve` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        matrix: O0,
        rhs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(matrix.into(), rhs.into(), scope)
    }

    fn build_impl(
        &self,
        matrix: crate::Output,
        rhs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MatrixTriangularSolve", |nd| {
            nd.add_input(matrix);
            nd.add_input(rhs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.lower {
                nd.set_attr_bool("lower", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint {
                nd.set_attr_bool("adjoint", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MatrixTriangularSolve::new().build(matrix, rhs, scope)`.
pub fn matrix_triangular_solve<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    matrix: O0,
    rhs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MatrixTriangularSolve::new().build(matrix, rhs, scope)
}
/// Builder for the `Max` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Max {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Max {
    /// Creates a new `Max`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Max` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Max", |nd| {
            nd.add_input(input);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Max::new().build(input, reduction_indices, scope)`.
pub fn max<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Max::new().build(input, reduction_indices, scope)
}
/// Builder for the `MaxIntraOpParallelismDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxIntraOpParallelismDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxIntraOpParallelismDataset {
    /// Creates a new `MaxIntraOpParallelismDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxIntraOpParallelismDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        max_intra_op_parallelism: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), max_intra_op_parallelism.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        max_intra_op_parallelism: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxIntraOpParallelismDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(max_intra_op_parallelism);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxIntraOpParallelismDataset::new().build(input_dataset, max_intra_op_parallelism, scope)`.
pub fn max_intra_op_parallelism_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    max_intra_op_parallelism: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxIntraOpParallelismDataset::new().build(input_dataset, max_intra_op_parallelism, scope)
}
/// Builder for the `MaxPool` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPool {
    T: ::std::option::Option<crate::DataType>,
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPool {
    /// Creates a new `MaxPool`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPool` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPool", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPool::new().build(input, scope)`.
pub fn max_pool<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPool::new().build(input, scope)
}
/// Builder for the `MaxPool3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPool3D {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPool3D {
    /// Creates a new `MaxPool3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPool3D` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPool3D", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPool3D::new().build(input, scope)`.
pub fn max_pool3_d<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPool3D::new().build(input, scope)
}
/// Builder for the `MaxPool3DGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPool3DGrad {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    TInput: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPool3DGrad {
    /// Creates a new `MaxPool3DGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `TInput` attribute.
    pub fn TInput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.TInput = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPool3DGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input: O0,
        orig_output: O1,
        grad: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(orig_input.into(), orig_output.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        orig_input: crate::Output,
        orig_output: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPool3DGrad", |nd| {
            nd.add_input(orig_input);
            nd.add_input(orig_output);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.TInput {
                nd.set_attr_type("TInput", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPool3DGrad::new().build(orig_input, orig_output, grad, scope)`.
pub fn max_pool3_dgrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    orig_input: O0,
    orig_output: O1,
    grad: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPool3DGrad::new().build(orig_input, orig_output, grad, scope)
}
/// Builder for the `MaxPool3DGradGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPool3DGradGrad {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPool3DGradGrad {
    /// Creates a new `MaxPool3DGradGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPool3DGradGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input: O0,
        orig_output: O1,
        grad: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(orig_input.into(), orig_output.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        orig_input: crate::Output,
        orig_output: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPool3DGradGrad", |nd| {
            nd.add_input(orig_input);
            nd.add_input(orig_output);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPool3DGradGrad::new().build(orig_input, orig_output, grad, scope)`.
pub fn max_pool3_dgrad_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    orig_input: O0,
    orig_output: O1,
    grad: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPool3DGradGrad::new().build(orig_input, orig_output, grad, scope)
}
/// Builder for the `MaxPoolGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGrad {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPoolGrad {
    /// Creates a new `MaxPoolGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPoolGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input: O0,
        orig_output: O1,
        grad: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(orig_input.into(), orig_output.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        orig_input: crate::Output,
        orig_output: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPoolGrad", |nd| {
            nd.add_input(orig_input);
            nd.add_input(orig_output);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPoolGrad::new().build(orig_input, orig_output, grad, scope)`.
pub fn max_pool_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    orig_input: O0,
    orig_output: O1,
    grad: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPoolGrad::new().build(orig_input, orig_output, grad, scope)
}
/// Builder for the `MaxPoolGradGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradGrad {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPoolGradGrad {
    /// Creates a new `MaxPoolGradGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPoolGradGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input: O0,
        orig_output: O1,
        grad: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(orig_input.into(), orig_output.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        orig_input: crate::Output,
        orig_output: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPoolGradGrad", |nd| {
            nd.add_input(orig_input);
            nd.add_input(orig_output);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPoolGradGrad::new().build(orig_input, orig_output, grad, scope)`.
pub fn max_pool_grad_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    orig_input: O0,
    orig_output: O1,
    grad: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPoolGradGrad::new().build(orig_input, orig_output, grad, scope)
}
/// Builder for the `MaxPoolGradGradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradGradV2 {
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPoolGradGradV2 {
    /// Creates a new `MaxPoolGradGradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPoolGradGradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input: O0,
        orig_output: O1,
        grad: O2,
        ksize: O3,
        strides: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            orig_input.into(),
            orig_output.into(),
            grad.into(),
            ksize.into(),
            strides.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        orig_input: crate::Output,
        orig_output: crate::Output,
        grad: crate::Output,
        ksize: crate::Output,
        strides: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPoolGradGradV2", |nd| {
            nd.add_input(orig_input);
            nd.add_input(orig_output);
            nd.add_input(grad);
            nd.add_input(ksize);
            nd.add_input(strides);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPoolGradGradV2::new().build(orig_input, orig_output, grad, ksize, strides, scope)`.
pub fn max_pool_grad_grad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    orig_input: O0,
    orig_output: O1,
    grad: O2,
    ksize: O3,
    strides: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPoolGradGradV2::new().build(orig_input, orig_output, grad, ksize, strides, scope)
}
/// Builder for the `MaxPoolGradGradWithArgmax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradGradWithArgmax {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    include_batch_in_index: ::std::option::Option<bool>,
    Targmax: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPoolGradGradWithArgmax {
    /// Creates a new `MaxPoolGradGradWithArgmax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `include_batch_in_index` attribute.
    pub fn include_batch_in_index<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.include_batch_in_index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targmax` attribute.
    pub fn Targmax<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targmax = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPoolGradGradWithArgmax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        grad: O1,
        argmax: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), grad.into(), argmax.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        grad: crate::Output,
        argmax: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPoolGradGradWithArgmax", |nd| {
            nd.add_input(input);
            nd.add_input(grad);
            nd.add_input(argmax);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.include_batch_in_index {
                nd.set_attr_bool("include_batch_in_index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targmax {
                nd.set_attr_type("Targmax", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPoolGradGradWithArgmax::new().build(input, grad, argmax, scope)`.
pub fn max_pool_grad_grad_with_argmax<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    grad: O1,
    argmax: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPoolGradGradWithArgmax::new().build(input, grad, argmax, scope)
}
/// Builder for the `MaxPoolGradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradV2 {
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPoolGradV2 {
    /// Creates a new `MaxPoolGradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPoolGradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        orig_input: O0,
        orig_output: O1,
        grad: O2,
        ksize: O3,
        strides: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            orig_input.into(),
            orig_output.into(),
            grad.into(),
            ksize.into(),
            strides.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        orig_input: crate::Output,
        orig_output: crate::Output,
        grad: crate::Output,
        ksize: crate::Output,
        strides: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPoolGradV2", |nd| {
            nd.add_input(orig_input);
            nd.add_input(orig_output);
            nd.add_input(grad);
            nd.add_input(ksize);
            nd.add_input(strides);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPoolGradV2::new().build(orig_input, orig_output, grad, ksize, strides, scope)`.
pub fn max_pool_grad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    orig_input: O0,
    orig_output: O1,
    grad: O2,
    ksize: O3,
    strides: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPoolGradV2::new().build(orig_input, orig_output, grad, ksize, strides, scope)
}
/// Builder for the `MaxPoolGradWithArgmax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolGradWithArgmax {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    include_batch_in_index: ::std::option::Option<bool>,
    Targmax: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPoolGradWithArgmax {
    /// Creates a new `MaxPoolGradWithArgmax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `include_batch_in_index` attribute.
    pub fn include_batch_in_index<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.include_batch_in_index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targmax` attribute.
    pub fn Targmax<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targmax = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPoolGradWithArgmax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        grad: O1,
        argmax: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), grad.into(), argmax.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        grad: crate::Output,
        argmax: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPoolGradWithArgmax", |nd| {
            nd.add_input(input);
            nd.add_input(grad);
            nd.add_input(argmax);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.include_batch_in_index {
                nd.set_attr_bool("include_batch_in_index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targmax {
                nd.set_attr_type("Targmax", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPoolGradWithArgmax::new().build(input, grad, argmax, scope)`.
pub fn max_pool_grad_with_argmax<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    grad: O1,
    argmax: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPoolGradWithArgmax::new().build(input, grad, argmax, scope)
}
/// Builder for the `MaxPoolV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolV2 {
    T: ::std::option::Option<crate::DataType>,
    padding: ::std::option::Option<::std::string::String>,
    data_format: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPoolV2 {
    /// Creates a new `MaxPoolV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPoolV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        ksize: O1,
        strides: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), ksize.into(), strides.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        ksize: crate::Output,
        strides: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPoolV2", |nd| {
            nd.add_input(input);
            nd.add_input(ksize);
            nd.add_input(strides);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPoolV2::new().build(input, ksize, strides, scope)`.
pub fn max_pool_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    ksize: O1,
    strides: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPoolV2::new().build(input, ksize, strides, scope)
}
/// Builder for the `MaxPoolWithArgmax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MaxPoolWithArgmax {
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    Targmax: ::std::option::Option<crate::DataType>,
    padding: ::std::option::Option<::std::string::String>,
    include_batch_in_index: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MaxPoolWithArgmax {
    /// Creates a new `MaxPoolWithArgmax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targmax` attribute.
    pub fn Targmax<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targmax = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `include_batch_in_index` attribute.
    pub fn include_batch_in_index<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.include_batch_in_index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MaxPoolWithArgmax` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MaxPoolWithArgmax", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targmax {
                nd.set_attr_type("Targmax", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.include_batch_in_index {
                nd.set_attr_bool("include_batch_in_index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MaxPoolWithArgmax::new().build(input, scope)`.
pub fn max_pool_with_argmax<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MaxPoolWithArgmax::new().build(input, scope)
}
/// Builder for the `Maximum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Maximum {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Maximum {
    /// Creates a new `Maximum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Maximum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Maximum", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Maximum::new().build(x, y, scope)`.
pub fn maximum<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Maximum::new().build(x, y, scope)
}
/// Builder for the `Mean` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Mean {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Mean {
    /// Creates a new `Mean`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Mean` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Mean", |nd| {
            nd.add_input(input);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Mean::new().build(input, reduction_indices, scope)`.
pub fn mean<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Mean::new().build(input, reduction_indices, scope)
}
/// Builder for the `Merge` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Merge {
    T: ::std::option::Option<crate::DataType>,
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Merge {
    /// Creates a new `Merge`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Merge` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Merge", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Merge::new().build(inputs, scope)`.
pub fn merge<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Merge::new().build(inputs, scope)
}
/// Builder for the `MergeSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MergeSummary {
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MergeSummary {
    /// Creates a new `MergeSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MergeSummary` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MergeSummary", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MergeSummary::new().build(inputs, scope)`.
pub fn merge_summary<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MergeSummary::new().build(inputs, scope)
}
/// Builder for the `MergeV2Checkpoints` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MergeV2Checkpoints {
    delete_old_dirs: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MergeV2Checkpoints {
    /// Creates a new `MergeV2Checkpoints`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `delete_old_dirs` attribute.
    pub fn delete_old_dirs<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.delete_old_dirs = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MergeV2Checkpoints` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        checkpoint_prefixes: O0,
        destination_prefix: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(checkpoint_prefixes.into(), destination_prefix.into(), scope)
    }

    fn build_impl(
        &self,
        checkpoint_prefixes: crate::Output,
        destination_prefix: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MergeV2Checkpoints", |nd| {
            nd.add_input(checkpoint_prefixes);
            nd.add_input(destination_prefix);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.delete_old_dirs {
                nd.set_attr_bool("delete_old_dirs", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MergeV2Checkpoints::new().build(checkpoint_prefixes, destination_prefix, scope)`.
pub fn merge_v2_checkpoints<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    checkpoint_prefixes: O0,
    destination_prefix: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MergeV2Checkpoints::new().build(checkpoint_prefixes, destination_prefix, scope)
}
/// Builder for the `Mfcc` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Mfcc {
    upper_frequency_limit: ::std::option::Option<f32>,
    lower_frequency_limit: ::std::option::Option<f32>,
    filterbank_channel_count: ::std::option::Option<i64>,
    dct_coefficient_count: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Mfcc {
    /// Creates a new `Mfcc`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `upper_frequency_limit` attribute.
    pub fn upper_frequency_limit<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.upper_frequency_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `lower_frequency_limit` attribute.
    pub fn lower_frequency_limit<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.lower_frequency_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `filterbank_channel_count` attribute.
    pub fn filterbank_channel_count<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.filterbank_channel_count = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dct_coefficient_count` attribute.
    pub fn dct_coefficient_count<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dct_coefficient_count = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Mfcc` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        spectrogram: O0,
        sample_rate: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(spectrogram.into(), sample_rate.into(), scope)
    }

    fn build_impl(
        &self,
        spectrogram: crate::Output,
        sample_rate: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Mfcc", |nd| {
            nd.add_input(spectrogram);
            nd.add_input(sample_rate);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.upper_frequency_limit {
                nd.set_attr_float("upper_frequency_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.lower_frequency_limit {
                nd.set_attr_float("lower_frequency_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.filterbank_channel_count {
                nd.set_attr_int("filterbank_channel_count", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dct_coefficient_count {
                nd.set_attr_int("dct_coefficient_count", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Mfcc::new().build(spectrogram, sample_rate, scope)`.
pub fn mfcc<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    spectrogram: O0,
    sample_rate: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Mfcc::new().build(spectrogram, sample_rate, scope)
}
/// Builder for the `Min` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Min {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Min {
    /// Creates a new `Min`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Min` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Min", |nd| {
            nd.add_input(input);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Min::new().build(input, reduction_indices, scope)`.
pub fn min<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Min::new().build(input, reduction_indices, scope)
}
/// Builder for the `Minimum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Minimum {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Minimum {
    /// Creates a new `Minimum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Minimum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Minimum", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Minimum::new().build(x, y, scope)`.
pub fn minimum<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Minimum::new().build(x, y, scope)
}
/// Builder for the `MirrorPad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MirrorPad {
    T: ::std::option::Option<crate::DataType>,
    Tpaddings: ::std::option::Option<crate::DataType>,
    mode: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MirrorPad {
    /// Creates a new `MirrorPad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tpaddings` attribute.
    pub fn Tpaddings<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tpaddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `mode` attribute.
    pub fn mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MirrorPad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        paddings: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), paddings.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        paddings: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MirrorPad", |nd| {
            nd.add_input(input);
            nd.add_input(paddings);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tpaddings {
                nd.set_attr_type("Tpaddings", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.mode {
                nd.set_attr_string("mode", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MirrorPad::new().build(input, paddings, scope)`.
pub fn mirror_pad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    paddings: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MirrorPad::new().build(input, paddings, scope)
}
/// Builder for the `MirrorPadGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MirrorPadGrad {
    T: ::std::option::Option<crate::DataType>,
    Tpaddings: ::std::option::Option<crate::DataType>,
    mode: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MirrorPadGrad {
    /// Creates a new `MirrorPadGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tpaddings` attribute.
    pub fn Tpaddings<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tpaddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `mode` attribute.
    pub fn mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MirrorPadGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        paddings: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), paddings.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        paddings: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MirrorPadGrad", |nd| {
            nd.add_input(input);
            nd.add_input(paddings);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tpaddings {
                nd.set_attr_type("Tpaddings", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.mode {
                nd.set_attr_string("mode", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MirrorPadGrad::new().build(input, paddings, scope)`.
pub fn mirror_pad_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    paddings: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MirrorPadGrad::new().build(input, paddings, scope)
}
/// Builder for the `MlirPassthroughOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MlirPassthroughOp {
    mlir_module: ::std::option::Option<::std::string::String>,
    Tinputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Toutputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MlirPassthroughOp {
    /// Creates a new `MlirPassthroughOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `mlir_module` attribute.
    pub fn mlir_module<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.mlir_module = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tinputs` attribute.
    pub fn Tinputs<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutputs` attribute.
    pub fn Toutputs<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MlirPassthroughOp` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MlirPassthroughOp", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.mlir_module {
                nd.set_attr_string("mlir_module", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tinputs {
                nd.set_attr_type_list("Tinputs", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutputs {
                nd.set_attr_type_list("Toutputs", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MlirPassthroughOp::new().build(inputs, scope)`.
pub fn mlir_passthrough_op<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MlirPassthroughOp::new().build(inputs, scope)
}
/// Builder for the `Mod` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Mod {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Mod {
    /// Creates a new `Mod`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Mod` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Mod", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Mod::new().build(x, y, scope)`.
pub fn mod_<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Mod::new().build(x, y, scope)
}
/// Builder for the `ModelDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ModelDataset {
    algorithm: ::std::option::Option<i64>,
    cpu_budget: ::std::option::Option<i64>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ModelDataset {
    /// Creates a new `ModelDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `algorithm` attribute.
    pub fn algorithm<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.algorithm = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `cpu_budget` attribute.
    pub fn cpu_budget<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.cpu_budget = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ModelDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ModelDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.algorithm {
                nd.set_attr_int("algorithm", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.cpu_budget {
                nd.set_attr_int("cpu_budget", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ModelDataset::new().build(input_dataset, scope)`.
pub fn model_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ModelDataset::new().build(input_dataset, scope)
}
/// Builder for the `Mul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Mul {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Mul {
    /// Creates a new `Mul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Mul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Mul", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Mul::new().build(x, y, scope)`.
pub fn mul<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Mul::new().build(x, y, scope)
}
/// Builder for the `MulNoNan` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MulNoNan {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MulNoNan {
    /// Creates a new `MulNoNan`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MulNoNan` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MulNoNan", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MulNoNan::new().build(x, y, scope)`.
pub fn mul_no_nan<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MulNoNan::new().build(x, y, scope)
}
/// Builder for the `MultiDeviceIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIterator {
    devices: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    shared_name: ::std::option::Option<::std::string::String>,
    container: ::std::option::Option<::std::string::String>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MultiDeviceIterator {
    /// Creates a new `MultiDeviceIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `devices` attribute.
    pub fn devices<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.devices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MultiDeviceIterator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MultiDeviceIterator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.devices {
                nd.set_attr_string_list("devices", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MultiDeviceIterator::new().build(scope)`.
pub fn multi_device_iterator(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    MultiDeviceIterator::new().build(scope)
}
/// Builder for the `MultiDeviceIteratorFromStringHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIteratorFromStringHandle {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MultiDeviceIteratorFromStringHandle {
    /// Creates a new `MultiDeviceIteratorFromStringHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MultiDeviceIteratorFromStringHandle` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        string_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(string_handle.into(), scope)
    }

    fn build_impl(
        &self,
        string_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MultiDeviceIteratorFromStringHandle", |nd| {
            nd.add_input(string_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MultiDeviceIteratorFromStringHandle::new().build(string_handle, scope)`.
pub fn multi_device_iterator_from_string_handle<O0: ::std::convert::Into<crate::Output>>(
    string_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MultiDeviceIteratorFromStringHandle::new().build(string_handle, scope)
}
/// Builder for the `MultiDeviceIteratorGetNextFromShard` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIteratorGetNextFromShard {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MultiDeviceIteratorGetNextFromShard {
    /// Creates a new `MultiDeviceIteratorGetNextFromShard`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MultiDeviceIteratorGetNextFromShard` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        multi_device_iterator: O0,
        shard_num: O1,
        incarnation_id: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            multi_device_iterator.into(),
            shard_num.into(),
            incarnation_id.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        multi_device_iterator: crate::Output,
        shard_num: crate::Output,
        incarnation_id: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MultiDeviceIteratorGetNextFromShard", |nd| {
            nd.add_input(multi_device_iterator);
            nd.add_input(shard_num);
            nd.add_input(incarnation_id);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MultiDeviceIteratorGetNextFromShard::new().build(multi_device_iterator, shard_num, incarnation_id, scope)`.
pub fn multi_device_iterator_get_next_from_shard<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    multi_device_iterator: O0,
    shard_num: O1,
    incarnation_id: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MultiDeviceIteratorGetNextFromShard::new().build(
        multi_device_iterator,
        shard_num,
        incarnation_id,
        scope,
    )
}
/// Builder for the `MultiDeviceIteratorInit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIteratorInit {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MultiDeviceIteratorInit {
    /// Creates a new `MultiDeviceIteratorInit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MultiDeviceIteratorInit` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        dataset: O0,
        multi_device_iterator: O1,
        max_buffer_size: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            dataset.into(),
            multi_device_iterator.into(),
            max_buffer_size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        dataset: crate::Output,
        multi_device_iterator: crate::Output,
        max_buffer_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MultiDeviceIteratorInit", |nd| {
            nd.add_input(dataset);
            nd.add_input(multi_device_iterator);
            nd.add_input(max_buffer_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MultiDeviceIteratorInit::new().build(dataset, multi_device_iterator, max_buffer_size, scope)`.
pub fn multi_device_iterator_init<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    dataset: O0,
    multi_device_iterator: O1,
    max_buffer_size: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MultiDeviceIteratorInit::new().build(dataset, multi_device_iterator, max_buffer_size, scope)
}
/// Builder for the `MultiDeviceIteratorToStringHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MultiDeviceIteratorToStringHandle {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MultiDeviceIteratorToStringHandle {
    /// Creates a new `MultiDeviceIteratorToStringHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MultiDeviceIteratorToStringHandle` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        multi_device_iterator: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(multi_device_iterator.into(), scope)
    }

    fn build_impl(
        &self,
        multi_device_iterator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MultiDeviceIteratorToStringHandle", |nd| {
            nd.add_input(multi_device_iterator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MultiDeviceIteratorToStringHandle::new().build(multi_device_iterator, scope)`.
pub fn multi_device_iterator_to_string_handle<O0: ::std::convert::Into<crate::Output>>(
    multi_device_iterator: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MultiDeviceIteratorToStringHandle::new().build(multi_device_iterator, scope)
}
/// Builder for the `Multinomial` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Multinomial {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    output_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Multinomial {
    /// Creates a new `Multinomial`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_dtype` attribute.
    pub fn output_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Multinomial` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        logits: O0,
        num_samples: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(logits.into(), num_samples.into(), scope)
    }

    fn build_impl(
        &self,
        logits: crate::Output,
        num_samples: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Multinomial", |nd| {
            nd.add_input(logits);
            nd.add_input(num_samples);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_dtype {
                nd.set_attr_type("output_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Multinomial::new().build(logits, num_samples, scope)`.
pub fn multinomial<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    logits: O0,
    num_samples: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Multinomial::new().build(logits, num_samples, scope)
}
/// Builder for the `MutableDenseHashTable` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableDenseHashTable {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    use_node_name_sharing: ::std::option::Option<bool>,
    key_dtype: ::std::option::Option<crate::DataType>,
    value_dtype: ::std::option::Option<crate::DataType>,
    value_shape: ::std::option::Option<crate::Shape>,
    initial_num_buckets: ::std::option::Option<i64>,
    max_load_factor: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MutableDenseHashTable {
    /// Creates a new `MutableDenseHashTable`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_node_name_sharing` attribute.
    pub fn use_node_name_sharing<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_node_name_sharing = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key_dtype` attribute.
    pub fn key_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_dtype` attribute.
    pub fn value_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_shape` attribute.
    pub fn value_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `initial_num_buckets` attribute.
    pub fn initial_num_buckets<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.initial_num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_load_factor` attribute.
    pub fn max_load_factor<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.max_load_factor = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MutableDenseHashTable` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        empty_key: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(empty_key.into(), scope)
    }

    fn build_impl(
        &self,
        empty_key: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MutableDenseHashTable", |nd| {
            nd.add_input(empty_key);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_node_name_sharing {
                nd.set_attr_bool("use_node_name_sharing", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key_dtype {
                nd.set_attr_type("key_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_dtype {
                nd.set_attr_type("value_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_shape {
                nd.set_attr_shape("value_shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.initial_num_buckets {
                nd.set_attr_int("initial_num_buckets", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_load_factor {
                nd.set_attr_float("max_load_factor", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MutableDenseHashTable::new().build(empty_key, scope)`.
pub fn mutable_dense_hash_table<O0: ::std::convert::Into<crate::Output>>(
    empty_key: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MutableDenseHashTable::new().build(empty_key, scope)
}
/// Builder for the `MutableDenseHashTableV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableDenseHashTableV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    use_node_name_sharing: ::std::option::Option<bool>,
    key_dtype: ::std::option::Option<crate::DataType>,
    value_dtype: ::std::option::Option<crate::DataType>,
    value_shape: ::std::option::Option<crate::Shape>,
    initial_num_buckets: ::std::option::Option<i64>,
    max_load_factor: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MutableDenseHashTableV2 {
    /// Creates a new `MutableDenseHashTableV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_node_name_sharing` attribute.
    pub fn use_node_name_sharing<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_node_name_sharing = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key_dtype` attribute.
    pub fn key_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_dtype` attribute.
    pub fn value_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_shape` attribute.
    pub fn value_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `initial_num_buckets` attribute.
    pub fn initial_num_buckets<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.initial_num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_load_factor` attribute.
    pub fn max_load_factor<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.max_load_factor = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MutableDenseHashTableV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        empty_key: O0,
        deleted_key: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(empty_key.into(), deleted_key.into(), scope)
    }

    fn build_impl(
        &self,
        empty_key: crate::Output,
        deleted_key: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MutableDenseHashTableV2", |nd| {
            nd.add_input(empty_key);
            nd.add_input(deleted_key);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_node_name_sharing {
                nd.set_attr_bool("use_node_name_sharing", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key_dtype {
                nd.set_attr_type("key_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_dtype {
                nd.set_attr_type("value_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_shape {
                nd.set_attr_shape("value_shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.initial_num_buckets {
                nd.set_attr_int("initial_num_buckets", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_load_factor {
                nd.set_attr_float("max_load_factor", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MutableDenseHashTableV2::new().build(empty_key, deleted_key, scope)`.
pub fn mutable_dense_hash_table_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    empty_key: O0,
    deleted_key: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MutableDenseHashTableV2::new().build(empty_key, deleted_key, scope)
}
/// Builder for the `MutableHashTable` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableHashTable {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    use_node_name_sharing: ::std::option::Option<bool>,
    key_dtype: ::std::option::Option<crate::DataType>,
    value_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MutableHashTable {
    /// Creates a new `MutableHashTable`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_node_name_sharing` attribute.
    pub fn use_node_name_sharing<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_node_name_sharing = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key_dtype` attribute.
    pub fn key_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_dtype` attribute.
    pub fn value_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MutableHashTable` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MutableHashTable", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_node_name_sharing {
                nd.set_attr_bool("use_node_name_sharing", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key_dtype {
                nd.set_attr_type("key_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_dtype {
                nd.set_attr_type("value_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MutableHashTable::new().build(scope)`.
pub fn mutable_hash_table(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    MutableHashTable::new().build(scope)
}
/// Builder for the `MutableHashTableOfTensors` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableHashTableOfTensors {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    use_node_name_sharing: ::std::option::Option<bool>,
    key_dtype: ::std::option::Option<crate::DataType>,
    value_dtype: ::std::option::Option<crate::DataType>,
    value_shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MutableHashTableOfTensors {
    /// Creates a new `MutableHashTableOfTensors`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_node_name_sharing` attribute.
    pub fn use_node_name_sharing<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_node_name_sharing = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key_dtype` attribute.
    pub fn key_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_dtype` attribute.
    pub fn value_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_shape` attribute.
    pub fn value_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MutableHashTableOfTensors` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MutableHashTableOfTensors", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_node_name_sharing {
                nd.set_attr_bool("use_node_name_sharing", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key_dtype {
                nd.set_attr_type("key_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_dtype {
                nd.set_attr_type("value_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_shape {
                nd.set_attr_shape("value_shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MutableHashTableOfTensors::new().build(scope)`.
pub fn mutable_hash_table_of_tensors(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    MutableHashTableOfTensors::new().build(scope)
}
/// Builder for the `MutableHashTableOfTensorsV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableHashTableOfTensorsV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    use_node_name_sharing: ::std::option::Option<bool>,
    key_dtype: ::std::option::Option<crate::DataType>,
    value_dtype: ::std::option::Option<crate::DataType>,
    value_shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MutableHashTableOfTensorsV2 {
    /// Creates a new `MutableHashTableOfTensorsV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_node_name_sharing` attribute.
    pub fn use_node_name_sharing<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_node_name_sharing = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key_dtype` attribute.
    pub fn key_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_dtype` attribute.
    pub fn value_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_shape` attribute.
    pub fn value_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MutableHashTableOfTensorsV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MutableHashTableOfTensorsV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_node_name_sharing {
                nd.set_attr_bool("use_node_name_sharing", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key_dtype {
                nd.set_attr_type("key_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_dtype {
                nd.set_attr_type("value_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_shape {
                nd.set_attr_shape("value_shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MutableHashTableOfTensorsV2::new().build(scope)`.
pub fn mutable_hash_table_of_tensors_v2(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MutableHashTableOfTensorsV2::new().build(scope)
}
/// Builder for the `MutableHashTableV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutableHashTableV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    use_node_name_sharing: ::std::option::Option<bool>,
    key_dtype: ::std::option::Option<crate::DataType>,
    value_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MutableHashTableV2 {
    /// Creates a new `MutableHashTableV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_node_name_sharing` attribute.
    pub fn use_node_name_sharing<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_node_name_sharing = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key_dtype` attribute.
    pub fn key_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `value_dtype` attribute.
    pub fn value_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.value_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MutableHashTableV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MutableHashTableV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_node_name_sharing {
                nd.set_attr_bool("use_node_name_sharing", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key_dtype {
                nd.set_attr_type("key_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.value_dtype {
                nd.set_attr_type("value_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MutableHashTableV2::new().build(scope)`.
pub fn mutable_hash_table_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    MutableHashTableV2::new().build(scope)
}
/// Builder for the `MutexLock` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutexLock {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MutexLock {
    /// Creates a new `MutexLock`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MutexLock` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        mutex: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(mutex.into(), scope)
    }

    fn build_impl(
        &self,
        mutex: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("MutexLock", |nd| {
            nd.add_input(mutex);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MutexLock::new().build(mutex, scope)`.
pub fn mutex_lock<O0: ::std::convert::Into<crate::Output>>(
    mutex: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    MutexLock::new().build(mutex, scope)
}
/// Builder for the `MutexV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct MutexV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl MutexV2 {
    /// Creates a new `MutexV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `MutexV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("MutexV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `MutexV2::new().build(scope)`.
pub fn mutex_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    MutexV2::new().build(scope)
}
/// Builder for the `NcclAllReduce` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NcclAllReduce {
    reduction: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    num_devices: ::std::option::Option<i64>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NcclAllReduce {
    /// Creates a new `NcclAllReduce`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `reduction` attribute.
    pub fn reduction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_devices` attribute.
    pub fn num_devices<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_devices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NcclAllReduce` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NcclAllReduce", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.reduction {
                nd.set_attr_string("reduction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_devices {
                nd.set_attr_int("num_devices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NcclAllReduce::new().build(input, scope)`.
pub fn nccl_all_reduce<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NcclAllReduce::new().build(input, scope)
}
/// Builder for the `NcclBroadcast` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NcclBroadcast {
    T: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NcclBroadcast {
    /// Creates a new `NcclBroadcast`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NcclBroadcast` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NcclBroadcast", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NcclBroadcast::new().build(input, scope)`.
pub fn nccl_broadcast<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NcclBroadcast::new().build(input, scope)
}
/// Builder for the `NcclReduce` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NcclReduce {
    reduction: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    num_devices: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NcclReduce {
    /// Creates a new `NcclReduce`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `reduction` attribute.
    pub fn reduction<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduction = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_devices` attribute.
    pub fn num_devices<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_devices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NcclReduce` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NcclReduce", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.reduction {
                nd.set_attr_string("reduction", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_devices {
                nd.set_attr_int("num_devices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NcclReduce::new().build(input, scope)`.
pub fn nccl_reduce<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NcclReduce::new().build(input, scope)
}
/// Builder for the `Ndtri` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Ndtri {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Ndtri {
    /// Creates a new `Ndtri`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Ndtri` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Ndtri", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Ndtri::new().build(x, scope)`.
pub fn ndtri<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Ndtri::new().build(x, scope)
}
/// Builder for the `NearestNeighbors` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NearestNeighbors {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NearestNeighbors {
    /// Creates a new `NearestNeighbors`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NearestNeighbors` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        points: O0,
        centers: O1,
        k: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(points.into(), centers.into(), k.into(), scope)
    }

    fn build_impl(
        &self,
        points: crate::Output,
        centers: crate::Output,
        k: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NearestNeighbors", |nd| {
            nd.add_input(points);
            nd.add_input(centers);
            nd.add_input(k);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NearestNeighbors::new().build(points, centers, k, scope)`.
pub fn nearest_neighbors<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    points: O0,
    centers: O1,
    k: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NearestNeighbors::new().build(points, centers, k, scope)
}
/// Builder for the `Neg` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Neg {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Neg {
    /// Creates a new `Neg`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Neg` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Neg", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Neg::new().build(x, scope)`.
pub fn neg<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Neg::new().build(x, scope)
}
/// Builder for the `NegTrain` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NegTrain {
    vocab_count: ::std::option::Option<::std::vec::Vec<i64>>,
    num_negative_samples: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NegTrain {
    /// Creates a new `NegTrain`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `vocab_count` attribute.
    pub fn vocab_count<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.vocab_count = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_negative_samples` attribute.
    pub fn num_negative_samples<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_negative_samples = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NegTrain` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        w_in: O0,
        w_out: O1,
        examples: O2,
        labels: O3,
        lr: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            w_in.into(),
            w_out.into(),
            examples.into(),
            labels.into(),
            lr.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        w_in: crate::Output,
        w_out: crate::Output,
        examples: crate::Output,
        labels: crate::Output,
        lr: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NegTrain", |nd| {
            nd.add_input(w_in);
            nd.add_input(w_out);
            nd.add_input(examples);
            nd.add_input(labels);
            nd.add_input(lr);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.vocab_count {
                nd.set_attr_int_list("vocab_count", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_negative_samples {
                nd.set_attr_int("num_negative_samples", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NegTrain::new().build(w_in, w_out, examples, labels, lr, scope)`.
pub fn neg_train<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    w_in: O0,
    w_out: O1,
    examples: O2,
    labels: O3,
    lr: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NegTrain::new().build(w_in, w_out, examples, labels, lr, scope)
}
/// Builder for the `NextAfter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NextAfter {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NextAfter {
    /// Creates a new `NextAfter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NextAfter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x1: O0,
        x2: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x1.into(), x2.into(), scope)
    }

    fn build_impl(
        &self,
        x1: crate::Output,
        x2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NextAfter", |nd| {
            nd.add_input(x1);
            nd.add_input(x2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NextAfter::new().build(x1, x2, scope)`.
pub fn next_after<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x1: O0,
    x2: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NextAfter::new().build(x1, x2, scope)
}
/// Builder for the `NextIteration` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NextIteration {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NextIteration {
    /// Creates a new `NextIteration`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NextIteration` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        data: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NextIteration", |nd| {
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NextIteration::new().build(data, scope)`.
pub fn next_iteration<O0: ::std::convert::Into<crate::Output>>(
    data: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NextIteration::new().build(data, scope)
}
/// Builder for the `NoOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NoOp {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NoOp {
    /// Creates a new `NoOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NoOp` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("NoOp", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NoOp::new().build(scope)`.
pub fn no_op(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    NoOp::new().build(scope)
}
/// Builder for the `NonDeterministicInts` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonDeterministicInts {
    dtype: ::std::option::Option<crate::DataType>,
    shape_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NonDeterministicInts {
    /// Creates a new `NonDeterministicInts`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_dtype` attribute.
    pub fn shape_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NonDeterministicInts` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        shape: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NonDeterministicInts", |nd| {
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_dtype {
                nd.set_attr_type("shape_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NonDeterministicInts::new().build(shape, scope)`.
pub fn non_deterministic_ints<O0: ::std::convert::Into<crate::Output>>(
    shape: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NonDeterministicInts::new().build(shape, scope)
}
/// Builder for the `NonMaxSuppression` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppression {
    iou_threshold: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NonMaxSuppression {
    /// Creates a new `NonMaxSuppression`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `iou_threshold` attribute.
    pub fn iou_threshold<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.iou_threshold = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NonMaxSuppression` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        boxes: O0,
        scores: O1,
        max_output_size: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(boxes.into(), scores.into(), max_output_size.into(), scope)
    }

    fn build_impl(
        &self,
        boxes: crate::Output,
        scores: crate::Output,
        max_output_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NonMaxSuppression", |nd| {
            nd.add_input(boxes);
            nd.add_input(scores);
            nd.add_input(max_output_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.iou_threshold {
                nd.set_attr_float("iou_threshold", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NonMaxSuppression::new().build(boxes, scores, max_output_size, scope)`.
pub fn non_max_suppression<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    boxes: O0,
    scores: O1,
    max_output_size: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NonMaxSuppression::new().build(boxes, scores, max_output_size, scope)
}
/// Builder for the `NonMaxSuppressionV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionV2 {
    T: ::std::option::Option<crate::DataType>,
    T_threshold: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NonMaxSuppressionV2 {
    /// Creates a new `NonMaxSuppressionV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T_threshold` attribute.
    pub fn T_threshold<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T_threshold = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NonMaxSuppressionV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        boxes: O0,
        scores: O1,
        max_output_size: O2,
        iou_threshold: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            boxes.into(),
            scores.into(),
            max_output_size.into(),
            iou_threshold.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        boxes: crate::Output,
        scores: crate::Output,
        max_output_size: crate::Output,
        iou_threshold: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NonMaxSuppressionV2", |nd| {
            nd.add_input(boxes);
            nd.add_input(scores);
            nd.add_input(max_output_size);
            nd.add_input(iou_threshold);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T_threshold {
                nd.set_attr_type("T_threshold", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NonMaxSuppressionV2::new().build(boxes, scores, max_output_size, iou_threshold, scope)`.
pub fn non_max_suppression_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    boxes: O0,
    scores: O1,
    max_output_size: O2,
    iou_threshold: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NonMaxSuppressionV2::new().build(boxes, scores, max_output_size, iou_threshold, scope)
}
/// Builder for the `NonMaxSuppressionV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionV3 {
    T: ::std::option::Option<crate::DataType>,
    T_threshold: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NonMaxSuppressionV3 {
    /// Creates a new `NonMaxSuppressionV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T_threshold` attribute.
    pub fn T_threshold<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T_threshold = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NonMaxSuppressionV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        boxes: O0,
        scores: O1,
        max_output_size: O2,
        iou_threshold: O3,
        score_threshold: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            boxes.into(),
            scores.into(),
            max_output_size.into(),
            iou_threshold.into(),
            score_threshold.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        boxes: crate::Output,
        scores: crate::Output,
        max_output_size: crate::Output,
        iou_threshold: crate::Output,
        score_threshold: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NonMaxSuppressionV3", |nd| {
            nd.add_input(boxes);
            nd.add_input(scores);
            nd.add_input(max_output_size);
            nd.add_input(iou_threshold);
            nd.add_input(score_threshold);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T_threshold {
                nd.set_attr_type("T_threshold", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NonMaxSuppressionV3::new().build(boxes, scores, max_output_size, iou_threshold, score_threshold, scope)`.
pub fn non_max_suppression_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    boxes: O0,
    scores: O1,
    max_output_size: O2,
    iou_threshold: O3,
    score_threshold: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NonMaxSuppressionV3::new().build(
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        scope,
    )
}
/// Builder for the `NonMaxSuppressionV4` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionV4 {
    T: ::std::option::Option<crate::DataType>,
    T_threshold: ::std::option::Option<crate::DataType>,
    pad_to_max_output_size: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NonMaxSuppressionV4 {
    /// Creates a new `NonMaxSuppressionV4`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T_threshold` attribute.
    pub fn T_threshold<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T_threshold = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `pad_to_max_output_size` attribute.
    pub fn pad_to_max_output_size<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.pad_to_max_output_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NonMaxSuppressionV4` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        boxes: O0,
        scores: O1,
        max_output_size: O2,
        iou_threshold: O3,
        score_threshold: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            boxes.into(),
            scores.into(),
            max_output_size.into(),
            iou_threshold.into(),
            score_threshold.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        boxes: crate::Output,
        scores: crate::Output,
        max_output_size: crate::Output,
        iou_threshold: crate::Output,
        score_threshold: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NonMaxSuppressionV4", |nd| {
            nd.add_input(boxes);
            nd.add_input(scores);
            nd.add_input(max_output_size);
            nd.add_input(iou_threshold);
            nd.add_input(score_threshold);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T_threshold {
                nd.set_attr_type("T_threshold", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.pad_to_max_output_size {
                nd.set_attr_bool("pad_to_max_output_size", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NonMaxSuppressionV4::new().build(boxes, scores, max_output_size, iou_threshold, score_threshold, scope)`.
pub fn non_max_suppression_v4<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    boxes: O0,
    scores: O1,
    max_output_size: O2,
    iou_threshold: O3,
    score_threshold: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NonMaxSuppressionV4::new().build(
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        scope,
    )
}
/// Builder for the `NonMaxSuppressionV5` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionV5 {
    T: ::std::option::Option<crate::DataType>,
    pad_to_max_output_size: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NonMaxSuppressionV5 {
    /// Creates a new `NonMaxSuppressionV5`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `pad_to_max_output_size` attribute.
    pub fn pad_to_max_output_size<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.pad_to_max_output_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NonMaxSuppressionV5` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        boxes: O0,
        scores: O1,
        max_output_size: O2,
        iou_threshold: O3,
        score_threshold: O4,
        soft_nms_sigma: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            boxes.into(),
            scores.into(),
            max_output_size.into(),
            iou_threshold.into(),
            score_threshold.into(),
            soft_nms_sigma.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        boxes: crate::Output,
        scores: crate::Output,
        max_output_size: crate::Output,
        iou_threshold: crate::Output,
        score_threshold: crate::Output,
        soft_nms_sigma: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NonMaxSuppressionV5", |nd| {
            nd.add_input(boxes);
            nd.add_input(scores);
            nd.add_input(max_output_size);
            nd.add_input(iou_threshold);
            nd.add_input(score_threshold);
            nd.add_input(soft_nms_sigma);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.pad_to_max_output_size {
                nd.set_attr_bool("pad_to_max_output_size", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NonMaxSuppressionV5::new().build(boxes, scores, max_output_size, iou_threshold, score_threshold, soft_nms_sigma, scope)`.
pub fn non_max_suppression_v5<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    boxes: O0,
    scores: O1,
    max_output_size: O2,
    iou_threshold: O3,
    score_threshold: O4,
    soft_nms_sigma: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NonMaxSuppressionV5::new().build(
        boxes,
        scores,
        max_output_size,
        iou_threshold,
        score_threshold,
        soft_nms_sigma,
        scope,
    )
}
/// Builder for the `NonMaxSuppressionWithOverlaps` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonMaxSuppressionWithOverlaps {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NonMaxSuppressionWithOverlaps {
    /// Creates a new `NonMaxSuppressionWithOverlaps`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NonMaxSuppressionWithOverlaps` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        overlaps: O0,
        scores: O1,
        max_output_size: O2,
        overlap_threshold: O3,
        score_threshold: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            overlaps.into(),
            scores.into(),
            max_output_size.into(),
            overlap_threshold.into(),
            score_threshold.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        overlaps: crate::Output,
        scores: crate::Output,
        max_output_size: crate::Output,
        overlap_threshold: crate::Output,
        score_threshold: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NonMaxSuppressionWithOverlaps", |nd| {
            nd.add_input(overlaps);
            nd.add_input(scores);
            nd.add_input(max_output_size);
            nd.add_input(overlap_threshold);
            nd.add_input(score_threshold);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NonMaxSuppressionWithOverlaps::new().build(overlaps, scores, max_output_size, overlap_threshold, score_threshold, scope)`.
pub fn non_max_suppression_with_overlaps<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    overlaps: O0,
    scores: O1,
    max_output_size: O2,
    overlap_threshold: O3,
    score_threshold: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NonMaxSuppressionWithOverlaps::new().build(
        overlaps,
        scores,
        max_output_size,
        overlap_threshold,
        score_threshold,
        scope,
    )
}
/// Builder for the `NonSerializableDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NonSerializableDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NonSerializableDataset {
    /// Creates a new `NonSerializableDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NonSerializableDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NonSerializableDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NonSerializableDataset::new().build(input_dataset, scope)`.
pub fn non_serializable_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NonSerializableDataset::new().build(input_dataset, scope)
}
/// Builder for the `NotEqual` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NotEqual {
    T: ::std::option::Option<crate::DataType>,
    incompatible_shape_error: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NotEqual {
    /// Creates a new `NotEqual`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `incompatible_shape_error` attribute.
    pub fn incompatible_shape_error<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.incompatible_shape_error = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NotEqual` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NotEqual", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.incompatible_shape_error {
                nd.set_attr_bool("incompatible_shape_error", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NotEqual::new().build(x, y, scope)`.
pub fn not_equal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NotEqual::new().build(x, y, scope)
}
/// Builder for the `NthElement` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct NthElement {
    reverse: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl NthElement {
    /// Creates a new `NthElement`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `reverse` attribute.
    pub fn reverse<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.reverse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `NthElement` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        n: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), n.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        n: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("NthElement", |nd| {
            nd.add_input(input);
            nd.add_input(n);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.reverse {
                nd.set_attr_bool("reverse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `NthElement::new().build(input, n, scope)`.
pub fn nth_element<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    n: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    NthElement::new().build(input, n, scope)
}
/// Builder for the `OneHot` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OneHot {
    axis: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    TI: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OneHot {
    /// Creates a new `OneHot`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `axis` attribute.
    pub fn axis<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.axis = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `TI` attribute.
    pub fn TI<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.TI = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OneHot` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        depth: O1,
        on_value: O2,
        off_value: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            indices.into(),
            depth.into(),
            on_value.into(),
            off_value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        depth: crate::Output,
        on_value: crate::Output,
        off_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OneHot", |nd| {
            nd.add_input(indices);
            nd.add_input(depth);
            nd.add_input(on_value);
            nd.add_input(off_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.axis {
                nd.set_attr_int("axis", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.TI {
                nd.set_attr_type("TI", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OneHot::new().build(indices, depth, on_value, off_value, scope)`.
pub fn one_hot<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    depth: O1,
    on_value: O2,
    off_value: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OneHot::new().build(indices, depth, on_value, off_value, scope)
}
/// Builder for the `OneShotIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OneShotIterator {
    dataset_factory: ::std::option::Option<::std::string::String>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OneShotIterator {
    /// Creates a new `OneShotIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dataset_factory` attribute.
    pub fn dataset_factory<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dataset_factory = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OneShotIterator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("OneShotIterator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dataset_factory {
                nd.set_attr_string("dataset_factory", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OneShotIterator::new().build(scope)`.
pub fn one_shot_iterator(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    OneShotIterator::new().build(scope)
}
/// Builder for the `OnesLike` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OnesLike {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OnesLike {
    /// Creates a new `OnesLike`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OnesLike` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OnesLike", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OnesLike::new().build(x, scope)`.
pub fn ones_like<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OnesLike::new().build(x, scope)
}
/// Builder for the `OptimizeDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptimizeDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    optimization_configs: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OptimizeDataset {
    /// Creates a new `OptimizeDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `optimization_configs` attribute.
    pub fn optimization_configs<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.optimization_configs = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OptimizeDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        optimizations: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), optimizations.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        optimizations: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OptimizeDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(optimizations);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.optimization_configs {
                nd.set_attr_string_list("optimization_configs", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OptimizeDataset::new().build(input_dataset, optimizations, scope)`.
pub fn optimize_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    optimizations: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OptimizeDataset::new().build(input_dataset, optimizations, scope)
}
/// Builder for the `OptionalFromValue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionalFromValue {
    Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OptionalFromValue {
    /// Creates a new `OptionalFromValue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Toutput_types` attribute.
    pub fn Toutput_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OptionalFromValue` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        components: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(components.into(), scope)
    }

    fn build_impl(
        &self,
        components: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OptionalFromValue", |nd| {
            nd.add_input(components);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Toutput_types {
                nd.set_attr_type_list("Toutput_types", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OptionalFromValue::new().build(components, scope)`.
pub fn optional_from_value<O0: ::std::convert::Into<crate::Output>>(
    components: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OptionalFromValue::new().build(components, scope)
}
/// Builder for the `OptionalGetValue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionalGetValue {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OptionalGetValue {
    /// Creates a new `OptionalGetValue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OptionalGetValue` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        optional: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(optional.into(), scope)
    }

    fn build_impl(
        &self,
        optional: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OptionalGetValue", |nd| {
            nd.add_input(optional);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OptionalGetValue::new().build(optional, scope)`.
pub fn optional_get_value<O0: ::std::convert::Into<crate::Output>>(
    optional: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OptionalGetValue::new().build(optional, scope)
}
/// Builder for the `OptionalHasValue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionalHasValue {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OptionalHasValue {
    /// Creates a new `OptionalHasValue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OptionalHasValue` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        optional: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(optional.into(), scope)
    }

    fn build_impl(
        &self,
        optional: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OptionalHasValue", |nd| {
            nd.add_input(optional);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OptionalHasValue::new().build(optional, scope)`.
pub fn optional_has_value<O0: ::std::convert::Into<crate::Output>>(
    optional: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OptionalHasValue::new().build(optional, scope)
}
/// Builder for the `OptionalNone` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OptionalNone {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OptionalNone {
    /// Creates a new `OptionalNone`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OptionalNone` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("OptionalNone", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OptionalNone::new().build(scope)`.
pub fn optional_none(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    OptionalNone::new().build(scope)
}
/// Builder for the `OrderedMapClear` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapClear {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OrderedMapClear {
    /// Creates a new `OrderedMapClear`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OrderedMapClear` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("OrderedMapClear", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OrderedMapClear::new().build(scope)`.
pub fn ordered_map_clear(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    OrderedMapClear::new().build(scope)
}
/// Builder for the `OrderedMapIncompleteSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapIncompleteSize {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OrderedMapIncompleteSize {
    /// Creates a new `OrderedMapIncompleteSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OrderedMapIncompleteSize` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("OrderedMapIncompleteSize", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OrderedMapIncompleteSize::new().build(scope)`.
pub fn ordered_map_incomplete_size(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    OrderedMapIncompleteSize::new().build(scope)
}
/// Builder for the `OrderedMapPeek` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapPeek {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OrderedMapPeek {
    /// Creates a new `OrderedMapPeek`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OrderedMapPeek` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        key: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(key.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        key: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OrderedMapPeek", |nd| {
            nd.add_input(key);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OrderedMapPeek::new().build(key, indices, scope)`.
pub fn ordered_map_peek<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    key: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OrderedMapPeek::new().build(key, indices, scope)
}
/// Builder for the `OrderedMapSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapSize {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OrderedMapSize {
    /// Creates a new `OrderedMapSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OrderedMapSize` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("OrderedMapSize", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OrderedMapSize::new().build(scope)`.
pub fn ordered_map_size(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    OrderedMapSize::new().build(scope)
}
/// Builder for the `OrderedMapStage` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapStage {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    fake_dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OrderedMapStage {
    /// Creates a new `OrderedMapStage`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fake_dtypes` attribute.
    pub fn fake_dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.fake_dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OrderedMapStage` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        key: O0,
        indices: O1,
        values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(key.into(), indices.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        key: crate::Output,
        indices: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OrderedMapStage", |nd| {
            nd.add_input(key);
            nd.add_input(indices);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fake_dtypes {
                nd.set_attr_type_list("fake_dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OrderedMapStage::new().build(key, indices, values, scope)`.
pub fn ordered_map_stage<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    key: O0,
    indices: O1,
    values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OrderedMapStage::new().build(key, indices, values, scope)
}
/// Builder for the `OrderedMapUnstage` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapUnstage {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OrderedMapUnstage {
    /// Creates a new `OrderedMapUnstage`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OrderedMapUnstage` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        key: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(key.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        key: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OrderedMapUnstage", |nd| {
            nd.add_input(key);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OrderedMapUnstage::new().build(key, indices, scope)`.
pub fn ordered_map_unstage<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    key: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OrderedMapUnstage::new().build(key, indices, scope)
}
/// Builder for the `OrderedMapUnstageNoKey` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OrderedMapUnstageNoKey {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OrderedMapUnstageNoKey {
    /// Creates a new `OrderedMapUnstageNoKey`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OrderedMapUnstageNoKey` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        indices: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OrderedMapUnstageNoKey", |nd| {
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OrderedMapUnstageNoKey::new().build(indices, scope)`.
pub fn ordered_map_unstage_no_key<O0: ::std::convert::Into<crate::Output>>(
    indices: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OrderedMapUnstageNoKey::new().build(indices, scope)
}
/// Builder for the `OutfeedDequeue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedDequeue {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    device_ordinal: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OutfeedDequeue {
    /// Creates a new `OutfeedDequeue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OutfeedDequeue` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("OutfeedDequeue", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OutfeedDequeue::new().build(scope)`.
pub fn outfeed_dequeue(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    OutfeedDequeue::new().build(scope)
}
/// Builder for the `OutfeedDequeueTuple` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedDequeueTuple {
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    device_ordinal: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OutfeedDequeueTuple {
    /// Creates a new `OutfeedDequeueTuple`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_ordinal` attribute.
    pub fn device_ordinal<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.device_ordinal = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OutfeedDequeueTuple` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("OutfeedDequeueTuple", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_ordinal {
                nd.set_attr_int("device_ordinal", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OutfeedDequeueTuple::new().build(scope)`.
pub fn outfeed_dequeue_tuple(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    OutfeedDequeueTuple::new().build(scope)
}
/// Builder for the `OutfeedEnqueue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedEnqueue {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OutfeedEnqueue {
    /// Creates a new `OutfeedEnqueue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OutfeedEnqueue` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OutfeedEnqueue", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OutfeedEnqueue::new().build(input, scope)`.
pub fn outfeed_enqueue<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OutfeedEnqueue::new().build(input, scope)
}
/// Builder for the `OutfeedEnqueueTuple` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct OutfeedEnqueueTuple {
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl OutfeedEnqueueTuple {
    /// Creates a new `OutfeedEnqueueTuple`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `OutfeedEnqueueTuple` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("OutfeedEnqueueTuple", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `OutfeedEnqueueTuple::new().build(inputs, scope)`.
pub fn outfeed_enqueue_tuple<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    OutfeedEnqueueTuple::new().build(inputs, scope)
}
/// Builder for the `Pack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Pack {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    axis: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Pack {
    /// Creates a new `Pack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `axis` attribute.
    pub fn axis<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.axis = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Pack` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        values: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(values.into(), scope)
    }

    fn build_impl(
        &self,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Pack", |nd| {
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.axis {
                nd.set_attr_int("axis", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Pack::new().build(values, scope)`.
pub fn pack<O0: ::std::convert::Into<crate::Output>>(
    values: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Pack::new().build(values, scope)
}
/// Builder for the `Pad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Pad {
    T: ::std::option::Option<crate::DataType>,
    Tpaddings: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Pad {
    /// Creates a new `Pad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tpaddings` attribute.
    pub fn Tpaddings<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tpaddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Pad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        paddings: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), paddings.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        paddings: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Pad", |nd| {
            nd.add_input(input);
            nd.add_input(paddings);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tpaddings {
                nd.set_attr_type("Tpaddings", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Pad::new().build(input, paddings, scope)`.
pub fn pad<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    paddings: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Pad::new().build(input, paddings, scope)
}
/// Builder for the `PadV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PadV2 {
    T: ::std::option::Option<crate::DataType>,
    Tpaddings: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PadV2 {
    /// Creates a new `PadV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tpaddings` attribute.
    pub fn Tpaddings<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tpaddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PadV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        paddings: O1,
        constant_values: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), paddings.into(), constant_values.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        paddings: crate::Output,
        constant_values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PadV2", |nd| {
            nd.add_input(input);
            nd.add_input(paddings);
            nd.add_input(constant_values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tpaddings {
                nd.set_attr_type("Tpaddings", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PadV2::new().build(input, paddings, constant_values, scope)`.
pub fn pad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    paddings: O1,
    constant_values: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PadV2::new().build(input, paddings, constant_values, scope)
}
/// Builder for the `PaddedBatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PaddedBatchDataset {
    Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PaddedBatchDataset {
    /// Creates a new `PaddedBatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Toutput_types` attribute.
    pub fn Toutput_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PaddedBatchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        batch_size: O1,
        padded_shapes: O2,
        padding_values: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            batch_size.into(),
            padded_shapes.into(),
            padding_values.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        batch_size: crate::Output,
        padded_shapes: crate::Output,
        padding_values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PaddedBatchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(batch_size);
            nd.add_input(padded_shapes);
            nd.add_input(padding_values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Toutput_types {
                nd.set_attr_type_list("Toutput_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PaddedBatchDataset::new().build(input_dataset, batch_size, padded_shapes, padding_values, scope)`.
pub fn padded_batch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    batch_size: O1,
    padded_shapes: O2,
    padding_values: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PaddedBatchDataset::new().build(
        input_dataset,
        batch_size,
        padded_shapes,
        padding_values,
        scope,
    )
}
/// Builder for the `PaddedBatchDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PaddedBatchDatasetV2 {
    parallel_copy: ::std::option::Option<bool>,
    Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PaddedBatchDatasetV2 {
    /// Creates a new `PaddedBatchDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `parallel_copy` attribute.
    pub fn parallel_copy<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.parallel_copy = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput_types` attribute.
    pub fn Toutput_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PaddedBatchDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        batch_size: O1,
        padded_shapes: O2,
        padding_values: O3,
        drop_remainder: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            batch_size.into(),
            padded_shapes.into(),
            padding_values.into(),
            drop_remainder.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        batch_size: crate::Output,
        padded_shapes: crate::Output,
        padding_values: crate::Output,
        drop_remainder: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PaddedBatchDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(batch_size);
            nd.add_input(padded_shapes);
            nd.add_input(padding_values);
            nd.add_input(drop_remainder);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.parallel_copy {
                nd.set_attr_bool("parallel_copy", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput_types {
                nd.set_attr_type_list("Toutput_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PaddedBatchDatasetV2::new().build(input_dataset, batch_size, padded_shapes, padding_values, drop_remainder, scope)`.
pub fn padded_batch_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    batch_size: O1,
    padded_shapes: O2,
    padding_values: O3,
    drop_remainder: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PaddedBatchDatasetV2::new().build(
        input_dataset,
        batch_size,
        padded_shapes,
        padding_values,
        drop_remainder,
        scope,
    )
}
/// Builder for the `PaddingFIFOQueue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PaddingFIFOQueue {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PaddingFIFOQueue {
    /// Creates a new `PaddingFIFOQueue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PaddingFIFOQueue` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("PaddingFIFOQueue", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PaddingFIFOQueue::new().build(scope)`.
pub fn padding_fifoqueue(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    PaddingFIFOQueue::new().build(scope)
}
/// Builder for the `PaddingFIFOQueueV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PaddingFIFOQueueV2 {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PaddingFIFOQueueV2 {
    /// Creates a new `PaddingFIFOQueueV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PaddingFIFOQueueV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("PaddingFIFOQueueV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PaddingFIFOQueueV2::new().build(scope)`.
pub fn padding_fifoqueue_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    PaddingFIFOQueueV2::new().build(scope)
}
/// Builder for the `ParallelConcat` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelConcat {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParallelConcat {
    /// Creates a new `ParallelConcat`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParallelConcat` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        values: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(values.into(), scope)
    }

    fn build_impl(
        &self,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParallelConcat", |nd| {
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParallelConcat::new().build(values, scope)`.
pub fn parallel_concat<O0: ::std::convert::Into<crate::Output>>(
    values: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParallelConcat::new().build(values, scope)
}
/// Builder for the `ParallelDynamicStitch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelDynamicStitch {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParallelDynamicStitch {
    /// Creates a new `ParallelDynamicStitch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParallelDynamicStitch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        data: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), data.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParallelDynamicStitch", |nd| {
            nd.add_input(indices);
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParallelDynamicStitch::new().build(indices, data, scope)`.
pub fn parallel_dynamic_stitch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    data: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParallelDynamicStitch::new().build(indices, data, scope)
}
/// Builder for the `ParallelInterleaveDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelInterleaveDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParallelInterleaveDataset {
    /// Creates a new `ParallelInterleaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParallelInterleaveDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        cycle_length: O2,
        block_length: O3,
        sloppy: O4,
        buffer_output_elements: O5,
        prefetch_input_elements: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            cycle_length.into(),
            block_length.into(),
            sloppy.into(),
            buffer_output_elements.into(),
            prefetch_input_elements.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        cycle_length: crate::Output,
        block_length: crate::Output,
        sloppy: crate::Output,
        buffer_output_elements: crate::Output,
        prefetch_input_elements: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParallelInterleaveDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(cycle_length);
            nd.add_input(block_length);
            nd.add_input(sloppy);
            nd.add_input(buffer_output_elements);
            nd.add_input(prefetch_input_elements);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParallelInterleaveDataset::new().build(input_dataset, other_arguments, cycle_length, block_length, sloppy, buffer_output_elements, prefetch_input_elements, scope)`.
pub fn parallel_interleave_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    cycle_length: O2,
    block_length: O3,
    sloppy: O4,
    buffer_output_elements: O5,
    prefetch_input_elements: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParallelInterleaveDataset::new().build(
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        sloppy,
        buffer_output_elements,
        prefetch_input_elements,
        scope,
    )
}
/// Builder for the `ParallelInterleaveDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelInterleaveDatasetV2 {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    sloppy: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParallelInterleaveDatasetV2 {
    /// Creates a new `ParallelInterleaveDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sloppy` attribute.
    pub fn sloppy<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.sloppy = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParallelInterleaveDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        cycle_length: O2,
        block_length: O3,
        num_parallel_calls: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            cycle_length.into(),
            block_length.into(),
            num_parallel_calls.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        cycle_length: crate::Output,
        block_length: crate::Output,
        num_parallel_calls: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParallelInterleaveDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(cycle_length);
            nd.add_input(block_length);
            nd.add_input(num_parallel_calls);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sloppy {
                nd.set_attr_bool("sloppy", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParallelInterleaveDatasetV2::new().build(input_dataset, other_arguments, cycle_length, block_length, num_parallel_calls, scope)`.
pub fn parallel_interleave_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    cycle_length: O2,
    block_length: O3,
    num_parallel_calls: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParallelInterleaveDatasetV2::new().build(
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        num_parallel_calls,
        scope,
    )
}
/// Builder for the `ParallelInterleaveDatasetV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelInterleaveDatasetV3 {
    f: ::std::option::Option<::std::string::String>,
    deterministic: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParallelInterleaveDatasetV3 {
    /// Creates a new `ParallelInterleaveDatasetV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `deterministic` attribute.
    pub fn deterministic<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.deterministic = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParallelInterleaveDatasetV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        cycle_length: O2,
        block_length: O3,
        num_parallel_calls: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            cycle_length.into(),
            block_length.into(),
            num_parallel_calls.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        cycle_length: crate::Output,
        block_length: crate::Output,
        num_parallel_calls: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParallelInterleaveDatasetV3", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(cycle_length);
            nd.add_input(block_length);
            nd.add_input(num_parallel_calls);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.deterministic {
                nd.set_attr_string("deterministic", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParallelInterleaveDatasetV3::new().build(input_dataset, other_arguments, cycle_length, block_length, num_parallel_calls, scope)`.
pub fn parallel_interleave_dataset_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    cycle_length: O2,
    block_length: O3,
    num_parallel_calls: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParallelInterleaveDatasetV3::new().build(
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        num_parallel_calls,
        scope,
    )
}
/// Builder for the `ParallelInterleaveDatasetV4` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelInterleaveDatasetV4 {
    f: ::std::option::Option<::std::string::String>,
    deterministic: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParallelInterleaveDatasetV4 {
    /// Creates a new `ParallelInterleaveDatasetV4`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `deterministic` attribute.
    pub fn deterministic<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.deterministic = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParallelInterleaveDatasetV4` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        cycle_length: O2,
        block_length: O3,
        buffer_output_elements: O4,
        prefetch_input_elements: O5,
        num_parallel_calls: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            cycle_length.into(),
            block_length.into(),
            buffer_output_elements.into(),
            prefetch_input_elements.into(),
            num_parallel_calls.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        cycle_length: crate::Output,
        block_length: crate::Output,
        buffer_output_elements: crate::Output,
        prefetch_input_elements: crate::Output,
        num_parallel_calls: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParallelInterleaveDatasetV4", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(cycle_length);
            nd.add_input(block_length);
            nd.add_input(buffer_output_elements);
            nd.add_input(prefetch_input_elements);
            nd.add_input(num_parallel_calls);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.deterministic {
                nd.set_attr_string("deterministic", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParallelInterleaveDatasetV4::new().build(input_dataset, other_arguments, cycle_length, block_length, buffer_output_elements, prefetch_input_elements, num_parallel_calls, scope)`.
pub fn parallel_interleave_dataset_v4<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    cycle_length: O2,
    block_length: O3,
    buffer_output_elements: O4,
    prefetch_input_elements: O5,
    num_parallel_calls: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParallelInterleaveDatasetV4::new().build(
        input_dataset,
        other_arguments,
        cycle_length,
        block_length,
        buffer_output_elements,
        prefetch_input_elements,
        num_parallel_calls,
        scope,
    )
}
/// Builder for the `ParallelMapDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelMapDataset {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    use_inter_op_parallelism: ::std::option::Option<bool>,
    sloppy: ::std::option::Option<bool>,
    preserve_cardinality: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParallelMapDataset {
    /// Creates a new `ParallelMapDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_inter_op_parallelism` attribute.
    pub fn use_inter_op_parallelism<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_inter_op_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sloppy` attribute.
    pub fn sloppy<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.sloppy = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_cardinality` attribute.
    pub fn preserve_cardinality<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_cardinality = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParallelMapDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        num_parallel_calls: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            num_parallel_calls.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        num_parallel_calls: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParallelMapDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(num_parallel_calls);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_inter_op_parallelism {
                nd.set_attr_bool("use_inter_op_parallelism", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sloppy {
                nd.set_attr_bool("sloppy", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_cardinality {
                nd.set_attr_bool("preserve_cardinality", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParallelMapDataset::new().build(input_dataset, other_arguments, num_parallel_calls, scope)`.
pub fn parallel_map_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    num_parallel_calls: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParallelMapDataset::new().build(input_dataset, other_arguments, num_parallel_calls, scope)
}
/// Builder for the `ParallelMapDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParallelMapDatasetV2 {
    f: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    use_inter_op_parallelism: ::std::option::Option<bool>,
    deterministic: ::std::option::Option<::std::string::String>,
    preserve_cardinality: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParallelMapDatasetV2 {
    /// Creates a new `ParallelMapDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_inter_op_parallelism` attribute.
    pub fn use_inter_op_parallelism<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_inter_op_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `deterministic` attribute.
    pub fn deterministic<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.deterministic = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_cardinality` attribute.
    pub fn preserve_cardinality<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_cardinality = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParallelMapDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        num_parallel_calls: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            other_arguments.into(),
            num_parallel_calls.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        num_parallel_calls: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParallelMapDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            nd.add_input(num_parallel_calls);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_inter_op_parallelism {
                nd.set_attr_bool("use_inter_op_parallelism", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.deterministic {
                nd.set_attr_string("deterministic", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_cardinality {
                nd.set_attr_bool("preserve_cardinality", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParallelMapDatasetV2::new().build(input_dataset, other_arguments, num_parallel_calls, scope)`.
pub fn parallel_map_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    num_parallel_calls: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParallelMapDatasetV2::new().build(input_dataset, other_arguments, num_parallel_calls, scope)
}
/// Builder for the `ParameterizedTruncatedNormal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParameterizedTruncatedNormal {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParameterizedTruncatedNormal {
    /// Creates a new `ParameterizedTruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParameterizedTruncatedNormal` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        means: O1,
        stdevs: O2,
        minvals: O3,
        maxvals: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            shape.into(),
            means.into(),
            stdevs.into(),
            minvals.into(),
            maxvals.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        means: crate::Output,
        stdevs: crate::Output,
        minvals: crate::Output,
        maxvals: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParameterizedTruncatedNormal", |nd| {
            nd.add_input(shape);
            nd.add_input(means);
            nd.add_input(stdevs);
            nd.add_input(minvals);
            nd.add_input(maxvals);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParameterizedTruncatedNormal::new().build(shape, means, stdevs, minvals, maxvals, scope)`.
pub fn parameterized_truncated_normal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    means: O1,
    stdevs: O2,
    minvals: O3,
    maxvals: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParameterizedTruncatedNormal::new().build(shape, means, stdevs, minvals, maxvals, scope)
}
/// Builder for the `ParseExample` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseExample {
    Nsparse: ::std::option::Option<i64>,
    Ndense: ::std::option::Option<i64>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseExample {
    /// Creates a new `ParseExample`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Nsparse` attribute.
    pub fn Nsparse<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.Nsparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Ndense` attribute.
    pub fn Ndense<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.Ndense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tdense` attribute.
    pub fn Tdense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tdense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_shapes` attribute.
    pub fn dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseExample` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        serialized: O0,
        names: O1,
        sparse_keys: O2,
        dense_keys: O3,
        dense_defaults: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            serialized.into(),
            names.into(),
            sparse_keys.into(),
            dense_keys.into(),
            dense_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        serialized: crate::Output,
        names: crate::Output,
        sparse_keys: crate::Output,
        dense_keys: crate::Output,
        dense_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseExample", |nd| {
            nd.add_input(serialized);
            nd.add_input(names);
            nd.add_input(sparse_keys);
            nd.add_input(dense_keys);
            nd.add_input(dense_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Nsparse {
                nd.set_attr_int("Nsparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Ndense {
                nd.set_attr_int("Ndense", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tdense {
                nd.set_attr_type_list("Tdense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_shapes {
                nd.set_attr_shape_list("dense_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseExample::new().build(serialized, names, sparse_keys, dense_keys, dense_defaults, scope)`.
pub fn parse_example<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    serialized: O0,
    names: O1,
    sparse_keys: O2,
    dense_keys: O3,
    dense_defaults: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseExample::new().build(
        serialized,
        names,
        sparse_keys,
        dense_keys,
        dense_defaults,
        scope,
    )
}
/// Builder for the `ParseExampleDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseExampleDataset {
    sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    sloppy: ::std::option::Option<bool>,
    ragged_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseExampleDataset {
    /// Creates a new `ParseExampleDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `sparse_keys` attribute.
    pub fn sparse_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_keys` attribute.
    pub fn dense_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tdense` attribute.
    pub fn Tdense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tdense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_shapes` attribute.
    pub fn dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sloppy` attribute.
    pub fn sloppy<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.sloppy = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_keys` attribute.
    pub fn ragged_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_value_types` attribute.
    pub fn ragged_value_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_value_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_split_types` attribute.
    pub fn ragged_split_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_split_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseExampleDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_parallel_calls: O1,
        dense_defaults: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            num_parallel_calls.into(),
            dense_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_parallel_calls: crate::Output,
        dense_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseExampleDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_parallel_calls);
            nd.add_input(dense_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.sparse_keys {
                nd.set_attr_string_list("sparse_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_keys {
                nd.set_attr_string_list("dense_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tdense {
                nd.set_attr_type_list("Tdense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_shapes {
                nd.set_attr_shape_list("dense_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sloppy {
                nd.set_attr_bool("sloppy", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_keys {
                nd.set_attr_string_list("ragged_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_value_types {
                nd.set_attr_type_list("ragged_value_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_split_types {
                nd.set_attr_type_list("ragged_split_types", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseExampleDataset::new().build(input_dataset, num_parallel_calls, dense_defaults, scope)`.
pub fn parse_example_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_parallel_calls: O1,
    dense_defaults: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseExampleDataset::new().build(input_dataset, num_parallel_calls, dense_defaults, scope)
}
/// Builder for the `ParseExampleDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseExampleDatasetV2 {
    sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    deterministic: ::std::option::Option<::std::string::String>,
    ragged_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseExampleDatasetV2 {
    /// Creates a new `ParseExampleDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `sparse_keys` attribute.
    pub fn sparse_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_keys` attribute.
    pub fn dense_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tdense` attribute.
    pub fn Tdense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tdense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_shapes` attribute.
    pub fn dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `deterministic` attribute.
    pub fn deterministic<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.deterministic = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_keys` attribute.
    pub fn ragged_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_value_types` attribute.
    pub fn ragged_value_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_value_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_split_types` attribute.
    pub fn ragged_split_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_split_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseExampleDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_parallel_calls: O1,
        dense_defaults: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            num_parallel_calls.into(),
            dense_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_parallel_calls: crate::Output,
        dense_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseExampleDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_parallel_calls);
            nd.add_input(dense_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.sparse_keys {
                nd.set_attr_string_list("sparse_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_keys {
                nd.set_attr_string_list("dense_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tdense {
                nd.set_attr_type_list("Tdense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_shapes {
                nd.set_attr_shape_list("dense_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.deterministic {
                nd.set_attr_string("deterministic", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_keys {
                nd.set_attr_string_list("ragged_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_value_types {
                nd.set_attr_type_list("ragged_value_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_split_types {
                nd.set_attr_type_list("ragged_split_types", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseExampleDatasetV2::new().build(input_dataset, num_parallel_calls, dense_defaults, scope)`.
pub fn parse_example_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_parallel_calls: O1,
    dense_defaults: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseExampleDatasetV2::new().build(input_dataset, num_parallel_calls, dense_defaults, scope)
}
/// Builder for the `ParseExampleV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseExampleV2 {
    Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    num_sparse: ::std::option::Option<i64>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseExampleV2 {
    /// Creates a new `ParseExampleV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tdense` attribute.
    pub fn Tdense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tdense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sparse` attribute.
    pub fn num_sparse<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_value_types` attribute.
    pub fn ragged_value_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_value_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_split_types` attribute.
    pub fn ragged_split_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_split_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_shapes` attribute.
    pub fn dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseExampleV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        serialized: O0,
        names: O1,
        sparse_keys: O2,
        dense_keys: O3,
        ragged_keys: O4,
        dense_defaults: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            serialized.into(),
            names.into(),
            sparse_keys.into(),
            dense_keys.into(),
            ragged_keys.into(),
            dense_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        serialized: crate::Output,
        names: crate::Output,
        sparse_keys: crate::Output,
        dense_keys: crate::Output,
        ragged_keys: crate::Output,
        dense_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseExampleV2", |nd| {
            nd.add_input(serialized);
            nd.add_input(names);
            nd.add_input(sparse_keys);
            nd.add_input(dense_keys);
            nd.add_input(ragged_keys);
            nd.add_input(dense_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tdense {
                nd.set_attr_type_list("Tdense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sparse {
                nd.set_attr_int("num_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_value_types {
                nd.set_attr_type_list("ragged_value_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_split_types {
                nd.set_attr_type_list("ragged_split_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_shapes {
                nd.set_attr_shape_list("dense_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseExampleV2::new().build(serialized, names, sparse_keys, dense_keys, ragged_keys, dense_defaults, scope)`.
pub fn parse_example_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    serialized: O0,
    names: O1,
    sparse_keys: O2,
    dense_keys: O3,
    ragged_keys: O4,
    dense_defaults: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseExampleV2::new().build(
        serialized,
        names,
        sparse_keys,
        dense_keys,
        ragged_keys,
        dense_defaults,
        scope,
    )
}
/// Builder for the `ParseSequenceExample` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseSequenceExample {
    feature_list_dense_missing_assumed_empty:
        ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    context_sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    context_dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    feature_list_sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    feature_list_dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    Ncontext_sparse: ::std::option::Option<i64>,
    Ncontext_dense: ::std::option::Option<i64>,
    Nfeature_list_sparse: ::std::option::Option<i64>,
    Nfeature_list_dense: ::std::option::Option<i64>,
    context_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tcontext_dense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    feature_list_dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    context_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    feature_list_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    feature_list_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseSequenceExample {
    /// Creates a new `ParseSequenceExample`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `feature_list_dense_missing_assumed_empty` attribute.
    pub fn feature_list_dense_missing_assumed_empty<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_dense_missing_assumed_empty = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_sparse_keys` attribute.
    pub fn context_sparse_keys<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_sparse_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_dense_keys` attribute.
    pub fn context_dense_keys<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_dense_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_sparse_keys` attribute.
    pub fn feature_list_sparse_keys<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_sparse_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_dense_keys` attribute.
    pub fn feature_list_dense_keys<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_dense_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Ncontext_sparse` attribute.
    pub fn Ncontext_sparse<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.Ncontext_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Ncontext_dense` attribute.
    pub fn Ncontext_dense<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.Ncontext_dense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Nfeature_list_sparse` attribute.
    pub fn Nfeature_list_sparse<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Nfeature_list_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Nfeature_list_dense` attribute.
    pub fn Nfeature_list_dense<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Nfeature_list_dense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_sparse_types` attribute.
    pub fn context_sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcontext_dense` attribute.
    pub fn Tcontext_dense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcontext_dense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_dense_types` attribute.
    pub fn feature_list_dense_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_dense_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_dense_shapes` attribute.
    pub fn context_dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_sparse_types` attribute.
    pub fn feature_list_sparse_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_dense_shapes` attribute.
    pub fn feature_list_dense_shapes<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseSequenceExample` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        serialized: O0,
        debug_name: O1,
        context_dense_defaults: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            serialized.into(),
            debug_name.into(),
            context_dense_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        serialized: crate::Output,
        debug_name: crate::Output,
        context_dense_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseSequenceExample", |nd| {
            nd.add_input(serialized);
            nd.add_input(debug_name);
            nd.add_input(context_dense_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) =
                &self.feature_list_dense_missing_assumed_empty
            {
                nd.set_attr_string_list("feature_list_dense_missing_assumed_empty", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_sparse_keys {
                nd.set_attr_string_list("context_sparse_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_dense_keys {
                nd.set_attr_string_list("context_dense_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_sparse_keys {
                nd.set_attr_string_list("feature_list_sparse_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_dense_keys {
                nd.set_attr_string_list("feature_list_dense_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Ncontext_sparse {
                nd.set_attr_int("Ncontext_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Ncontext_dense {
                nd.set_attr_int("Ncontext_dense", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Nfeature_list_sparse {
                nd.set_attr_int("Nfeature_list_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Nfeature_list_dense {
                nd.set_attr_int("Nfeature_list_dense", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_sparse_types {
                nd.set_attr_type_list("context_sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcontext_dense {
                nd.set_attr_type_list("Tcontext_dense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_dense_types {
                nd.set_attr_type_list("feature_list_dense_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_dense_shapes {
                nd.set_attr_shape_list("context_dense_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_sparse_types {
                nd.set_attr_type_list("feature_list_sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_dense_shapes {
                nd.set_attr_shape_list("feature_list_dense_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseSequenceExample::new().build(serialized, debug_name, context_dense_defaults, scope)`.
pub fn parse_sequence_example<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    serialized: O0,
    debug_name: O1,
    context_dense_defaults: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseSequenceExample::new().build(serialized, debug_name, context_dense_defaults, scope)
}
/// Builder for the `ParseSequenceExampleV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseSequenceExampleV2 {
    Ncontext_sparse: ::std::option::Option<i64>,
    Tcontext_dense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    context_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    context_ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    context_ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    context_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    Nfeature_list_sparse: ::std::option::Option<i64>,
    Nfeature_list_dense: ::std::option::Option<i64>,
    feature_list_dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    feature_list_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    feature_list_ragged_value_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    feature_list_ragged_split_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    feature_list_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseSequenceExampleV2 {
    /// Creates a new `ParseSequenceExampleV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Ncontext_sparse` attribute.
    pub fn Ncontext_sparse<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.Ncontext_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcontext_dense` attribute.
    pub fn Tcontext_dense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcontext_dense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_sparse_types` attribute.
    pub fn context_sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_ragged_value_types` attribute.
    pub fn context_ragged_value_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_ragged_value_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_ragged_split_types` attribute.
    pub fn context_ragged_split_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_ragged_split_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_dense_shapes` attribute.
    pub fn context_dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Nfeature_list_sparse` attribute.
    pub fn Nfeature_list_sparse<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Nfeature_list_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Nfeature_list_dense` attribute.
    pub fn Nfeature_list_dense<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Nfeature_list_dense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_dense_types` attribute.
    pub fn feature_list_dense_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_dense_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_sparse_types` attribute.
    pub fn feature_list_sparse_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_ragged_value_types` attribute.
    pub fn feature_list_ragged_value_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_ragged_value_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_ragged_split_types` attribute.
    pub fn feature_list_ragged_split_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_ragged_split_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_dense_shapes` attribute.
    pub fn feature_list_dense_shapes<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseSequenceExampleV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        serialized: O0,
        debug_name: O1,
        context_sparse_keys: O2,
        context_dense_keys: O3,
        context_ragged_keys: O4,
        feature_list_sparse_keys: O5,
        feature_list_dense_keys: O6,
        feature_list_ragged_keys: O7,
        feature_list_dense_missing_assumed_empty: O8,
        context_dense_defaults: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            serialized.into(),
            debug_name.into(),
            context_sparse_keys.into(),
            context_dense_keys.into(),
            context_ragged_keys.into(),
            feature_list_sparse_keys.into(),
            feature_list_dense_keys.into(),
            feature_list_ragged_keys.into(),
            feature_list_dense_missing_assumed_empty.into(),
            context_dense_defaults.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        serialized: crate::Output,
        debug_name: crate::Output,
        context_sparse_keys: crate::Output,
        context_dense_keys: crate::Output,
        context_ragged_keys: crate::Output,
        feature_list_sparse_keys: crate::Output,
        feature_list_dense_keys: crate::Output,
        feature_list_ragged_keys: crate::Output,
        feature_list_dense_missing_assumed_empty: crate::Output,
        context_dense_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseSequenceExampleV2", |nd| {
            nd.add_input(serialized);
            nd.add_input(debug_name);
            nd.add_input(context_sparse_keys);
            nd.add_input(context_dense_keys);
            nd.add_input(context_ragged_keys);
            nd.add_input(feature_list_sparse_keys);
            nd.add_input(feature_list_dense_keys);
            nd.add_input(feature_list_ragged_keys);
            nd.add_input(feature_list_dense_missing_assumed_empty);
            nd.add_input(context_dense_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Ncontext_sparse {
                nd.set_attr_int("Ncontext_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcontext_dense {
                nd.set_attr_type_list("Tcontext_dense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_sparse_types {
                nd.set_attr_type_list("context_sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_ragged_value_types {
                nd.set_attr_type_list("context_ragged_value_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_ragged_split_types {
                nd.set_attr_type_list("context_ragged_split_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_dense_shapes {
                nd.set_attr_shape_list("context_dense_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Nfeature_list_sparse {
                nd.set_attr_int("Nfeature_list_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Nfeature_list_dense {
                nd.set_attr_int("Nfeature_list_dense", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_dense_types {
                nd.set_attr_type_list("feature_list_dense_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_sparse_types {
                nd.set_attr_type_list("feature_list_sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_ragged_value_types {
                nd.set_attr_type_list("feature_list_ragged_value_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_ragged_split_types {
                nd.set_attr_type_list("feature_list_ragged_split_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_dense_shapes {
                nd.set_attr_shape_list("feature_list_dense_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseSequenceExampleV2::new().build(serialized, debug_name, context_sparse_keys, context_dense_keys, context_ragged_keys, feature_list_sparse_keys, feature_list_dense_keys, feature_list_ragged_keys, feature_list_dense_missing_assumed_empty, context_dense_defaults, scope)`.
pub fn parse_sequence_example_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    serialized: O0,
    debug_name: O1,
    context_sparse_keys: O2,
    context_dense_keys: O3,
    context_ragged_keys: O4,
    feature_list_sparse_keys: O5,
    feature_list_dense_keys: O6,
    feature_list_ragged_keys: O7,
    feature_list_dense_missing_assumed_empty: O8,
    context_dense_defaults: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseSequenceExampleV2::new().build(
        serialized,
        debug_name,
        context_sparse_keys,
        context_dense_keys,
        context_ragged_keys,
        feature_list_sparse_keys,
        feature_list_dense_keys,
        feature_list_ragged_keys,
        feature_list_dense_missing_assumed_empty,
        context_dense_defaults,
        scope,
    )
}
/// Builder for the `ParseSingleExample` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseSingleExample {
    num_sparse: ::std::option::Option<i64>,
    sparse_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    dense_keys: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tdense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseSingleExample {
    /// Creates a new `ParseSingleExample`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_sparse` attribute.
    pub fn num_sparse<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_keys` attribute.
    pub fn sparse_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_keys` attribute.
    pub fn dense_keys<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_keys = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tdense` attribute.
    pub fn Tdense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tdense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_shapes` attribute.
    pub fn dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseSingleExample` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        serialized: O0,
        dense_defaults: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(serialized.into(), dense_defaults.into(), scope)
    }

    fn build_impl(
        &self,
        serialized: crate::Output,
        dense_defaults: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseSingleExample", |nd| {
            nd.add_input(serialized);
            nd.add_input(dense_defaults);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_sparse {
                nd.set_attr_int("num_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_keys {
                nd.set_attr_string_list("sparse_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_keys {
                nd.set_attr_string_list("dense_keys", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tdense {
                nd.set_attr_type_list("Tdense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_shapes {
                nd.set_attr_shape_list("dense_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseSingleExample::new().build(serialized, dense_defaults, scope)`.
pub fn parse_single_example<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    serialized: O0,
    dense_defaults: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseSingleExample::new().build(serialized, dense_defaults, scope)
}
/// Builder for the `ParseSingleSequenceExample` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseSingleSequenceExample {
    Ncontext_sparse: ::std::option::Option<i64>,
    Ncontext_dense: ::std::option::Option<i64>,
    Nfeature_list_sparse: ::std::option::Option<i64>,
    Nfeature_list_dense: ::std::option::Option<i64>,
    context_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tcontext_dense: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    feature_list_dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    context_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    feature_list_sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    feature_list_dense_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseSingleSequenceExample {
    /// Creates a new `ParseSingleSequenceExample`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Ncontext_sparse` attribute.
    pub fn Ncontext_sparse<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.Ncontext_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Ncontext_dense` attribute.
    pub fn Ncontext_dense<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.Ncontext_dense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Nfeature_list_sparse` attribute.
    pub fn Nfeature_list_sparse<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Nfeature_list_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Nfeature_list_dense` attribute.
    pub fn Nfeature_list_dense<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Nfeature_list_dense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_sparse_types` attribute.
    pub fn context_sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcontext_dense` attribute.
    pub fn Tcontext_dense<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcontext_dense = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_dense_types` attribute.
    pub fn feature_list_dense_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_dense_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `context_dense_shapes` attribute.
    pub fn context_dense_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.context_dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_sparse_types` attribute.
    pub fn feature_list_sparse_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `feature_list_dense_shapes` attribute.
    pub fn feature_list_dense_shapes<
        ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.feature_list_dense_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseSingleSequenceExample` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        serialized: O0,
        feature_list_dense_missing_assumed_empty: O1,
        context_sparse_keys: O2,
        context_dense_keys: O3,
        feature_list_sparse_keys: O4,
        feature_list_dense_keys: O5,
        context_dense_defaults: O6,
        debug_name: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            serialized.into(),
            feature_list_dense_missing_assumed_empty.into(),
            context_sparse_keys.into(),
            context_dense_keys.into(),
            feature_list_sparse_keys.into(),
            feature_list_dense_keys.into(),
            context_dense_defaults.into(),
            debug_name.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        serialized: crate::Output,
        feature_list_dense_missing_assumed_empty: crate::Output,
        context_sparse_keys: crate::Output,
        context_dense_keys: crate::Output,
        feature_list_sparse_keys: crate::Output,
        feature_list_dense_keys: crate::Output,
        context_dense_defaults: crate::Output,
        debug_name: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseSingleSequenceExample", |nd| {
            nd.add_input(serialized);
            nd.add_input(feature_list_dense_missing_assumed_empty);
            nd.add_input(context_sparse_keys);
            nd.add_input(context_dense_keys);
            nd.add_input(feature_list_sparse_keys);
            nd.add_input(feature_list_dense_keys);
            nd.add_input(context_dense_defaults);
            nd.add_input(debug_name);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Ncontext_sparse {
                nd.set_attr_int("Ncontext_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Ncontext_dense {
                nd.set_attr_int("Ncontext_dense", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Nfeature_list_sparse {
                nd.set_attr_int("Nfeature_list_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Nfeature_list_dense {
                nd.set_attr_int("Nfeature_list_dense", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_sparse_types {
                nd.set_attr_type_list("context_sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcontext_dense {
                nd.set_attr_type_list("Tcontext_dense", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_dense_types {
                nd.set_attr_type_list("feature_list_dense_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.context_dense_shapes {
                nd.set_attr_shape_list("context_dense_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_sparse_types {
                nd.set_attr_type_list("feature_list_sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.feature_list_dense_shapes {
                nd.set_attr_shape_list("feature_list_dense_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseSingleSequenceExample::new().build(serialized, feature_list_dense_missing_assumed_empty, context_sparse_keys, context_dense_keys, feature_list_sparse_keys, feature_list_dense_keys, context_dense_defaults, debug_name, scope)`.
pub fn parse_single_sequence_example<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    serialized: O0,
    feature_list_dense_missing_assumed_empty: O1,
    context_sparse_keys: O2,
    context_dense_keys: O3,
    feature_list_sparse_keys: O4,
    feature_list_dense_keys: O5,
    context_dense_defaults: O6,
    debug_name: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseSingleSequenceExample::new().build(
        serialized,
        feature_list_dense_missing_assumed_empty,
        context_sparse_keys,
        context_dense_keys,
        feature_list_sparse_keys,
        feature_list_dense_keys,
        context_dense_defaults,
        debug_name,
        scope,
    )
}
/// Builder for the `ParseTensor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ParseTensor {
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ParseTensor {
    /// Creates a new `ParseTensor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ParseTensor` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        serialized: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(serialized.into(), scope)
    }

    fn build_impl(
        &self,
        serialized: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ParseTensor", |nd| {
            nd.add_input(serialized);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ParseTensor::new().build(serialized, scope)`.
pub fn parse_tensor<O0: ::std::convert::Into<crate::Output>>(
    serialized: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ParseTensor::new().build(serialized, scope)
}
/// Builder for the `PartitionedCall` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PartitionedCall {
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    f: ::std::option::Option<::std::string::String>,
    config: ::std::option::Option<::std::string::String>,
    config_proto: ::std::option::Option<::std::string::String>,
    executor_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PartitionedCall {
    /// Creates a new `PartitionedCall`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config_proto` attribute.
    pub fn config_proto<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config_proto = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `executor_type` attribute.
    pub fn executor_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.executor_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PartitionedCall` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        args: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(args.into(), scope)
    }

    fn build_impl(
        &self,
        args: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PartitionedCall", |nd| {
            nd.add_input(args);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config_proto {
                nd.set_attr_string("config_proto", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.executor_type {
                nd.set_attr_string("executor_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PartitionedCall::new().build(args, scope)`.
pub fn partitioned_call<O0: ::std::convert::Into<crate::Output>>(
    args: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PartitionedCall::new().build(args, scope)
}
/// Builder for the `Placeholder` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Placeholder {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Placeholder {
    /// Creates a new `Placeholder`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Placeholder` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Placeholder", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Placeholder::new().build(scope)`.
pub fn placeholder(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Placeholder::new().build(scope)
}
/// Builder for the `PlaceholderV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PlaceholderV2 {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PlaceholderV2 {
    /// Creates a new `PlaceholderV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PlaceholderV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("PlaceholderV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PlaceholderV2::new().build(scope)`.
pub fn placeholder_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    PlaceholderV2::new().build(scope)
}
/// Builder for the `PlaceholderWithDefault` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PlaceholderWithDefault {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PlaceholderWithDefault {
    /// Creates a new `PlaceholderWithDefault`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PlaceholderWithDefault` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PlaceholderWithDefault", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PlaceholderWithDefault::new().build(input, scope)`.
pub fn placeholder_with_default<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PlaceholderWithDefault::new().build(input, scope)
}
/// Builder for the `Polygamma` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Polygamma {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Polygamma {
    /// Creates a new `Polygamma`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Polygamma` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        x: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), x.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Polygamma", |nd| {
            nd.add_input(a);
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Polygamma::new().build(a, x, scope)`.
pub fn polygamma<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    x: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Polygamma::new().build(a, x, scope)
}
/// Builder for the `PopulationCount` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PopulationCount {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PopulationCount {
    /// Creates a new `PopulationCount`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PopulationCount` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PopulationCount", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PopulationCount::new().build(x, scope)`.
pub fn population_count<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PopulationCount::new().build(x, scope)
}
/// Builder for the `Pow` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Pow {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Pow {
    /// Creates a new `Pow`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Pow` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Pow", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Pow::new().build(x, y, scope)`.
pub fn pow<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Pow::new().build(x, y, scope)
}
/// Builder for the `PrefetchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PrefetchDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    slack_period: ::std::option::Option<i64>,
    legacy_autotune: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PrefetchDataset {
    /// Creates a new `PrefetchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `slack_period` attribute.
    pub fn slack_period<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.slack_period = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `legacy_autotune` attribute.
    pub fn legacy_autotune<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.legacy_autotune = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PrefetchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        buffer_size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), buffer_size.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        buffer_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PrefetchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(buffer_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.slack_period {
                nd.set_attr_int("slack_period", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.legacy_autotune {
                nd.set_attr_bool("legacy_autotune", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PrefetchDataset::new().build(input_dataset, buffer_size, scope)`.
pub fn prefetch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    buffer_size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PrefetchDataset::new().build(input_dataset, buffer_size, scope)
}
/// Builder for the `Prelinearize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Prelinearize {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    layout: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Prelinearize {
    /// Creates a new `Prelinearize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `layout` attribute.
    pub fn layout<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.layout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Prelinearize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Prelinearize", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.layout {
                nd.set_attr_int_list("layout", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Prelinearize::new().build(input, scope)`.
pub fn prelinearize<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Prelinearize::new().build(input, scope)
}
/// Builder for the `PrelinearizeTuple` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PrelinearizeTuple {
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    layouts: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PrelinearizeTuple {
    /// Creates a new `PrelinearizeTuple`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `layouts` attribute.
    pub fn layouts<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.layouts = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PrelinearizeTuple` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PrelinearizeTuple", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.layouts {
                nd.set_attr_int_list("layouts", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PrelinearizeTuple::new().build(inputs, scope)`.
pub fn prelinearize_tuple<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PrelinearizeTuple::new().build(inputs, scope)
}
/// Builder for the `PreventGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PreventGradient {
    T: ::std::option::Option<crate::DataType>,
    message: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PreventGradient {
    /// Creates a new `PreventGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `message` attribute.
    pub fn message<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.message = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PreventGradient` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PreventGradient", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.message {
                nd.set_attr_string("message", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PreventGradient::new().build(input, scope)`.
pub fn prevent_gradient<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PreventGradient::new().build(input, scope)
}
/// Builder for the `Print` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Print {
    T: ::std::option::Option<crate::DataType>,
    U: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    message: ::std::option::Option<::std::string::String>,
    first_n: ::std::option::Option<i64>,
    summarize: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Print {
    /// Creates a new `Print`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `U` attribute.
    pub fn U<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.U = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `message` attribute.
    pub fn message<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.message = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `first_n` attribute.
    pub fn first_n<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.first_n = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `summarize` attribute.
    pub fn summarize<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.summarize = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Print` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        data: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), data.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Print", |nd| {
            nd.add_input(input);
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.U {
                nd.set_attr_type_list("U", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.message {
                nd.set_attr_string("message", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.first_n {
                nd.set_attr_int("first_n", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.summarize {
                nd.set_attr_int("summarize", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Print::new().build(input, data, scope)`.
pub fn print<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    data: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Print::new().build(input, data, scope)
}
/// Builder for the `PrintV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PrintV2 {
    output_stream: ::std::option::Option<::std::string::String>,
    end: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PrintV2 {
    /// Creates a new `PrintV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_stream` attribute.
    pub fn output_stream<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_stream = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `end` attribute.
    pub fn end<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.end = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PrintV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PrintV2", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_stream {
                nd.set_attr_string("output_stream", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.end {
                nd.set_attr_string("end", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PrintV2::new().build(input, scope)`.
pub fn print_v2<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PrintV2::new().build(input, scope)
}
/// Builder for the `PriorityQueue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PriorityQueue {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PriorityQueue {
    /// Creates a new `PriorityQueue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PriorityQueue` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("PriorityQueue", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PriorityQueue::new().build(scope)`.
pub fn priority_queue(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    PriorityQueue::new().build(scope)
}
/// Builder for the `PriorityQueueV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PriorityQueueV2 {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PriorityQueueV2 {
    /// Creates a new `PriorityQueueV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PriorityQueueV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("PriorityQueueV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PriorityQueueV2::new().build(scope)`.
pub fn priority_queue_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    PriorityQueueV2::new().build(scope)
}
/// Builder for the `PrivateThreadPoolDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PrivateThreadPoolDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PrivateThreadPoolDataset {
    /// Creates a new `PrivateThreadPoolDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PrivateThreadPoolDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_threads: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), num_threads.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_threads: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PrivateThreadPoolDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_threads);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PrivateThreadPoolDataset::new().build(input_dataset, num_threads, scope)`.
pub fn private_thread_pool_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_threads: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PrivateThreadPoolDataset::new().build(input_dataset, num_threads, scope)
}
/// Builder for the `Prod` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Prod {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Prod {
    /// Creates a new `Prod`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Prod` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Prod", |nd| {
            nd.add_input(input);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Prod::new().build(input, reduction_indices, scope)`.
pub fn prod<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Prod::new().build(input, reduction_indices, scope)
}
/// Builder for the `PyFunc` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PyFunc {
    token: ::std::option::Option<::std::string::String>,
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PyFunc {
    /// Creates a new `PyFunc`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `token` attribute.
    pub fn token<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.token = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PyFunc` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PyFunc", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.token {
                nd.set_attr_string("token", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PyFunc::new().build(input, scope)`.
pub fn py_func<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PyFunc::new().build(input, scope)
}
/// Builder for the `PyFuncStateless` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct PyFuncStateless {
    token: ::std::option::Option<::std::string::String>,
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl PyFuncStateless {
    /// Creates a new `PyFuncStateless`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `token` attribute.
    pub fn token<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.token = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `PyFuncStateless` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("PyFuncStateless", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.token {
                nd.set_attr_string("token", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `PyFuncStateless::new().build(input, scope)`.
pub fn py_func_stateless<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    PyFuncStateless::new().build(input, scope)
}
/// Builder for the `Qr` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Qr {
    full_matrices: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Qr {
    /// Creates a new `Qr`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `full_matrices` attribute.
    pub fn full_matrices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.full_matrices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Qr` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Qr", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.full_matrices {
                nd.set_attr_bool("full_matrices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Qr::new().build(input, scope)`.
pub fn qr<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Qr::new().build(input, scope)
}
/// Builder for the `QuantizeAndDequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeAndDequantize {
    signed_input: ::std::option::Option<bool>,
    num_bits: ::std::option::Option<i64>,
    range_given: ::std::option::Option<bool>,
    input_min: ::std::option::Option<f32>,
    input_max: ::std::option::Option<f32>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizeAndDequantize {
    /// Creates a new `QuantizeAndDequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `signed_input` attribute.
    pub fn signed_input<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.signed_input = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_bits` attribute.
    pub fn num_bits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_bits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `range_given` attribute.
    pub fn range_given<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.range_given = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_min` attribute.
    pub fn input_min<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.input_min = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_max` attribute.
    pub fn input_max<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.input_max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizeAndDequantize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizeAndDequantize", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.signed_input {
                nd.set_attr_bool("signed_input", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_bits {
                nd.set_attr_int("num_bits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.range_given {
                nd.set_attr_bool("range_given", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_min {
                nd.set_attr_float("input_min", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_max {
                nd.set_attr_float("input_max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizeAndDequantize::new().build(input, scope)`.
pub fn quantize_and_dequantize<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizeAndDequantize::new().build(input, scope)
}
/// Builder for the `QuantizeAndDequantizeV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeAndDequantizeV2 {
    signed_input: ::std::option::Option<bool>,
    num_bits: ::std::option::Option<i64>,
    range_given: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    round_mode: ::std::option::Option<::std::string::String>,
    narrow_range: ::std::option::Option<bool>,
    axis: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizeAndDequantizeV2 {
    /// Creates a new `QuantizeAndDequantizeV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `signed_input` attribute.
    pub fn signed_input<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.signed_input = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_bits` attribute.
    pub fn num_bits<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_bits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `range_given` attribute.
    pub fn range_given<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.range_given = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `round_mode` attribute.
    pub fn round_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.round_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `axis` attribute.
    pub fn axis<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.axis = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizeAndDequantizeV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_min: O1,
        input_max: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), input_min.into(), input_max.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_min: crate::Output,
        input_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizeAndDequantizeV2", |nd| {
            nd.add_input(input);
            nd.add_input(input_min);
            nd.add_input(input_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.signed_input {
                nd.set_attr_bool("signed_input", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_bits {
                nd.set_attr_int("num_bits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.range_given {
                nd.set_attr_bool("range_given", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.round_mode {
                nd.set_attr_string("round_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.axis {
                nd.set_attr_int("axis", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizeAndDequantizeV2::new().build(input, input_min, input_max, scope)`.
pub fn quantize_and_dequantize_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_min: O1,
    input_max: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizeAndDequantizeV2::new().build(input, input_min, input_max, scope)
}
/// Builder for the `QuantizeAndDequantizeV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeAndDequantizeV3 {
    signed_input: ::std::option::Option<bool>,
    range_given: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    narrow_range: ::std::option::Option<bool>,
    axis: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizeAndDequantizeV3 {
    /// Creates a new `QuantizeAndDequantizeV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `signed_input` attribute.
    pub fn signed_input<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.signed_input = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `range_given` attribute.
    pub fn range_given<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.range_given = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `axis` attribute.
    pub fn axis<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.axis = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizeAndDequantizeV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_min: O1,
        input_max: O2,
        num_bits: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_min.into(),
            input_max.into(),
            num_bits.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_min: crate::Output,
        input_max: crate::Output,
        num_bits: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizeAndDequantizeV3", |nd| {
            nd.add_input(input);
            nd.add_input(input_min);
            nd.add_input(input_max);
            nd.add_input(num_bits);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.signed_input {
                nd.set_attr_bool("signed_input", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.range_given {
                nd.set_attr_bool("range_given", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.axis {
                nd.set_attr_int("axis", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizeAndDequantizeV3::new().build(input, input_min, input_max, num_bits, scope)`.
pub fn quantize_and_dequantize_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_min: O1,
    input_max: O2,
    num_bits: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizeAndDequantizeV3::new().build(input, input_min, input_max, num_bits, scope)
}
/// Builder for the `QuantizeDownAndShrinkRange` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeDownAndShrinkRange {
    Tinput: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizeDownAndShrinkRange {
    /// Creates a new `QuantizeDownAndShrinkRange`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizeDownAndShrinkRange` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_min: O1,
        input_max: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), input_min.into(), input_max.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_min: crate::Output,
        input_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizeDownAndShrinkRange", |nd| {
            nd.add_input(input);
            nd.add_input(input_min);
            nd.add_input(input_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizeDownAndShrinkRange::new().build(input, input_min, input_max, scope)`.
pub fn quantize_down_and_shrink_range<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_min: O1,
    input_max: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizeDownAndShrinkRange::new().build(input, input_min, input_max, scope)
}
/// Builder for the `QuantizeV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizeV2 {
    T: ::std::option::Option<crate::DataType>,
    mode: ::std::option::Option<::std::string::String>,
    round_mode: ::std::option::Option<::std::string::String>,
    narrow_range: ::std::option::Option<bool>,
    axis: ::std::option::Option<i64>,
    ensure_minimum_range: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizeV2 {
    /// Creates a new `QuantizeV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `mode` attribute.
    pub fn mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `round_mode` attribute.
    pub fn round_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.round_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `narrow_range` attribute.
    pub fn narrow_range<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.narrow_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `axis` attribute.
    pub fn axis<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.axis = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ensure_minimum_range` attribute.
    pub fn ensure_minimum_range<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ensure_minimum_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizeV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        min_range: O1,
        max_range: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), min_range.into(), max_range.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        min_range: crate::Output,
        max_range: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizeV2", |nd| {
            nd.add_input(input);
            nd.add_input(min_range);
            nd.add_input(max_range);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.mode {
                nd.set_attr_string("mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.round_mode {
                nd.set_attr_string("round_mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.narrow_range {
                nd.set_attr_bool("narrow_range", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.axis {
                nd.set_attr_int("axis", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ensure_minimum_range {
                nd.set_attr_float("ensure_minimum_range", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizeV2::new().build(input, min_range, max_range, scope)`.
pub fn quantize_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    min_range: O1,
    max_range: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizeV2::new().build(input, min_range, max_range, scope)
}
/// Builder for the `QuantizedAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedAdd {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    Toutput: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedAdd {
    /// Creates a new `QuantizedAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput` attribute.
    pub fn Toutput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        min_x: O2,
        max_x: O3,
        min_y: O4,
        max_y: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            y.into(),
            min_x.into(),
            max_x.into(),
            min_y.into(),
            max_y.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        min_x: crate::Output,
        max_x: crate::Output,
        min_y: crate::Output,
        max_y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedAdd", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            nd.add_input(min_x);
            nd.add_input(max_x);
            nd.add_input(min_y);
            nd.add_input(max_y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput {
                nd.set_attr_type("Toutput", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedAdd::new().build(x, y, min_x, max_x, min_y, max_y, scope)`.
pub fn quantized_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    min_x: O2,
    max_x: O3,
    min_y: O4,
    max_y: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedAdd::new().build(x, y, min_x, max_x, min_y, max_y, scope)
}
/// Builder for the `QuantizedAvgPool` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedAvgPool {
    T: ::std::option::Option<crate::DataType>,
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedAvgPool {
    /// Creates a new `QuantizedAvgPool`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedAvgPool` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        min_input: O1,
        max_input: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), min_input.into(), max_input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedAvgPool", |nd| {
            nd.add_input(input);
            nd.add_input(min_input);
            nd.add_input(max_input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedAvgPool::new().build(input, min_input, max_input, scope)`.
pub fn quantized_avg_pool<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    min_input: O1,
    max_input: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedAvgPool::new().build(input, min_input, max_input, scope)
}
/// Builder for the `QuantizedBatchNormWithGlobalNormalization` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedBatchNormWithGlobalNormalization {
    Tinput: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    variance_epsilon: ::std::option::Option<f32>,
    scale_after_normalization: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedBatchNormWithGlobalNormalization {
    /// Creates a new `QuantizedBatchNormWithGlobalNormalization`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `variance_epsilon` attribute.
    pub fn variance_epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.variance_epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `scale_after_normalization` attribute.
    pub fn scale_after_normalization<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.scale_after_normalization = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedBatchNormWithGlobalNormalization` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
        O12: ::std::convert::Into<crate::Output>,
        O13: ::std::convert::Into<crate::Output>,
        O14: ::std::convert::Into<crate::Output>,
    >(
        &self,
        t: O0,
        t_min: O1,
        t_max: O2,
        m: O3,
        m_min: O4,
        m_max: O5,
        v: O6,
        v_min: O7,
        v_max: O8,
        beta: O9,
        beta_min: O10,
        beta_max: O11,
        gamma: O12,
        gamma_min: O13,
        gamma_max: O14,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            t.into(),
            t_min.into(),
            t_max.into(),
            m.into(),
            m_min.into(),
            m_max.into(),
            v.into(),
            v_min.into(),
            v_max.into(),
            beta.into(),
            beta_min.into(),
            beta_max.into(),
            gamma.into(),
            gamma_min.into(),
            gamma_max.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        t: crate::Output,
        t_min: crate::Output,
        t_max: crate::Output,
        m: crate::Output,
        m_min: crate::Output,
        m_max: crate::Output,
        v: crate::Output,
        v_min: crate::Output,
        v_max: crate::Output,
        beta: crate::Output,
        beta_min: crate::Output,
        beta_max: crate::Output,
        gamma: crate::Output,
        gamma_min: crate::Output,
        gamma_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedBatchNormWithGlobalNormalization", |nd| {
            nd.add_input(t);
            nd.add_input(t_min);
            nd.add_input(t_max);
            nd.add_input(m);
            nd.add_input(m_min);
            nd.add_input(m_max);
            nd.add_input(v);
            nd.add_input(v_min);
            nd.add_input(v_max);
            nd.add_input(beta);
            nd.add_input(beta_min);
            nd.add_input(beta_max);
            nd.add_input(gamma);
            nd.add_input(gamma_min);
            nd.add_input(gamma_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.variance_epsilon {
                nd.set_attr_float("variance_epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.scale_after_normalization {
                nd.set_attr_bool("scale_after_normalization", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedBatchNormWithGlobalNormalization::new().build(t, t_min, t_max, m, m_min, m_max, v, v_min, v_max, beta, beta_min, beta_max, gamma, gamma_min, gamma_max, scope)`.
pub fn quantized_batch_norm_with_global_normalization<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
    O12: ::std::convert::Into<crate::Output>,
    O13: ::std::convert::Into<crate::Output>,
    O14: ::std::convert::Into<crate::Output>,
>(
    t: O0,
    t_min: O1,
    t_max: O2,
    m: O3,
    m_min: O4,
    m_max: O5,
    v: O6,
    v_min: O7,
    v_max: O8,
    beta: O9,
    beta_min: O10,
    beta_max: O11,
    gamma: O12,
    gamma_min: O13,
    gamma_max: O14,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedBatchNormWithGlobalNormalization::new().build(
        t, t_min, t_max, m, m_min, m_max, v, v_min, v_max, beta, beta_min, beta_max, gamma,
        gamma_min, gamma_max, scope,
    )
}
/// Builder for the `QuantizedBiasAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedBiasAdd {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedBiasAdd {
    /// Creates a new `QuantizedBiasAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedBiasAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        bias: O1,
        min_input: O2,
        max_input: O3,
        min_bias: O4,
        max_bias: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_bias.into(),
            max_bias.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_bias: crate::Output,
        max_bias: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedBiasAdd", |nd| {
            nd.add_input(input);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_bias);
            nd.add_input(max_bias);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedBiasAdd::new().build(input, bias, min_input, max_input, min_bias, max_bias, scope)`.
pub fn quantized_bias_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    bias: O1,
    min_input: O2,
    max_input: O3,
    min_bias: O4,
    max_bias: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedBiasAdd::new().build(input, bias, min_input, max_input, min_bias, max_bias, scope)
}
/// Builder for the `QuantizedConcat` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConcat {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConcat {
    /// Creates a new `QuantizedConcat`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConcat` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        concat_dim: O0,
        values: O1,
        input_mins: O2,
        input_maxes: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            concat_dim.into(),
            values.into(),
            input_mins.into(),
            input_maxes.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        concat_dim: crate::Output,
        values: crate::Output,
        input_mins: crate::Output,
        input_maxes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConcat", |nd| {
            nd.add_input(concat_dim);
            nd.add_input(values);
            nd.add_input(input_mins);
            nd.add_input(input_maxes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConcat::new().build(concat_dim, values, input_mins, input_maxes, scope)`.
pub fn quantized_concat<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    concat_dim: O0,
    values: O1,
    input_mins: O2,
    input_maxes: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConcat::new().build(concat_dim, values, input_mins, input_maxes, scope)
}
/// Builder for the `QuantizedConv2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2D {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2D {
    /// Creates a new `QuantizedConv2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        min_input: O2,
        max_input: O3,
        min_filter: O4,
        max_filter: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2D", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2D::new().build(input, filter, min_input, max_input, min_filter, max_filter, scope)`.
pub fn quantized_conv2_d<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    min_input: O2,
    max_input: O3,
    min_filter: O4,
    max_filter: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2D::new().build(
        input, filter, min_input, max_input, min_filter, max_filter, scope,
    )
}
/// Builder for the `QuantizedConv2DAndRelu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DAndRelu {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DAndRelu {
    /// Creates a new `QuantizedConv2DAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DAndRelu` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        min_input: O2,
        max_input: O3,
        min_filter: O4,
        max_filter: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DAndRelu", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DAndRelu::new().build(input, filter, min_input, max_input, min_filter, max_filter, scope)`.
pub fn quantized_conv2_dand_relu<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    min_input: O2,
    max_input: O3,
    min_filter: O4,
    max_filter: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DAndRelu::new().build(
        input, filter, min_input, max_input, min_filter, max_filter, scope,
    )
}
/// Builder for the `QuantizedConv2DAndReluAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DAndReluAndRequantize {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DAndReluAndRequantize {
    /// Creates a new `QuantizedConv2DAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DAndReluAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        min_input: O2,
        max_input: O3,
        min_filter: O4,
        max_filter: O5,
        min_freezed_output: O6,
        max_freezed_output: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DAndReluAndRequantize", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            nd.add_input(min_freezed_output);
            nd.add_input(max_freezed_output);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DAndReluAndRequantize::new().build(input, filter, min_input, max_input, min_filter, max_filter, min_freezed_output, max_freezed_output, scope)`.
pub fn quantized_conv2_dand_relu_and_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    min_input: O2,
    max_input: O3,
    min_filter: O4,
    max_filter: O5,
    min_freezed_output: O6,
    max_freezed_output: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DAndReluAndRequantize::new().build(
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        scope,
    )
}
/// Builder for the `QuantizedConv2DAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DAndRequantize {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DAndRequantize {
    /// Creates a new `QuantizedConv2DAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        min_input: O2,
        max_input: O3,
        min_filter: O4,
        max_filter: O5,
        min_freezed_output: O6,
        max_freezed_output: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DAndRequantize", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            nd.add_input(min_freezed_output);
            nd.add_input(max_freezed_output);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DAndRequantize::new().build(input, filter, min_input, max_input, min_filter, max_filter, min_freezed_output, max_freezed_output, scope)`.
pub fn quantized_conv2_dand_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    min_input: O2,
    max_input: O3,
    min_filter: O4,
    max_filter: O5,
    min_freezed_output: O6,
    max_freezed_output: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DAndRequantize::new().build(
        input,
        filter,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        scope,
    )
}
/// Builder for the `QuantizedConv2DPerChannel` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DPerChannel {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DPerChannel {
    /// Creates a new `QuantizedConv2DPerChannel`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DPerChannel` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        min_input: O2,
        max_input: O3,
        min_filter: O4,
        max_filter: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DPerChannel", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DPerChannel::new().build(input, filter, min_input, max_input, min_filter, max_filter, scope)`.
pub fn quantized_conv2_dper_channel<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    min_input: O2,
    max_input: O3,
    min_filter: O4,
    max_filter: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DPerChannel::new().build(
        input, filter, min_input, max_input, min_filter, max_filter, scope,
    )
}
/// Builder for the `QuantizedConv2DWithBias` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBias {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DWithBias {
    /// Creates a new `QuantizedConv2DWithBias`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DWithBias` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DWithBias", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DWithBias::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, scope)`.
pub fn quantized_conv2_dwith_bias<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DWithBias::new().build(
        input, filter, bias, min_input, max_input, min_filter, max_filter, scope,
    )
}
/// Builder for the `QuantizedConv2DWithBiasAndRelu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasAndRelu {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DWithBiasAndRelu {
    /// Creates a new `QuantizedConv2DWithBiasAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DWithBiasAndRelu` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DWithBiasAndRelu", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DWithBiasAndRelu::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, scope)`.
pub fn quantized_conv2_dwith_bias_and_relu<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DWithBiasAndRelu::new().build(
        input, filter, bias, min_input, max_input, min_filter, max_filter, scope,
    )
}
/// Builder for the `QuantizedConv2DWithBiasAndReluAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasAndReluAndRequantize {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DWithBiasAndReluAndRequantize {
    /// Creates a new `QuantizedConv2DWithBiasAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DWithBiasAndReluAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        min_freezed_output: O7,
        max_freezed_output: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DWithBiasAndReluAndRequantize", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            nd.add_input(min_freezed_output);
            nd.add_input(max_freezed_output);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tbias {
                nd.set_attr_type("Tbias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DWithBiasAndReluAndRequantize::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, min_freezed_output, max_freezed_output, scope)`.
pub fn quantized_conv2_dwith_bias_and_relu_and_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    min_freezed_output: O7,
    max_freezed_output: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DWithBiasAndReluAndRequantize::new().build(
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        scope,
    )
}
/// Builder for the `QuantizedConv2DWithBiasAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasAndRequantize {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DWithBiasAndRequantize {
    /// Creates a new `QuantizedConv2DWithBiasAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DWithBiasAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        min_freezed_output: O7,
        max_freezed_output: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DWithBiasAndRequantize", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            nd.add_input(min_freezed_output);
            nd.add_input(max_freezed_output);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tbias {
                nd.set_attr_type("Tbias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DWithBiasAndRequantize::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, min_freezed_output, max_freezed_output, scope)`.
pub fn quantized_conv2_dwith_bias_and_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    min_freezed_output: O7,
    max_freezed_output: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DWithBiasAndRequantize::new().build(
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        scope,
    )
}
/// Builder for the `QuantizedConv2DWithBiasSignedSumAndReluAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasSignedSumAndReluAndRequantize {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    Tsummand: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DWithBiasSignedSumAndReluAndRequantize {
    /// Creates a new `QuantizedConv2DWithBiasSignedSumAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsummand` attribute.
    pub fn Tsummand<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsummand = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DWithBiasSignedSumAndReluAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        min_freezed_output: O7,
        max_freezed_output: O8,
        summand: O9,
        min_summand: O10,
        max_summand: O11,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            summand.into(),
            min_summand.into(),
            max_summand.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        summand: crate::Output,
        min_summand: crate::Output,
        max_summand: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "QuantizedConv2DWithBiasSignedSumAndReluAndRequantize",
            |nd| {
                nd.add_input(input);
                nd.add_input(filter);
                nd.add_input(bias);
                nd.add_input(min_input);
                nd.add_input(max_input);
                nd.add_input(min_filter);
                nd.add_input(max_filter);
                nd.add_input(min_freezed_output);
                nd.add_input(max_freezed_output);
                nd.add_input(summand);
                nd.add_input(min_summand);
                nd.add_input(max_summand);
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.Tinput {
                    nd.set_attr_type("Tinput", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.Tfilter {
                    nd.set_attr_type("Tfilter", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.Tbias {
                    nd.set_attr_type("Tbias", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.Tsummand {
                    nd.set_attr_type("Tsummand", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.out_type {
                    nd.set_attr_type("out_type", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.strides {
                    nd.set_attr_int_list("strides", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.padding {
                    nd.set_attr_string("padding", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.dilations {
                    nd.set_attr_int_list("dilations", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.padding_list {
                    nd.set_attr_int_list("padding_list", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `QuantizedConv2DWithBiasSignedSumAndReluAndRequantize::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, min_freezed_output, max_freezed_output, summand, min_summand, max_summand, scope)`.
pub fn quantized_conv2_dwith_bias_signed_sum_and_relu_and_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    min_freezed_output: O7,
    max_freezed_output: O8,
    summand: O9,
    min_summand: O10,
    max_summand: O11,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DWithBiasSignedSumAndReluAndRequantize::new().build(
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        summand,
        min_summand,
        max_summand,
        scope,
    )
}
/// Builder for the `QuantizedConv2DWithBiasSumAndRelu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasSumAndRelu {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DWithBiasSumAndRelu {
    /// Creates a new `QuantizedConv2DWithBiasSumAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DWithBiasSumAndRelu` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        summand: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            summand.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        summand: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DWithBiasSumAndRelu", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            nd.add_input(summand);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DWithBiasSumAndRelu::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, summand, scope)`.
pub fn quantized_conv2_dwith_bias_sum_and_relu<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    summand: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DWithBiasSumAndRelu::new().build(
        input, filter, bias, min_input, max_input, min_filter, max_filter, summand, scope,
    )
}
/// Builder for the `QuantizedConv2DWithBiasSumAndReluAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedConv2DWithBiasSumAndReluAndRequantize {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    Tsummand: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedConv2DWithBiasSumAndReluAndRequantize {
    /// Creates a new `QuantizedConv2DWithBiasSumAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsummand` attribute.
    pub fn Tsummand<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsummand = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedConv2DWithBiasSumAndReluAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
        O11: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        min_freezed_output: O7,
        max_freezed_output: O8,
        summand: O9,
        min_summand: O10,
        max_summand: O11,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            summand.into(),
            min_summand.into(),
            max_summand.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        summand: crate::Output,
        min_summand: crate::Output,
        max_summand: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedConv2DWithBiasSumAndReluAndRequantize", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            nd.add_input(min_freezed_output);
            nd.add_input(max_freezed_output);
            nd.add_input(summand);
            nd.add_input(min_summand);
            nd.add_input(max_summand);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tbias {
                nd.set_attr_type("Tbias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsummand {
                nd.set_attr_type("Tsummand", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedConv2DWithBiasSumAndReluAndRequantize::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, min_freezed_output, max_freezed_output, summand, min_summand, max_summand, scope)`.
pub fn quantized_conv2_dwith_bias_sum_and_relu_and_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
    O11: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    min_freezed_output: O7,
    max_freezed_output: O8,
    summand: O9,
    min_summand: O10,
    max_summand: O11,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedConv2DWithBiasSumAndReluAndRequantize::new().build(
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        summand,
        min_summand,
        max_summand,
        scope,
    )
}
/// Builder for the `QuantizedDepthwiseConv2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedDepthwiseConv2D {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedDepthwiseConv2D {
    /// Creates a new `QuantizedDepthwiseConv2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedDepthwiseConv2D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        min_input: O2,
        max_input: O3,
        min_filter: O4,
        max_filter: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedDepthwiseConv2D", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedDepthwiseConv2D::new().build(input, filter, min_input, max_input, min_filter, max_filter, scope)`.
pub fn quantized_depthwise_conv2_d<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    min_input: O2,
    max_input: O3,
    min_filter: O4,
    max_filter: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedDepthwiseConv2D::new().build(
        input, filter, min_input, max_input, min_filter, max_filter, scope,
    )
}
/// Builder for the `QuantizedDepthwiseConv2DWithBias` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedDepthwiseConv2DWithBias {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedDepthwiseConv2DWithBias {
    /// Creates a new `QuantizedDepthwiseConv2DWithBias`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedDepthwiseConv2DWithBias` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedDepthwiseConv2DWithBias", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedDepthwiseConv2DWithBias::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, scope)`.
pub fn quantized_depthwise_conv2_dwith_bias<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedDepthwiseConv2DWithBias::new().build(
        input, filter, bias, min_input, max_input, min_filter, max_filter, scope,
    )
}
/// Builder for the `QuantizedDepthwiseConv2DWithBiasAndRelu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedDepthwiseConv2DWithBiasAndRelu {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedDepthwiseConv2DWithBiasAndRelu {
    /// Creates a new `QuantizedDepthwiseConv2DWithBiasAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedDepthwiseConv2DWithBiasAndRelu` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedDepthwiseConv2DWithBiasAndRelu", |nd| {
            nd.add_input(input);
            nd.add_input(filter);
            nd.add_input(bias);
            nd.add_input(min_input);
            nd.add_input(max_input);
            nd.add_input(min_filter);
            nd.add_input(max_filter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tfilter {
                nd.set_attr_type("Tfilter", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dilations {
                nd.set_attr_int_list("dilations", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_list {
                nd.set_attr_int_list("padding_list", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedDepthwiseConv2DWithBiasAndRelu::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, scope)`.
pub fn quantized_depthwise_conv2_dwith_bias_and_relu<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedDepthwiseConv2DWithBiasAndRelu::new().build(
        input, filter, bias, min_input, max_input, min_filter, max_filter, scope,
    )
}
/// Builder for the `QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize {
    Tinput: ::std::option::Option<crate::DataType>,
    Tfilter: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    dilations: ::std::option::Option<::std::vec::Vec<i64>>,
    padding_list: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize {
    /// Creates a new `QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tfilter` attribute.
    pub fn Tfilter<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tfilter = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dilations` attribute.
    pub fn dilations<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dilations = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_list` attribute.
    pub fn padding_list<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_list = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        filter: O1,
        bias: O2,
        min_input: O3,
        max_input: O4,
        min_filter: O5,
        max_filter: O6,
        min_freezed_output: O7,
        max_freezed_output: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            filter.into(),
            bias.into(),
            min_input.into(),
            max_input.into(),
            min_filter.into(),
            max_filter.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        filter: crate::Output,
        bias: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        min_filter: crate::Output,
        max_filter: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize",
            |nd| {
                nd.add_input(input);
                nd.add_input(filter);
                nd.add_input(bias);
                nd.add_input(min_input);
                nd.add_input(max_input);
                nd.add_input(min_filter);
                nd.add_input(max_filter);
                nd.add_input(min_freezed_output);
                nd.add_input(max_freezed_output);
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.Tinput {
                    nd.set_attr_type("Tinput", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.Tfilter {
                    nd.set_attr_type("Tfilter", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.Tbias {
                    nd.set_attr_type("Tbias", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.out_type {
                    nd.set_attr_type("out_type", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.strides {
                    nd.set_attr_int_list("strides", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.padding {
                    nd.set_attr_string("padding", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.dilations {
                    nd.set_attr_int_list("dilations", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.padding_list {
                    nd.set_attr_int_list("padding_list", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize::new().build(input, filter, bias, min_input, max_input, min_filter, max_filter, min_freezed_output, max_freezed_output, scope)`.
pub fn quantized_depthwise_conv2_dwith_bias_and_relu_and_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    filter: O1,
    bias: O2,
    min_input: O3,
    max_input: O4,
    min_filter: O5,
    max_filter: O6,
    min_freezed_output: O7,
    max_freezed_output: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize::new().build(
        input,
        filter,
        bias,
        min_input,
        max_input,
        min_filter,
        max_filter,
        min_freezed_output,
        max_freezed_output,
        scope,
    )
}
/// Builder for the `QuantizedInstanceNorm` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedInstanceNorm {
    T: ::std::option::Option<crate::DataType>,
    output_range_given: ::std::option::Option<bool>,
    given_y_min: ::std::option::Option<f32>,
    given_y_max: ::std::option::Option<f32>,
    variance_epsilon: ::std::option::Option<f32>,
    min_separation: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedInstanceNorm {
    /// Creates a new `QuantizedInstanceNorm`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_range_given` attribute.
    pub fn output_range_given<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_range_given = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `given_y_min` attribute.
    pub fn given_y_min<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.given_y_min = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `given_y_max` attribute.
    pub fn given_y_max<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.given_y_max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `variance_epsilon` attribute.
    pub fn variance_epsilon<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.variance_epsilon = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `min_separation` attribute.
    pub fn min_separation<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.min_separation = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedInstanceNorm` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        x_min: O1,
        x_max: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), x_min.into(), x_max.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        x_min: crate::Output,
        x_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedInstanceNorm", |nd| {
            nd.add_input(x);
            nd.add_input(x_min);
            nd.add_input(x_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_range_given {
                nd.set_attr_bool("output_range_given", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.given_y_min {
                nd.set_attr_float("given_y_min", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.given_y_max {
                nd.set_attr_float("given_y_max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.variance_epsilon {
                nd.set_attr_float("variance_epsilon", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.min_separation {
                nd.set_attr_float("min_separation", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedInstanceNorm::new().build(x, x_min, x_max, scope)`.
pub fn quantized_instance_norm<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    x_min: O1,
    x_max: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedInstanceNorm::new().build(x, x_min, x_max, scope)
}
/// Builder for the `QuantizedMatMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMul {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    Toutput: ::std::option::Option<crate::DataType>,
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    Tactivation: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedMatMul {
    /// Creates a new `QuantizedMatMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput` attribute.
    pub fn Toutput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tactivation` attribute.
    pub fn Tactivation<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tactivation = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedMatMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        min_a: O2,
        max_a: O3,
        min_b: O4,
        max_b: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a.into(),
            b.into(),
            min_a.into(),
            max_a.into(),
            min_b.into(),
            max_b.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        min_a: crate::Output,
        max_a: crate::Output,
        min_b: crate::Output,
        max_b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedMatMul", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            nd.add_input(min_a);
            nd.add_input(max_a);
            nd.add_input(min_b);
            nd.add_input(max_b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput {
                nd.set_attr_type("Toutput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tactivation {
                nd.set_attr_type("Tactivation", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedMatMul::new().build(a, b, min_a, max_a, min_b, max_b, scope)`.
pub fn quantized_mat_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    min_a: O2,
    max_a: O3,
    min_b: O4,
    max_b: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedMatMul::new().build(a, b, min_a, max_a, min_b, max_b, scope)
}
/// Builder for the `QuantizedMatMulWithBias` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBias {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    Toutput: ::std::option::Option<crate::DataType>,
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    input_quant_mode: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedMatMulWithBias {
    /// Creates a new `QuantizedMatMulWithBias`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput` attribute.
    pub fn Toutput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_quant_mode` attribute.
    pub fn input_quant_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_quant_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedMatMulWithBias` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        bias: O2,
        min_a: O3,
        max_a: O4,
        min_b: O5,
        max_b: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a.into(),
            b.into(),
            bias.into(),
            min_a.into(),
            max_a.into(),
            min_b.into(),
            max_b.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        bias: crate::Output,
        min_a: crate::Output,
        max_a: crate::Output,
        min_b: crate::Output,
        max_b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedMatMulWithBias", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            nd.add_input(bias);
            nd.add_input(min_a);
            nd.add_input(max_a);
            nd.add_input(min_b);
            nd.add_input(max_b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tbias {
                nd.set_attr_type("Tbias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput {
                nd.set_attr_type("Toutput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_quant_mode {
                nd.set_attr_string("input_quant_mode", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedMatMulWithBias::new().build(a, b, bias, min_a, max_a, min_b, max_b, scope)`.
pub fn quantized_mat_mul_with_bias<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    bias: O2,
    min_a: O3,
    max_a: O4,
    min_b: O5,
    max_b: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedMatMulWithBias::new().build(a, b, bias, min_a, max_a, min_b, max_b, scope)
}
/// Builder for the `QuantizedMatMulWithBiasAndDequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBiasAndDequantize {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    Toutput: ::std::option::Option<crate::DataType>,
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    input_quant_mode: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedMatMulWithBiasAndDequantize {
    /// Creates a new `QuantizedMatMulWithBiasAndDequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput` attribute.
    pub fn Toutput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_quant_mode` attribute.
    pub fn input_quant_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_quant_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedMatMulWithBiasAndDequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        bias: O2,
        min_a: O3,
        max_a: O4,
        min_b: O5,
        max_b: O6,
        min_freezed_output: O7,
        max_freezed_output: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a.into(),
            b.into(),
            bias.into(),
            min_a.into(),
            max_a.into(),
            min_b.into(),
            max_b.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        bias: crate::Output,
        min_a: crate::Output,
        max_a: crate::Output,
        min_b: crate::Output,
        max_b: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedMatMulWithBiasAndDequantize", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            nd.add_input(bias);
            nd.add_input(min_a);
            nd.add_input(max_a);
            nd.add_input(min_b);
            nd.add_input(max_b);
            nd.add_input(min_freezed_output);
            nd.add_input(max_freezed_output);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tbias {
                nd.set_attr_type("Tbias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput {
                nd.set_attr_type("Toutput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_quant_mode {
                nd.set_attr_string("input_quant_mode", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedMatMulWithBiasAndDequantize::new().build(a, b, bias, min_a, max_a, min_b, max_b, min_freezed_output, max_freezed_output, scope)`.
pub fn quantized_mat_mul_with_bias_and_dequantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    bias: O2,
    min_a: O3,
    max_a: O4,
    min_b: O5,
    max_b: O6,
    min_freezed_output: O7,
    max_freezed_output: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedMatMulWithBiasAndDequantize::new().build(
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        scope,
    )
}
/// Builder for the `QuantizedMatMulWithBiasAndRelu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBiasAndRelu {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    Toutput: ::std::option::Option<crate::DataType>,
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    input_quant_mode: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedMatMulWithBiasAndRelu {
    /// Creates a new `QuantizedMatMulWithBiasAndRelu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput` attribute.
    pub fn Toutput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_quant_mode` attribute.
    pub fn input_quant_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_quant_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedMatMulWithBiasAndRelu` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        bias: O2,
        min_a: O3,
        max_a: O4,
        min_b: O5,
        max_b: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a.into(),
            b.into(),
            bias.into(),
            min_a.into(),
            max_a.into(),
            min_b.into(),
            max_b.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        bias: crate::Output,
        min_a: crate::Output,
        max_a: crate::Output,
        min_b: crate::Output,
        max_b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedMatMulWithBiasAndRelu", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            nd.add_input(bias);
            nd.add_input(min_a);
            nd.add_input(max_a);
            nd.add_input(min_b);
            nd.add_input(max_b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput {
                nd.set_attr_type("Toutput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_quant_mode {
                nd.set_attr_string("input_quant_mode", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedMatMulWithBiasAndRelu::new().build(a, b, bias, min_a, max_a, min_b, max_b, scope)`.
pub fn quantized_mat_mul_with_bias_and_relu<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    bias: O2,
    min_a: O3,
    max_a: O4,
    min_b: O5,
    max_b: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedMatMulWithBiasAndRelu::new().build(a, b, bias, min_a, max_a, min_b, max_b, scope)
}
/// Builder for the `QuantizedMatMulWithBiasAndReluAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBiasAndReluAndRequantize {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    Toutput: ::std::option::Option<crate::DataType>,
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    input_quant_mode: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedMatMulWithBiasAndReluAndRequantize {
    /// Creates a new `QuantizedMatMulWithBiasAndReluAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput` attribute.
    pub fn Toutput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_quant_mode` attribute.
    pub fn input_quant_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_quant_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedMatMulWithBiasAndReluAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        bias: O2,
        min_a: O3,
        max_a: O4,
        min_b: O5,
        max_b: O6,
        min_freezed_output: O7,
        max_freezed_output: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a.into(),
            b.into(),
            bias.into(),
            min_a.into(),
            max_a.into(),
            min_b.into(),
            max_b.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        bias: crate::Output,
        min_a: crate::Output,
        max_a: crate::Output,
        min_b: crate::Output,
        max_b: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedMatMulWithBiasAndReluAndRequantize", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            nd.add_input(bias);
            nd.add_input(min_a);
            nd.add_input(max_a);
            nd.add_input(min_b);
            nd.add_input(max_b);
            nd.add_input(min_freezed_output);
            nd.add_input(max_freezed_output);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tbias {
                nd.set_attr_type("Tbias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput {
                nd.set_attr_type("Toutput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_quant_mode {
                nd.set_attr_string("input_quant_mode", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedMatMulWithBiasAndReluAndRequantize::new().build(a, b, bias, min_a, max_a, min_b, max_b, min_freezed_output, max_freezed_output, scope)`.
pub fn quantized_mat_mul_with_bias_and_relu_and_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    bias: O2,
    min_a: O3,
    max_a: O4,
    min_b: O5,
    max_b: O6,
    min_freezed_output: O7,
    max_freezed_output: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedMatMulWithBiasAndReluAndRequantize::new().build(
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        scope,
    )
}
/// Builder for the `QuantizedMatMulWithBiasAndRequantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMatMulWithBiasAndRequantize {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    Tbias: ::std::option::Option<crate::DataType>,
    Toutput: ::std::option::Option<crate::DataType>,
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    input_quant_mode: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedMatMulWithBiasAndRequantize {
    /// Creates a new `QuantizedMatMulWithBiasAndRequantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tbias` attribute.
    pub fn Tbias<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tbias = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput` attribute.
    pub fn Toutput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_quant_mode` attribute.
    pub fn input_quant_mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_quant_mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedMatMulWithBiasAndRequantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        bias: O2,
        min_a: O3,
        max_a: O4,
        min_b: O5,
        max_b: O6,
        min_freezed_output: O7,
        max_freezed_output: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a.into(),
            b.into(),
            bias.into(),
            min_a.into(),
            max_a.into(),
            min_b.into(),
            max_b.into(),
            min_freezed_output.into(),
            max_freezed_output.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        bias: crate::Output,
        min_a: crate::Output,
        max_a: crate::Output,
        min_b: crate::Output,
        max_b: crate::Output,
        min_freezed_output: crate::Output,
        max_freezed_output: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedMatMulWithBiasAndRequantize", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            nd.add_input(bias);
            nd.add_input(min_a);
            nd.add_input(max_a);
            nd.add_input(min_b);
            nd.add_input(max_b);
            nd.add_input(min_freezed_output);
            nd.add_input(max_freezed_output);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tbias {
                nd.set_attr_type("Tbias", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput {
                nd.set_attr_type("Toutput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_quant_mode {
                nd.set_attr_string("input_quant_mode", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedMatMulWithBiasAndRequantize::new().build(a, b, bias, min_a, max_a, min_b, max_b, min_freezed_output, max_freezed_output, scope)`.
pub fn quantized_mat_mul_with_bias_and_requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    bias: O2,
    min_a: O3,
    max_a: O4,
    min_b: O5,
    max_b: O6,
    min_freezed_output: O7,
    max_freezed_output: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedMatMulWithBiasAndRequantize::new().build(
        a,
        b,
        bias,
        min_a,
        max_a,
        min_b,
        max_b,
        min_freezed_output,
        max_freezed_output,
        scope,
    )
}
/// Builder for the `QuantizedMaxPool` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMaxPool {
    T: ::std::option::Option<crate::DataType>,
    ksize: ::std::option::Option<::std::vec::Vec<i64>>,
    strides: ::std::option::Option<::std::vec::Vec<i64>>,
    padding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedMaxPool {
    /// Creates a new `QuantizedMaxPool`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ksize` attribute.
    pub fn ksize<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ksize = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `strides` attribute.
    pub fn strides<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.strides = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding` attribute.
    pub fn padding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedMaxPool` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        min_input: O1,
        max_input: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), min_input.into(), max_input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        min_input: crate::Output,
        max_input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedMaxPool", |nd| {
            nd.add_input(input);
            nd.add_input(min_input);
            nd.add_input(max_input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ksize {
                nd.set_attr_int_list("ksize", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.strides {
                nd.set_attr_int_list("strides", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding {
                nd.set_attr_string("padding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedMaxPool::new().build(input, min_input, max_input, scope)`.
pub fn quantized_max_pool<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    min_input: O1,
    max_input: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedMaxPool::new().build(input, min_input, max_input, scope)
}
/// Builder for the `QuantizedMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedMul {
    T1: ::std::option::Option<crate::DataType>,
    T2: ::std::option::Option<crate::DataType>,
    Toutput: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedMul {
    /// Creates a new `QuantizedMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T1` attribute.
    pub fn T1<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T2` attribute.
    pub fn T2<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutput` attribute.
    pub fn Toutput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        min_x: O2,
        max_x: O3,
        min_y: O4,
        max_y: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            x.into(),
            y.into(),
            min_x.into(),
            max_x.into(),
            min_y.into(),
            max_y.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        min_x: crate::Output,
        max_x: crate::Output,
        min_y: crate::Output,
        max_y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedMul", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            nd.add_input(min_x);
            nd.add_input(max_x);
            nd.add_input(min_y);
            nd.add_input(max_y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T1 {
                nd.set_attr_type("T1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T2 {
                nd.set_attr_type("T2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutput {
                nd.set_attr_type("Toutput", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedMul::new().build(x, y, min_x, max_x, min_y, max_y, scope)`.
pub fn quantized_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    min_x: O2,
    max_x: O3,
    min_y: O4,
    max_y: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedMul::new().build(x, y, min_x, max_x, min_y, max_y, scope)
}
/// Builder for the `QuantizedRelu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedRelu {
    Tinput: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedRelu {
    /// Creates a new `QuantizedRelu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedRelu` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        features: O0,
        min_features: O1,
        max_features: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            features.into(),
            min_features.into(),
            max_features.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        features: crate::Output,
        min_features: crate::Output,
        max_features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedRelu", |nd| {
            nd.add_input(features);
            nd.add_input(min_features);
            nd.add_input(max_features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedRelu::new().build(features, min_features, max_features, scope)`.
pub fn quantized_relu<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    features: O0,
    min_features: O1,
    max_features: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedRelu::new().build(features, min_features, max_features, scope)
}
/// Builder for the `QuantizedRelu6` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedRelu6 {
    Tinput: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedRelu6 {
    /// Creates a new `QuantizedRelu6`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedRelu6` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        features: O0,
        min_features: O1,
        max_features: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            features.into(),
            min_features.into(),
            max_features.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        features: crate::Output,
        min_features: crate::Output,
        max_features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedRelu6", |nd| {
            nd.add_input(features);
            nd.add_input(min_features);
            nd.add_input(max_features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedRelu6::new().build(features, min_features, max_features, scope)`.
pub fn quantized_relu6<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    features: O0,
    min_features: O1,
    max_features: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedRelu6::new().build(features, min_features, max_features, scope)
}
/// Builder for the `QuantizedReluX` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedReluX {
    Tinput: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedReluX {
    /// Creates a new `QuantizedReluX`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedReluX` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        features: O0,
        max_value: O1,
        min_features: O2,
        max_features: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            features.into(),
            max_value.into(),
            min_features.into(),
            max_features.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        features: crate::Output,
        max_value: crate::Output,
        min_features: crate::Output,
        max_features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedReluX", |nd| {
            nd.add_input(features);
            nd.add_input(max_value);
            nd.add_input(min_features);
            nd.add_input(max_features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedReluX::new().build(features, max_value, min_features, max_features, scope)`.
pub fn quantized_relu_x<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    features: O0,
    max_value: O1,
    min_features: O2,
    max_features: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedReluX::new().build(features, max_value, min_features, max_features, scope)
}
/// Builder for the `QuantizedReshape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedReshape {
    T: ::std::option::Option<crate::DataType>,
    Tshape: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedReshape {
    /// Creates a new `QuantizedReshape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tshape` attribute.
    pub fn Tshape<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tshape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedReshape` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        shape: O1,
        input_min: O2,
        input_max: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tensor.into(),
            shape.into(),
            input_min.into(),
            input_max.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        shape: crate::Output,
        input_min: crate::Output,
        input_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedReshape", |nd| {
            nd.add_input(tensor);
            nd.add_input(shape);
            nd.add_input(input_min);
            nd.add_input(input_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tshape {
                nd.set_attr_type("Tshape", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedReshape::new().build(tensor, shape, input_min, input_max, scope)`.
pub fn quantized_reshape<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    shape: O1,
    input_min: O2,
    input_max: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedReshape::new().build(tensor, shape, input_min, input_max, scope)
}
/// Builder for the `QuantizedResizeBilinear` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QuantizedResizeBilinear {
    T: ::std::option::Option<crate::DataType>,
    align_corners: ::std::option::Option<bool>,
    half_pixel_centers: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QuantizedResizeBilinear {
    /// Creates a new `QuantizedResizeBilinear`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align_corners` attribute.
    pub fn align_corners<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `half_pixel_centers` attribute.
    pub fn half_pixel_centers<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.half_pixel_centers = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QuantizedResizeBilinear` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        size: O1,
        min: O2,
        max: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), size.into(), min.into(), max.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        size: crate::Output,
        min: crate::Output,
        max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QuantizedResizeBilinear", |nd| {
            nd.add_input(images);
            nd.add_input(size);
            nd.add_input(min);
            nd.add_input(max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align_corners {
                nd.set_attr_bool("align_corners", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.half_pixel_centers {
                nd.set_attr_bool("half_pixel_centers", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QuantizedResizeBilinear::new().build(images, size, min, max, scope)`.
pub fn quantized_resize_bilinear<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    size: O1,
    min: O2,
    max: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QuantizedResizeBilinear::new().build(images, size, min, max, scope)
}
/// Builder for the `QueueClose` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueClose {
    cancel_pending_enqueues: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueClose {
    /// Creates a new `QueueClose`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `cancel_pending_enqueues` attribute.
    pub fn cancel_pending_enqueues<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.cancel_pending_enqueues = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueClose` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueClose", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.cancel_pending_enqueues {
                nd.set_attr_bool("cancel_pending_enqueues", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueClose::new().build(handle, scope)`.
pub fn queue_close<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueClose::new().build(handle, scope)
}
/// Builder for the `QueueCloseV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueCloseV2 {
    cancel_pending_enqueues: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueCloseV2 {
    /// Creates a new `QueueCloseV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `cancel_pending_enqueues` attribute.
    pub fn cancel_pending_enqueues<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.cancel_pending_enqueues = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueCloseV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueCloseV2", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.cancel_pending_enqueues {
                nd.set_attr_bool("cancel_pending_enqueues", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueCloseV2::new().build(handle, scope)`.
pub fn queue_close_v2<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueCloseV2::new().build(handle, scope)
}
/// Builder for the `QueueDequeue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeue {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueDequeue {
    /// Creates a new `QueueDequeue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueDequeue` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueDequeue", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueDequeue::new().build(handle, scope)`.
pub fn queue_dequeue<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueDequeue::new().build(handle, scope)
}
/// Builder for the `QueueDequeueMany` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueMany {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueDequeueMany {
    /// Creates a new `QueueDequeueMany`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueDequeueMany` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        n: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), n.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        n: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueDequeueMany", |nd| {
            nd.add_input(handle);
            nd.add_input(n);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueDequeueMany::new().build(handle, n, scope)`.
pub fn queue_dequeue_many<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    n: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueDequeueMany::new().build(handle, n, scope)
}
/// Builder for the `QueueDequeueManyV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueManyV2 {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueDequeueManyV2 {
    /// Creates a new `QueueDequeueManyV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueDequeueManyV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        n: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), n.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        n: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueDequeueManyV2", |nd| {
            nd.add_input(handle);
            nd.add_input(n);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueDequeueManyV2::new().build(handle, n, scope)`.
pub fn queue_dequeue_many_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    n: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueDequeueManyV2::new().build(handle, n, scope)
}
/// Builder for the `QueueDequeueUpTo` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueUpTo {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueDequeueUpTo {
    /// Creates a new `QueueDequeueUpTo`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueDequeueUpTo` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        n: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), n.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        n: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueDequeueUpTo", |nd| {
            nd.add_input(handle);
            nd.add_input(n);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueDequeueUpTo::new().build(handle, n, scope)`.
pub fn queue_dequeue_up_to<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    n: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueDequeueUpTo::new().build(handle, n, scope)
}
/// Builder for the `QueueDequeueUpToV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueUpToV2 {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueDequeueUpToV2 {
    /// Creates a new `QueueDequeueUpToV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueDequeueUpToV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        n: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), n.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        n: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueDequeueUpToV2", |nd| {
            nd.add_input(handle);
            nd.add_input(n);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueDequeueUpToV2::new().build(handle, n, scope)`.
pub fn queue_dequeue_up_to_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    n: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueDequeueUpToV2::new().build(handle, n, scope)
}
/// Builder for the `QueueDequeueV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueDequeueV2 {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueDequeueV2 {
    /// Creates a new `QueueDequeueV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueDequeueV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueDequeueV2", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueDequeueV2::new().build(handle, scope)`.
pub fn queue_dequeue_v2<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueDequeueV2::new().build(handle, scope)
}
/// Builder for the `QueueEnqueue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueEnqueue {
    Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueEnqueue {
    /// Creates a new `QueueEnqueue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomponents` attribute.
    pub fn Tcomponents<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomponents = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueEnqueue` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        components: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), components.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        components: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueEnqueue", |nd| {
            nd.add_input(handle);
            nd.add_input(components);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomponents {
                nd.set_attr_type_list("Tcomponents", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueEnqueue::new().build(handle, components, scope)`.
pub fn queue_enqueue<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    components: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueEnqueue::new().build(handle, components, scope)
}
/// Builder for the `QueueEnqueueMany` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueEnqueueMany {
    Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueEnqueueMany {
    /// Creates a new `QueueEnqueueMany`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomponents` attribute.
    pub fn Tcomponents<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomponents = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueEnqueueMany` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        components: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), components.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        components: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueEnqueueMany", |nd| {
            nd.add_input(handle);
            nd.add_input(components);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomponents {
                nd.set_attr_type_list("Tcomponents", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueEnqueueMany::new().build(handle, components, scope)`.
pub fn queue_enqueue_many<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    components: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueEnqueueMany::new().build(handle, components, scope)
}
/// Builder for the `QueueEnqueueManyV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueEnqueueManyV2 {
    Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueEnqueueManyV2 {
    /// Creates a new `QueueEnqueueManyV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomponents` attribute.
    pub fn Tcomponents<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomponents = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueEnqueueManyV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        components: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), components.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        components: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueEnqueueManyV2", |nd| {
            nd.add_input(handle);
            nd.add_input(components);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomponents {
                nd.set_attr_type_list("Tcomponents", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueEnqueueManyV2::new().build(handle, components, scope)`.
pub fn queue_enqueue_many_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    components: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueEnqueueManyV2::new().build(handle, components, scope)
}
/// Builder for the `QueueEnqueueV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueEnqueueV2 {
    Tcomponents: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    timeout_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueEnqueueV2 {
    /// Creates a new `QueueEnqueueV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcomponents` attribute.
    pub fn Tcomponents<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomponents = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_ms` attribute.
    pub fn timeout_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueEnqueueV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        components: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), components.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        components: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueEnqueueV2", |nd| {
            nd.add_input(handle);
            nd.add_input(components);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcomponents {
                nd.set_attr_type_list("Tcomponents", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_ms {
                nd.set_attr_int("timeout_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueEnqueueV2::new().build(handle, components, scope)`.
pub fn queue_enqueue_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    components: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueEnqueueV2::new().build(handle, components, scope)
}
/// Builder for the `QueueIsClosed` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueIsClosed {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueIsClosed {
    /// Creates a new `QueueIsClosed`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueIsClosed` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueIsClosed", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueIsClosed::new().build(handle, scope)`.
pub fn queue_is_closed<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueIsClosed::new().build(handle, scope)
}
/// Builder for the `QueueIsClosedV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueIsClosedV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueIsClosedV2 {
    /// Creates a new `QueueIsClosedV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueIsClosedV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueIsClosedV2", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueIsClosedV2::new().build(handle, scope)`.
pub fn queue_is_closed_v2<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueIsClosedV2::new().build(handle, scope)
}
/// Builder for the `QueueSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueSize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueSize {
    /// Creates a new `QueueSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueSize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueSize", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueSize::new().build(handle, scope)`.
pub fn queue_size<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueSize::new().build(handle, scope)
}
/// Builder for the `QueueSizeV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct QueueSizeV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl QueueSizeV2 {
    /// Creates a new `QueueSizeV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `QueueSizeV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("QueueSizeV2", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `QueueSizeV2::new().build(handle, scope)`.
pub fn queue_size_v2<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    QueueSizeV2::new().build(handle, scope)
}
/// Builder for the `RFFT` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RFFT {
    Treal: ::std::option::Option<crate::DataType>,
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RFFT {
    /// Creates a new `RFFT`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Treal` attribute.
    pub fn Treal<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Treal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RFFT` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        fft_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), fft_length.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        fft_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RFFT", |nd| {
            nd.add_input(input);
            nd.add_input(fft_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Treal {
                nd.set_attr_type("Treal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RFFT::new().build(input, fft_length, scope)`.
pub fn rfft<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    fft_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RFFT::new().build(input, fft_length, scope)
}
/// Builder for the `RFFT2D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RFFT2D {
    Treal: ::std::option::Option<crate::DataType>,
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RFFT2D {
    /// Creates a new `RFFT2D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Treal` attribute.
    pub fn Treal<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Treal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RFFT2D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        fft_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), fft_length.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        fft_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RFFT2D", |nd| {
            nd.add_input(input);
            nd.add_input(fft_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Treal {
                nd.set_attr_type("Treal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RFFT2D::new().build(input, fft_length, scope)`.
pub fn rfft2_d<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    fft_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RFFT2D::new().build(input, fft_length, scope)
}
/// Builder for the `RFFT3D` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RFFT3D {
    Treal: ::std::option::Option<crate::DataType>,
    Tcomplex: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RFFT3D {
    /// Creates a new `RFFT3D`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Treal` attribute.
    pub fn Treal<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Treal = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tcomplex` attribute.
    pub fn Tcomplex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tcomplex = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RFFT3D` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        fft_length: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), fft_length.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        fft_length: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RFFT3D", |nd| {
            nd.add_input(input);
            nd.add_input(fft_length);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Treal {
                nd.set_attr_type("Treal", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tcomplex {
                nd.set_attr_type("Tcomplex", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RFFT3D::new().build(input, fft_length, scope)`.
pub fn rfft3_d<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    fft_length: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RFFT3D::new().build(input, fft_length, scope)
}
/// Builder for the `RGBToHSV` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RGBToHSV {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RGBToHSV {
    /// Creates a new `RGBToHSV`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RGBToHSV` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        images: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RGBToHSV", |nd| {
            nd.add_input(images);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RGBToHSV::new().build(images, scope)`.
pub fn rgbto_hsv<O0: ::std::convert::Into<crate::Output>>(
    images: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RGBToHSV::new().build(images, scope)
}
/// Builder for the `RaggedBincount` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedBincount {
    Tidx: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    binary_output: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedBincount {
    /// Creates a new `RaggedBincount`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `binary_output` attribute.
    pub fn binary_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.binary_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedBincount` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        splits: O0,
        values: O1,
        size: O2,
        weights: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            splits.into(),
            values.into(),
            size.into(),
            weights.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        splits: crate::Output,
        values: crate::Output,
        size: crate::Output,
        weights: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedBincount", |nd| {
            nd.add_input(splits);
            nd.add_input(values);
            nd.add_input(size);
            nd.add_input(weights);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.binary_output {
                nd.set_attr_bool("binary_output", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedBincount::new().build(splits, values, size, weights, scope)`.
pub fn ragged_bincount<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    splits: O0,
    values: O1,
    size: O2,
    weights: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedBincount::new().build(splits, values, size, weights, scope)
}
/// Builder for the `RaggedCountSparseOutput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedCountSparseOutput {
    T: ::std::option::Option<crate::DataType>,
    minlength: ::std::option::Option<i64>,
    maxlength: ::std::option::Option<i64>,
    binary_output: ::std::option::Option<bool>,
    output_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedCountSparseOutput {
    /// Creates a new `RaggedCountSparseOutput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `minlength` attribute.
    pub fn minlength<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.minlength = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `maxlength` attribute.
    pub fn maxlength<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.maxlength = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `binary_output` attribute.
    pub fn binary_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.binary_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_type` attribute.
    pub fn output_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedCountSparseOutput` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        splits: O0,
        values: O1,
        weights: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(splits.into(), values.into(), weights.into(), scope)
    }

    fn build_impl(
        &self,
        splits: crate::Output,
        values: crate::Output,
        weights: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedCountSparseOutput", |nd| {
            nd.add_input(splits);
            nd.add_input(values);
            nd.add_input(weights);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.minlength {
                nd.set_attr_int("minlength", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.maxlength {
                nd.set_attr_int("maxlength", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.binary_output {
                nd.set_attr_bool("binary_output", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_type {
                nd.set_attr_type("output_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedCountSparseOutput::new().build(splits, values, weights, scope)`.
pub fn ragged_count_sparse_output<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    splits: O0,
    values: O1,
    weights: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedCountSparseOutput::new().build(splits, values, weights, scope)
}
/// Builder for the `RaggedCross` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedCross {
    Nsparse: ::std::option::Option<i64>,
    input_order: ::std::option::Option<::std::string::String>,
    hashed_output: ::std::option::Option<bool>,
    num_buckets: ::std::option::Option<i64>,
    hash_key: ::std::option::Option<i64>,
    ragged_values_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    ragged_splits_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    sparse_values_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    out_values_type: ::std::option::Option<crate::DataType>,
    out_row_splits_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedCross {
    /// Creates a new `RaggedCross`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Nsparse` attribute.
    pub fn Nsparse<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.Nsparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `input_order` attribute.
    pub fn input_order<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_order = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `hashed_output` attribute.
    pub fn hashed_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.hashed_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_buckets` attribute.
    pub fn num_buckets<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `hash_key` attribute.
    pub fn hash_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.hash_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_values_types` attribute.
    pub fn ragged_values_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_values_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ragged_splits_types` attribute.
    pub fn ragged_splits_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ragged_splits_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_values_types` attribute.
    pub fn sparse_values_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_values_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_types` attribute.
    pub fn dense_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_values_type` attribute.
    pub fn out_values_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_values_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_row_splits_type` attribute.
    pub fn out_row_splits_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_row_splits_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedCross` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ragged_values: O0,
        ragged_row_splits: O1,
        sparse_indices: O2,
        sparse_values: O3,
        sparse_shape: O4,
        dense_inputs: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            ragged_values.into(),
            ragged_row_splits.into(),
            sparse_indices.into(),
            sparse_values.into(),
            sparse_shape.into(),
            dense_inputs.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        ragged_values: crate::Output,
        ragged_row_splits: crate::Output,
        sparse_indices: crate::Output,
        sparse_values: crate::Output,
        sparse_shape: crate::Output,
        dense_inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedCross", |nd| {
            nd.add_input(ragged_values);
            nd.add_input(ragged_row_splits);
            nd.add_input(sparse_indices);
            nd.add_input(sparse_values);
            nd.add_input(sparse_shape);
            nd.add_input(dense_inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Nsparse {
                nd.set_attr_int("Nsparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.input_order {
                nd.set_attr_string("input_order", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.hashed_output {
                nd.set_attr_bool("hashed_output", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_buckets {
                nd.set_attr_int("num_buckets", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.hash_key {
                nd.set_attr_int("hash_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_values_types {
                nd.set_attr_type_list("ragged_values_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ragged_splits_types {
                nd.set_attr_type_list("ragged_splits_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_values_types {
                nd.set_attr_type_list("sparse_values_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_types {
                nd.set_attr_type_list("dense_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_values_type {
                nd.set_attr_type("out_values_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_row_splits_type {
                nd.set_attr_type("out_row_splits_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedCross::new().build(ragged_values, ragged_row_splits, sparse_indices, sparse_values, sparse_shape, dense_inputs, scope)`.
pub fn ragged_cross<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    ragged_values: O0,
    ragged_row_splits: O1,
    sparse_indices: O2,
    sparse_values: O3,
    sparse_shape: O4,
    dense_inputs: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedCross::new().build(
        ragged_values,
        ragged_row_splits,
        sparse_indices,
        sparse_values,
        sparse_shape,
        dense_inputs,
        scope,
    )
}
/// Builder for the `RaggedGather` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedGather {
    Tvalues: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    Tsplits: ::std::option::Option<crate::DataType>,
    PARAMS_RAGGED_RANK: ::std::option::Option<i64>,
    OUTPUT_RAGGED_RANK: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedGather {
    /// Creates a new `RaggedGather`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tvalues` attribute.
    pub fn Tvalues<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tvalues = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `PARAMS_RAGGED_RANK` attribute.
    pub fn PARAMS_RAGGED_RANK<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.PARAMS_RAGGED_RANK = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `OUTPUT_RAGGED_RANK` attribute.
    pub fn OUTPUT_RAGGED_RANK<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.OUTPUT_RAGGED_RANK = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedGather` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        params_nested_splits: O0,
        params_dense_values: O1,
        indices: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            params_nested_splits.into(),
            params_dense_values.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        params_nested_splits: crate::Output,
        params_dense_values: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedGather", |nd| {
            nd.add_input(params_nested_splits);
            nd.add_input(params_dense_values);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tvalues {
                nd.set_attr_type("Tvalues", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.PARAMS_RAGGED_RANK {
                nd.set_attr_int("PARAMS_RAGGED_RANK", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.OUTPUT_RAGGED_RANK {
                nd.set_attr_int("OUTPUT_RAGGED_RANK", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedGather::new().build(params_nested_splits, params_dense_values, indices, scope)`.
pub fn ragged_gather<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    params_nested_splits: O0,
    params_dense_values: O1,
    indices: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedGather::new().build(params_nested_splits, params_dense_values, indices, scope)
}
/// Builder for the `RaggedRange` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedRange {
    T: ::std::option::Option<crate::DataType>,
    Tsplits: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedRange {
    /// Creates a new `RaggedRange`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedRange` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        starts: O0,
        limits: O1,
        deltas: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(starts.into(), limits.into(), deltas.into(), scope)
    }

    fn build_impl(
        &self,
        starts: crate::Output,
        limits: crate::Output,
        deltas: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedRange", |nd| {
            nd.add_input(starts);
            nd.add_input(limits);
            nd.add_input(deltas);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedRange::new().build(starts, limits, deltas, scope)`.
pub fn ragged_range<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    starts: O0,
    limits: O1,
    deltas: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedRange::new().build(starts, limits, deltas, scope)
}
/// Builder for the `RaggedTensorFromVariant` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorFromVariant {
    input_ragged_rank: ::std::option::Option<i64>,
    output_ragged_rank: ::std::option::Option<i64>,
    Tvalues: ::std::option::Option<crate::DataType>,
    Tsplits: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedTensorFromVariant {
    /// Creates a new `RaggedTensorFromVariant`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `input_ragged_rank` attribute.
    pub fn input_ragged_rank<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.input_ragged_rank = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_ragged_rank` attribute.
    pub fn output_ragged_rank<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_ragged_rank = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tvalues` attribute.
    pub fn Tvalues<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tvalues = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedTensorFromVariant` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        encoded_ragged: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(encoded_ragged.into(), scope)
    }

    fn build_impl(
        &self,
        encoded_ragged: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedTensorFromVariant", |nd| {
            nd.add_input(encoded_ragged);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.input_ragged_rank {
                nd.set_attr_int("input_ragged_rank", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_ragged_rank {
                nd.set_attr_int("output_ragged_rank", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tvalues {
                nd.set_attr_type("Tvalues", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedTensorFromVariant::new().build(encoded_ragged, scope)`.
pub fn ragged_tensor_from_variant<O0: ::std::convert::Into<crate::Output>>(
    encoded_ragged: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedTensorFromVariant::new().build(encoded_ragged, scope)
}
/// Builder for the `RaggedTensorToSparse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorToSparse {
    RAGGED_RANK: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    Tsplits: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedTensorToSparse {
    /// Creates a new `RaggedTensorToSparse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `RAGGED_RANK` attribute.
    pub fn RAGGED_RANK<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.RAGGED_RANK = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedTensorToSparse` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        rt_nested_splits: O0,
        rt_dense_values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(rt_nested_splits.into(), rt_dense_values.into(), scope)
    }

    fn build_impl(
        &self,
        rt_nested_splits: crate::Output,
        rt_dense_values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedTensorToSparse", |nd| {
            nd.add_input(rt_nested_splits);
            nd.add_input(rt_dense_values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.RAGGED_RANK {
                nd.set_attr_int("RAGGED_RANK", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedTensorToSparse::new().build(rt_nested_splits, rt_dense_values, scope)`.
pub fn ragged_tensor_to_sparse<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    rt_nested_splits: O0,
    rt_dense_values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedTensorToSparse::new().build(rt_nested_splits, rt_dense_values, scope)
}
/// Builder for the `RaggedTensorToTensor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorToTensor {
    T: ::std::option::Option<crate::DataType>,
    Tindex: ::std::option::Option<crate::DataType>,
    Tshape: ::std::option::Option<crate::DataType>,
    num_row_partition_tensors: ::std::option::Option<i64>,
    row_partition_types: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedTensorToTensor {
    /// Creates a new `RaggedTensorToTensor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindex` attribute.
    pub fn Tindex<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindex = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tshape` attribute.
    pub fn Tshape<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tshape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_row_partition_tensors` attribute.
    pub fn num_row_partition_tensors<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_row_partition_tensors = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `row_partition_types` attribute.
    pub fn row_partition_types<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.row_partition_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedTensorToTensor` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        values: O1,
        default_value: O2,
        row_partition_tensors: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            shape.into(),
            values.into(),
            default_value.into(),
            row_partition_tensors.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        values: crate::Output,
        default_value: crate::Output,
        row_partition_tensors: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedTensorToTensor", |nd| {
            nd.add_input(shape);
            nd.add_input(values);
            nd.add_input(default_value);
            nd.add_input(row_partition_tensors);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindex {
                nd.set_attr_type("Tindex", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tshape {
                nd.set_attr_type("Tshape", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_row_partition_tensors {
                nd.set_attr_int("num_row_partition_tensors", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.row_partition_types {
                nd.set_attr_string_list("row_partition_types", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedTensorToTensor::new().build(shape, values, default_value, row_partition_tensors, scope)`.
pub fn ragged_tensor_to_tensor<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    values: O1,
    default_value: O2,
    row_partition_tensors: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedTensorToTensor::new().build(shape, values, default_value, row_partition_tensors, scope)
}
/// Builder for the `RaggedTensorToVariant` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RaggedTensorToVariant {
    RAGGED_RANK: ::std::option::Option<i64>,
    Tvalues: ::std::option::Option<crate::DataType>,
    Tsplits: ::std::option::Option<crate::DataType>,
    batched_input: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RaggedTensorToVariant {
    /// Creates a new `RaggedTensorToVariant`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `RAGGED_RANK` attribute.
    pub fn RAGGED_RANK<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.RAGGED_RANK = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tvalues` attribute.
    pub fn Tvalues<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tvalues = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `batched_input` attribute.
    pub fn batched_input<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.batched_input = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RaggedTensorToVariant` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        rt_nested_splits: O0,
        rt_dense_values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(rt_nested_splits.into(), rt_dense_values.into(), scope)
    }

    fn build_impl(
        &self,
        rt_nested_splits: crate::Output,
        rt_dense_values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RaggedTensorToVariant", |nd| {
            nd.add_input(rt_nested_splits);
            nd.add_input(rt_dense_values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.RAGGED_RANK {
                nd.set_attr_int("RAGGED_RANK", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tvalues {
                nd.set_attr_type("Tvalues", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.batched_input {
                nd.set_attr_bool("batched_input", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RaggedTensorToVariant::new().build(rt_nested_splits, rt_dense_values, scope)`.
pub fn ragged_tensor_to_variant<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    rt_nested_splits: O0,
    rt_dense_values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RaggedTensorToVariant::new().build(rt_nested_splits, rt_dense_values, scope)
}
/// Builder for the `RandomCrop` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomCrop {
    T: ::std::option::Option<crate::DataType>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomCrop {
    /// Creates a new `RandomCrop`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomCrop` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        image: O0,
        size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(image.into(), size.into(), scope)
    }

    fn build_impl(
        &self,
        image: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomCrop", |nd| {
            nd.add_input(image);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomCrop::new().build(image, size, scope)`.
pub fn random_crop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    image: O0,
    size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomCrop::new().build(image, size, scope)
}
/// Builder for the `RandomDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomDataset {
    /// Creates a new `RandomDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        seed: O0,
        seed2: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(seed.into(), seed2.into(), scope)
    }

    fn build_impl(
        &self,
        seed: crate::Output,
        seed2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomDataset", |nd| {
            nd.add_input(seed);
            nd.add_input(seed2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomDataset::new().build(seed, seed2, scope)`.
pub fn random_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    seed: O0,
    seed2: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomDataset::new().build(seed, seed2, scope)
}
/// Builder for the `RandomGamma` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomGamma {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    S: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomGamma {
    /// Creates a new `RandomGamma`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `S` attribute.
    pub fn S<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.S = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomGamma` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        alpha: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), alpha.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        alpha: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomGamma", |nd| {
            nd.add_input(shape);
            nd.add_input(alpha);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.S {
                nd.set_attr_type("S", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomGamma::new().build(shape, alpha, scope)`.
pub fn random_gamma<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    alpha: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomGamma::new().build(shape, alpha, scope)
}
/// Builder for the `RandomGammaGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomGammaGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomGammaGrad {
    /// Creates a new `RandomGammaGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomGammaGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        alpha: O0,
        sample: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(alpha.into(), sample.into(), scope)
    }

    fn build_impl(
        &self,
        alpha: crate::Output,
        sample: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomGammaGrad", |nd| {
            nd.add_input(alpha);
            nd.add_input(sample);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomGammaGrad::new().build(alpha, sample, scope)`.
pub fn random_gamma_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    alpha: O0,
    sample: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomGammaGrad::new().build(alpha, sample, scope)
}
/// Builder for the `RandomPoisson` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomPoisson {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    S: ::std::option::Option<crate::DataType>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomPoisson {
    /// Creates a new `RandomPoisson`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `S` attribute.
    pub fn S<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.S = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomPoisson` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        rate: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), rate.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        rate: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomPoisson", |nd| {
            nd.add_input(shape);
            nd.add_input(rate);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.S {
                nd.set_attr_type("S", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomPoisson::new().build(shape, rate, scope)`.
pub fn random_poisson<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    rate: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomPoisson::new().build(shape, rate, scope)
}
/// Builder for the `RandomPoissonV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomPoissonV2 {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    S: ::std::option::Option<crate::DataType>,
    R: ::std::option::Option<crate::DataType>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomPoissonV2 {
    /// Creates a new `RandomPoissonV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `S` attribute.
    pub fn S<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.S = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `R` attribute.
    pub fn R<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.R = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomPoissonV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        rate: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), rate.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        rate: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomPoissonV2", |nd| {
            nd.add_input(shape);
            nd.add_input(rate);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.S {
                nd.set_attr_type("S", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.R {
                nd.set_attr_type("R", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomPoissonV2::new().build(shape, rate, scope)`.
pub fn random_poisson_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    rate: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomPoissonV2::new().build(shape, rate, scope)
}
/// Builder for the `RandomShuffle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomShuffle {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomShuffle {
    /// Creates a new `RandomShuffle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomShuffle` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        value: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomShuffle", |nd| {
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomShuffle::new().build(value, scope)`.
pub fn random_shuffle<O0: ::std::convert::Into<crate::Output>>(
    value: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomShuffle::new().build(value, scope)
}
/// Builder for the `RandomShuffleQueue` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomShuffleQueue {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    min_after_dequeue: ::std::option::Option<i64>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomShuffleQueue {
    /// Creates a new `RandomShuffleQueue`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `min_after_dequeue` attribute.
    pub fn min_after_dequeue<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.min_after_dequeue = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomShuffleQueue` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomShuffleQueue", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.min_after_dequeue {
                nd.set_attr_int("min_after_dequeue", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomShuffleQueue::new().build(scope)`.
pub fn random_shuffle_queue(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    RandomShuffleQueue::new().build(scope)
}
/// Builder for the `RandomShuffleQueueV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomShuffleQueueV2 {
    component_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    capacity: ::std::option::Option<i64>,
    min_after_dequeue: ::std::option::Option<i64>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomShuffleQueueV2 {
    /// Creates a new `RandomShuffleQueueV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `component_types` attribute.
    pub fn component_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.component_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shapes` attribute.
    pub fn shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `min_after_dequeue` attribute.
    pub fn min_after_dequeue<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.min_after_dequeue = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomShuffleQueueV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomShuffleQueueV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.component_types {
                nd.set_attr_type_list("component_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shapes {
                nd.set_attr_shape_list("shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.min_after_dequeue {
                nd.set_attr_int("min_after_dequeue", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomShuffleQueueV2::new().build(scope)`.
pub fn random_shuffle_queue_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    RandomShuffleQueueV2::new().build(scope)
}
/// Builder for the `RandomStandardNormal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomStandardNormal {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomStandardNormal {
    /// Creates a new `RandomStandardNormal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomStandardNormal` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        shape: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomStandardNormal", |nd| {
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomStandardNormal::new().build(shape, scope)`.
pub fn random_standard_normal<O0: ::std::convert::Into<crate::Output>>(
    shape: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomStandardNormal::new().build(shape, scope)
}
/// Builder for the `RandomUniform` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomUniform {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomUniform {
    /// Creates a new `RandomUniform`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomUniform` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        shape: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomUniform", |nd| {
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomUniform::new().build(shape, scope)`.
pub fn random_uniform<O0: ::std::convert::Into<crate::Output>>(
    shape: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomUniform::new().build(shape, scope)
}
/// Builder for the `RandomUniformInt` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RandomUniformInt {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    Tout: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RandomUniformInt {
    /// Creates a new `RandomUniformInt`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RandomUniformInt` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        minval: O1,
        maxval: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), minval.into(), maxval.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        minval: crate::Output,
        maxval: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RandomUniformInt", |nd| {
            nd.add_input(shape);
            nd.add_input(minval);
            nd.add_input(maxval);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RandomUniformInt::new().build(shape, minval, maxval, scope)`.
pub fn random_uniform_int<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    minval: O1,
    maxval: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RandomUniformInt::new().build(shape, minval, maxval, scope)
}
/// Builder for the `Range` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Range {
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Range {
    /// Creates a new `Range`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Range` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        start: O0,
        limit: O1,
        delta: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(start.into(), limit.into(), delta.into(), scope)
    }

    fn build_impl(
        &self,
        start: crate::Output,
        limit: crate::Output,
        delta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Range", |nd| {
            nd.add_input(start);
            nd.add_input(limit);
            nd.add_input(delta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Range::new().build(start, limit, delta, scope)`.
pub fn range<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    start: O0,
    limit: O1,
    delta: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Range::new().build(start, limit, delta, scope)
}
/// Builder for the `RangeDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RangeDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RangeDataset {
    /// Creates a new `RangeDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RangeDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        start: O0,
        stop: O1,
        step: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(start.into(), stop.into(), step.into(), scope)
    }

    fn build_impl(
        &self,
        start: crate::Output,
        stop: crate::Output,
        step: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RangeDataset", |nd| {
            nd.add_input(start);
            nd.add_input(stop);
            nd.add_input(step);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RangeDataset::new().build(start, stop, step, scope)`.
pub fn range_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    start: O0,
    stop: O1,
    step: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RangeDataset::new().build(start, stop, step, scope)
}
/// Builder for the `Rank` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Rank {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Rank {
    /// Creates a new `Rank`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Rank` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Rank", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Rank::new().build(input, scope)`.
pub fn rank<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Rank::new().build(input, scope)
}
/// Builder for the `ReadFile` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReadFile {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReadFile {
    /// Creates a new `ReadFile`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReadFile` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        filename: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(filename.into(), scope)
    }

    fn build_impl(
        &self,
        filename: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReadFile", |nd| {
            nd.add_input(filename);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReadFile::new().build(filename, scope)`.
pub fn read_file<O0: ::std::convert::Into<crate::Output>>(
    filename: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReadFile::new().build(filename, scope)
}
/// Builder for the `ReadVariableOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReadVariableOp {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReadVariableOp {
    /// Creates a new `ReadVariableOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReadVariableOp` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReadVariableOp", |nd| {
            nd.add_input(resource);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReadVariableOp::new().build(resource, scope)`.
pub fn read_variable_op<O0: ::std::convert::Into<crate::Output>>(
    resource: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReadVariableOp::new().build(resource, scope)
}
/// Builder for the `ReaderNumRecordsProduced` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderNumRecordsProduced {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderNumRecordsProduced {
    /// Creates a new `ReaderNumRecordsProduced`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderNumRecordsProduced` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        reader_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderNumRecordsProduced", |nd| {
            nd.add_input(reader_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderNumRecordsProduced::new().build(reader_handle, scope)`.
pub fn reader_num_records_produced<O0: ::std::convert::Into<crate::Output>>(
    reader_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderNumRecordsProduced::new().build(reader_handle, scope)
}
/// Builder for the `ReaderNumRecordsProducedV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderNumRecordsProducedV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderNumRecordsProducedV2 {
    /// Creates a new `ReaderNumRecordsProducedV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderNumRecordsProducedV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        reader_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderNumRecordsProducedV2", |nd| {
            nd.add_input(reader_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderNumRecordsProducedV2::new().build(reader_handle, scope)`.
pub fn reader_num_records_produced_v2<O0: ::std::convert::Into<crate::Output>>(
    reader_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderNumRecordsProducedV2::new().build(reader_handle, scope)
}
/// Builder for the `ReaderNumWorkUnitsCompleted` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderNumWorkUnitsCompleted {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderNumWorkUnitsCompleted {
    /// Creates a new `ReaderNumWorkUnitsCompleted`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderNumWorkUnitsCompleted` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        reader_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderNumWorkUnitsCompleted", |nd| {
            nd.add_input(reader_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderNumWorkUnitsCompleted::new().build(reader_handle, scope)`.
pub fn reader_num_work_units_completed<O0: ::std::convert::Into<crate::Output>>(
    reader_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderNumWorkUnitsCompleted::new().build(reader_handle, scope)
}
/// Builder for the `ReaderNumWorkUnitsCompletedV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderNumWorkUnitsCompletedV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderNumWorkUnitsCompletedV2 {
    /// Creates a new `ReaderNumWorkUnitsCompletedV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderNumWorkUnitsCompletedV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        reader_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderNumWorkUnitsCompletedV2", |nd| {
            nd.add_input(reader_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderNumWorkUnitsCompletedV2::new().build(reader_handle, scope)`.
pub fn reader_num_work_units_completed_v2<O0: ::std::convert::Into<crate::Output>>(
    reader_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderNumWorkUnitsCompletedV2::new().build(reader_handle, scope)
}
/// Builder for the `ReaderRead` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderRead {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderRead {
    /// Creates a new `ReaderRead`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderRead` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        reader_handle: O0,
        queue_handle: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), queue_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        queue_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderRead", |nd| {
            nd.add_input(reader_handle);
            nd.add_input(queue_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderRead::new().build(reader_handle, queue_handle, scope)`.
pub fn reader_read<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    reader_handle: O0,
    queue_handle: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderRead::new().build(reader_handle, queue_handle, scope)
}
/// Builder for the `ReaderReadUpTo` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderReadUpTo {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderReadUpTo {
    /// Creates a new `ReaderReadUpTo`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderReadUpTo` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        reader_handle: O0,
        queue_handle: O1,
        num_records: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            reader_handle.into(),
            queue_handle.into(),
            num_records.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        queue_handle: crate::Output,
        num_records: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderReadUpTo", |nd| {
            nd.add_input(reader_handle);
            nd.add_input(queue_handle);
            nd.add_input(num_records);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderReadUpTo::new().build(reader_handle, queue_handle, num_records, scope)`.
pub fn reader_read_up_to<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    reader_handle: O0,
    queue_handle: O1,
    num_records: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderReadUpTo::new().build(reader_handle, queue_handle, num_records, scope)
}
/// Builder for the `ReaderReadUpToV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderReadUpToV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderReadUpToV2 {
    /// Creates a new `ReaderReadUpToV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderReadUpToV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        reader_handle: O0,
        queue_handle: O1,
        num_records: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            reader_handle.into(),
            queue_handle.into(),
            num_records.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        queue_handle: crate::Output,
        num_records: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderReadUpToV2", |nd| {
            nd.add_input(reader_handle);
            nd.add_input(queue_handle);
            nd.add_input(num_records);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderReadUpToV2::new().build(reader_handle, queue_handle, num_records, scope)`.
pub fn reader_read_up_to_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    reader_handle: O0,
    queue_handle: O1,
    num_records: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderReadUpToV2::new().build(reader_handle, queue_handle, num_records, scope)
}
/// Builder for the `ReaderReadV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderReadV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderReadV2 {
    /// Creates a new `ReaderReadV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderReadV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        reader_handle: O0,
        queue_handle: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), queue_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        queue_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderReadV2", |nd| {
            nd.add_input(reader_handle);
            nd.add_input(queue_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderReadV2::new().build(reader_handle, queue_handle, scope)`.
pub fn reader_read_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    reader_handle: O0,
    queue_handle: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderReadV2::new().build(reader_handle, queue_handle, scope)
}
/// Builder for the `ReaderReset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderReset {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderReset {
    /// Creates a new `ReaderReset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderReset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        reader_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderReset", |nd| {
            nd.add_input(reader_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderReset::new().build(reader_handle, scope)`.
pub fn reader_reset<O0: ::std::convert::Into<crate::Output>>(
    reader_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderReset::new().build(reader_handle, scope)
}
/// Builder for the `ReaderResetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderResetV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderResetV2 {
    /// Creates a new `ReaderResetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderResetV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        reader_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderResetV2", |nd| {
            nd.add_input(reader_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderResetV2::new().build(reader_handle, scope)`.
pub fn reader_reset_v2<O0: ::std::convert::Into<crate::Output>>(
    reader_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderResetV2::new().build(reader_handle, scope)
}
/// Builder for the `ReaderRestoreState` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderRestoreState {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderRestoreState {
    /// Creates a new `ReaderRestoreState`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderRestoreState` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        reader_handle: O0,
        state: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), state.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        state: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderRestoreState", |nd| {
            nd.add_input(reader_handle);
            nd.add_input(state);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderRestoreState::new().build(reader_handle, state, scope)`.
pub fn reader_restore_state<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    reader_handle: O0,
    state: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderRestoreState::new().build(reader_handle, state, scope)
}
/// Builder for the `ReaderRestoreStateV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderRestoreStateV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderRestoreStateV2 {
    /// Creates a new `ReaderRestoreStateV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderRestoreStateV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        reader_handle: O0,
        state: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), state.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        state: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderRestoreStateV2", |nd| {
            nd.add_input(reader_handle);
            nd.add_input(state);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderRestoreStateV2::new().build(reader_handle, state, scope)`.
pub fn reader_restore_state_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    reader_handle: O0,
    state: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderRestoreStateV2::new().build(reader_handle, state, scope)
}
/// Builder for the `ReaderSerializeState` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderSerializeState {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderSerializeState {
    /// Creates a new `ReaderSerializeState`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderSerializeState` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        reader_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderSerializeState", |nd| {
            nd.add_input(reader_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderSerializeState::new().build(reader_handle, scope)`.
pub fn reader_serialize_state<O0: ::std::convert::Into<crate::Output>>(
    reader_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderSerializeState::new().build(reader_handle, scope)
}
/// Builder for the `ReaderSerializeStateV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReaderSerializeStateV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReaderSerializeStateV2 {
    /// Creates a new `ReaderSerializeStateV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReaderSerializeStateV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        reader_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reader_handle.into(), scope)
    }

    fn build_impl(
        &self,
        reader_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReaderSerializeStateV2", |nd| {
            nd.add_input(reader_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReaderSerializeStateV2::new().build(reader_handle, scope)`.
pub fn reader_serialize_state_v2<O0: ::std::convert::Into<crate::Output>>(
    reader_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReaderSerializeStateV2::new().build(reader_handle, scope)
}
/// Builder for the `Real` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Real {
    T: ::std::option::Option<crate::DataType>,
    Tout: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Real {
    /// Creates a new `Real`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Real` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Real", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type("Tout", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Real::new().build(input, scope)`.
pub fn real<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Real::new().build(input, scope)
}
/// Builder for the `RealDiv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RealDiv {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RealDiv {
    /// Creates a new `RealDiv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RealDiv` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RealDiv", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RealDiv::new().build(x, y, scope)`.
pub fn real_div<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RealDiv::new().build(x, y, scope)
}
/// Builder for the `RebatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RebatchDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    use_fallback: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RebatchDataset {
    /// Creates a new `RebatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_fallback` attribute.
    pub fn use_fallback<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_fallback = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RebatchDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_replicas: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), num_replicas.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_replicas: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RebatchDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_replicas);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_fallback {
                nd.set_attr_bool("use_fallback", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RebatchDataset::new().build(input_dataset, num_replicas, scope)`.
pub fn rebatch_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_replicas: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RebatchDataset::new().build(input_dataset, num_replicas, scope)
}
/// Builder for the `Reciprocal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Reciprocal {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Reciprocal {
    /// Creates a new `Reciprocal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Reciprocal` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Reciprocal", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Reciprocal::new().build(x, scope)`.
pub fn reciprocal<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Reciprocal::new().build(x, scope)
}
/// Builder for the `ReciprocalGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReciprocalGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReciprocalGrad {
    /// Creates a new `ReciprocalGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReciprocalGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y: O0,
        dy: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(y.into(), dy.into(), scope)
    }

    fn build_impl(
        &self,
        y: crate::Output,
        dy: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReciprocalGrad", |nd| {
            nd.add_input(y);
            nd.add_input(dy);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReciprocalGrad::new().build(y, dy, scope)`.
pub fn reciprocal_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    y: O0,
    dy: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReciprocalGrad::new().build(y, dy, scope)
}
/// Builder for the `RecordInput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RecordInput {
    file_pattern: ::std::option::Option<::std::string::String>,
    file_random_seed: ::std::option::Option<i64>,
    file_shuffle_shift_ratio: ::std::option::Option<f32>,
    file_buffer_size: ::std::option::Option<i64>,
    file_parallelism: ::std::option::Option<i64>,
    batch_size: ::std::option::Option<i64>,
    compression_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RecordInput {
    /// Creates a new `RecordInput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `file_pattern` attribute.
    pub fn file_pattern<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.file_pattern = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `file_random_seed` attribute.
    pub fn file_random_seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.file_random_seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `file_shuffle_shift_ratio` attribute.
    pub fn file_shuffle_shift_ratio<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.file_shuffle_shift_ratio = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `file_buffer_size` attribute.
    pub fn file_buffer_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.file_buffer_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `file_parallelism` attribute.
    pub fn file_parallelism<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.file_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `batch_size` attribute.
    pub fn batch_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.batch_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `compression_type` attribute.
    pub fn compression_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compression_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RecordInput` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RecordInput", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.file_pattern {
                nd.set_attr_string("file_pattern", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.file_random_seed {
                nd.set_attr_int("file_random_seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.file_shuffle_shift_ratio {
                nd.set_attr_float("file_shuffle_shift_ratio", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.file_buffer_size {
                nd.set_attr_int("file_buffer_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.file_parallelism {
                nd.set_attr_int("file_parallelism", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.batch_size {
                nd.set_attr_int("batch_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.compression_type {
                nd.set_attr_string("compression_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RecordInput::new().build(scope)`.
pub fn record_input(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    RecordInput::new().build(scope)
}
/// Builder for the `Recv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Recv {
    tensor_type: ::std::option::Option<crate::DataType>,
    tensor_name: ::std::option::Option<::std::string::String>,
    send_device: ::std::option::Option<::std::string::String>,
    send_device_incarnation: ::std::option::Option<i64>,
    recv_device: ::std::option::Option<::std::string::String>,
    client_terminated: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Recv {
    /// Creates a new `Recv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `tensor_type` attribute.
    pub fn tensor_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_name` attribute.
    pub fn tensor_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `send_device` attribute.
    pub fn send_device<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.send_device = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `send_device_incarnation` attribute.
    pub fn send_device_incarnation<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.send_device_incarnation = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `recv_device` attribute.
    pub fn recv_device<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.recv_device = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `client_terminated` attribute.
    pub fn client_terminated<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.client_terminated = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Recv` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Recv", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.tensor_type {
                nd.set_attr_type("tensor_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_name {
                nd.set_attr_string("tensor_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.send_device {
                nd.set_attr_string("send_device", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.send_device_incarnation {
                nd.set_attr_int("send_device_incarnation", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.recv_device {
                nd.set_attr_string("recv_device", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.client_terminated {
                nd.set_attr_bool("client_terminated", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Recv::new().build(scope)`.
pub fn recv(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Recv::new().build(scope)
}
/// Builder for the `RecvTPUEmbeddingActivations` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RecvTPUEmbeddingActivations {
    num_outputs: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RecvTPUEmbeddingActivations {
    /// Creates a new `RecvTPUEmbeddingActivations`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_outputs` attribute.
    pub fn num_outputs<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_outputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RecvTPUEmbeddingActivations` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RecvTPUEmbeddingActivations", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_outputs {
                nd.set_attr_int("num_outputs", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RecvTPUEmbeddingActivations::new().build(scope)`.
pub fn recv_tpuembedding_activations(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    RecvTPUEmbeddingActivations::new().build(scope)
}
/// Builder for the `ReduceDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReduceDataset {
    f: ::std::option::Option<::std::string::String>,
    Tstate: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    use_inter_op_parallelism: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReduceDataset {
    /// Creates a new `ReduceDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tstate` attribute.
    pub fn Tstate<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tstate = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_inter_op_parallelism` attribute.
    pub fn use_inter_op_parallelism<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_inter_op_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReduceDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        initial_state: O1,
        other_arguments: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            initial_state.into(),
            other_arguments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        initial_state: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReduceDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(initial_state);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tstate {
                nd.set_attr_type_list("Tstate", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_inter_op_parallelism {
                nd.set_attr_bool("use_inter_op_parallelism", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReduceDataset::new().build(input_dataset, initial_state, other_arguments, scope)`.
pub fn reduce_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    initial_state: O1,
    other_arguments: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReduceDataset::new().build(input_dataset, initial_state, other_arguments, scope)
}
/// Builder for the `ReduceJoin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReduceJoin {
    keep_dims: ::std::option::Option<bool>,
    separator: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReduceJoin {
    /// Creates a new `ReduceJoin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `separator` attribute.
    pub fn separator<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.separator = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReduceJoin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReduceJoin", |nd| {
            nd.add_input(inputs);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.separator {
                nd.set_attr_string("separator", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReduceJoin::new().build(inputs, reduction_indices, scope)`.
pub fn reduce_join<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReduceJoin::new().build(inputs, reduction_indices, scope)
}
/// Builder for the `RefEnter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefEnter {
    T: ::std::option::Option<crate::DataType>,
    frame_name: ::std::option::Option<::std::string::String>,
    is_constant: ::std::option::Option<bool>,
    parallel_iterations: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RefEnter {
    /// Creates a new `RefEnter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `frame_name` attribute.
    pub fn frame_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.frame_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_constant` attribute.
    pub fn is_constant<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_constant = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `parallel_iterations` attribute.
    pub fn parallel_iterations<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.parallel_iterations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RefEnter` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        data: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RefEnter", |nd| {
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.frame_name {
                nd.set_attr_string("frame_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_constant {
                nd.set_attr_bool("is_constant", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.parallel_iterations {
                nd.set_attr_int("parallel_iterations", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RefEnter::new().build(data, scope)`.
pub fn ref_enter<O0: ::std::convert::Into<crate::Output>>(
    data: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RefEnter::new().build(data, scope)
}
/// Builder for the `RefExit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefExit {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RefExit {
    /// Creates a new `RefExit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RefExit` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        data: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RefExit", |nd| {
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RefExit::new().build(data, scope)`.
pub fn ref_exit<O0: ::std::convert::Into<crate::Output>>(
    data: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RefExit::new().build(data, scope)
}
/// Builder for the `RefIdentity` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefIdentity {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RefIdentity {
    /// Creates a new `RefIdentity`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RefIdentity` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RefIdentity", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RefIdentity::new().build(input, scope)`.
pub fn ref_identity<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RefIdentity::new().build(input, scope)
}
/// Builder for the `RefMerge` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefMerge {
    T: ::std::option::Option<crate::DataType>,
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RefMerge {
    /// Creates a new `RefMerge`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RefMerge` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RefMerge", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RefMerge::new().build(inputs, scope)`.
pub fn ref_merge<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RefMerge::new().build(inputs, scope)
}
/// Builder for the `RefNextIteration` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefNextIteration {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RefNextIteration {
    /// Creates a new `RefNextIteration`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RefNextIteration` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        data: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RefNextIteration", |nd| {
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RefNextIteration::new().build(data, scope)`.
pub fn ref_next_iteration<O0: ::std::convert::Into<crate::Output>>(
    data: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RefNextIteration::new().build(data, scope)
}
/// Builder for the `RefSelect` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefSelect {
    T: ::std::option::Option<crate::DataType>,
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RefSelect {
    /// Creates a new `RefSelect`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RefSelect` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        index: O0,
        inputs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(index.into(), inputs.into(), scope)
    }

    fn build_impl(
        &self,
        index: crate::Output,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RefSelect", |nd| {
            nd.add_input(index);
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RefSelect::new().build(index, inputs, scope)`.
pub fn ref_select<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    index: O0,
    inputs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RefSelect::new().build(index, inputs, scope)
}
/// Builder for the `RefSwitch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RefSwitch {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RefSwitch {
    /// Creates a new `RefSwitch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RefSwitch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        pred: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), pred.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        pred: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RefSwitch", |nd| {
            nd.add_input(data);
            nd.add_input(pred);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RefSwitch::new().build(data, pred, scope)`.
pub fn ref_switch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    pred: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RefSwitch::new().build(data, pred, scope)
}
/// Builder for the `RegexFullMatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RegexFullMatch {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RegexFullMatch {
    /// Creates a new `RegexFullMatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RegexFullMatch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        pattern: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), pattern.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        pattern: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RegexFullMatch", |nd| {
            nd.add_input(input);
            nd.add_input(pattern);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RegexFullMatch::new().build(input, pattern, scope)`.
pub fn regex_full_match<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    pattern: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RegexFullMatch::new().build(input, pattern, scope)
}
/// Builder for the `RegexReplace` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RegexReplace {
    replace_global: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RegexReplace {
    /// Creates a new `RegexReplace`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `replace_global` attribute.
    pub fn replace_global<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.replace_global = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RegexReplace` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        pattern: O1,
        rewrite: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), pattern.into(), rewrite.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        pattern: crate::Output,
        rewrite: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RegexReplace", |nd| {
            nd.add_input(input);
            nd.add_input(pattern);
            nd.add_input(rewrite);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.replace_global {
                nd.set_attr_bool("replace_global", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RegexReplace::new().build(input, pattern, rewrite, scope)`.
pub fn regex_replace<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    pattern: O1,
    rewrite: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RegexReplace::new().build(input, pattern, rewrite, scope)
}
/// Builder for the `RegisterDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RegisterDataset {
    external_state_policy: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RegisterDataset {
    /// Creates a new `RegisterDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `external_state_policy` attribute.
    pub fn external_state_policy<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.external_state_policy = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RegisterDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        dataset: O0,
        address: O1,
        protocol: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(dataset.into(), address.into(), protocol.into(), scope)
    }

    fn build_impl(
        &self,
        dataset: crate::Output,
        address: crate::Output,
        protocol: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RegisterDataset", |nd| {
            nd.add_input(dataset);
            nd.add_input(address);
            nd.add_input(protocol);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.external_state_policy {
                nd.set_attr_int("external_state_policy", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RegisterDataset::new().build(dataset, address, protocol, scope)`.
pub fn register_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    dataset: O0,
    address: O1,
    protocol: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RegisterDataset::new().build(dataset, address, protocol, scope)
}
/// Builder for the `Relu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Relu {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Relu {
    /// Creates a new `Relu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Relu` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        features: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Relu", |nd| {
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Relu::new().build(features, scope)`.
pub fn relu<O0: ::std::convert::Into<crate::Output>>(
    features: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Relu::new().build(features, scope)
}
/// Builder for the `Relu6` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Relu6 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Relu6 {
    /// Creates a new `Relu6`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Relu6` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        features: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Relu6", |nd| {
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Relu6::new().build(features, scope)`.
pub fn relu6<O0: ::std::convert::Into<crate::Output>>(
    features: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Relu6::new().build(features, scope)
}
/// Builder for the `Relu6Grad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Relu6Grad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Relu6Grad {
    /// Creates a new `Relu6Grad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Relu6Grad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        features: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(gradients.into(), features.into(), scope)
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Relu6Grad", |nd| {
            nd.add_input(gradients);
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Relu6Grad::new().build(gradients, features, scope)`.
pub fn relu6_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    features: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Relu6Grad::new().build(gradients, features, scope)
}
/// Builder for the `ReluGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReluGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReluGrad {
    /// Creates a new `ReluGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReluGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        features: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(gradients.into(), features.into(), scope)
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReluGrad", |nd| {
            nd.add_input(gradients);
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReluGrad::new().build(gradients, features, scope)`.
pub fn relu_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    features: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReluGrad::new().build(gradients, features, scope)
}
/// Builder for the `RemoteCall` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RemoteCall {
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    f: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RemoteCall {
    /// Creates a new `RemoteCall`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RemoteCall` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        target: O0,
        args: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(target.into(), args.into(), scope)
    }

    fn build_impl(
        &self,
        target: crate::Output,
        args: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RemoteCall", |nd| {
            nd.add_input(target);
            nd.add_input(args);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RemoteCall::new().build(target, args, scope)`.
pub fn remote_call<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    target: O0,
    args: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RemoteCall::new().build(target, args, scope)
}
/// Builder for the `RemoteFusedGraphExecute` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RemoteFusedGraphExecute {
    Tinputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Toutputs: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    serialized_remote_fused_graph_execute_info: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RemoteFusedGraphExecute {
    /// Creates a new `RemoteFusedGraphExecute`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinputs` attribute.
    pub fn Tinputs<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Toutputs` attribute.
    pub fn Toutputs<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `serialized_remote_fused_graph_execute_info` attribute.
    pub fn serialized_remote_fused_graph_execute_info<
        ArgType: ::std::convert::Into<::std::string::String>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.serialized_remote_fused_graph_execute_info = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RemoteFusedGraphExecute` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RemoteFusedGraphExecute", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinputs {
                nd.set_attr_type_list("Tinputs", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Toutputs {
                nd.set_attr_type_list("Toutputs", value)?;
            }
            if let ::std::option::Option::Some(value) =
                &self.serialized_remote_fused_graph_execute_info
            {
                nd.set_attr_string("serialized_remote_fused_graph_execute_info", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RemoteFusedGraphExecute::new().build(inputs, scope)`.
pub fn remote_fused_graph_execute<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RemoteFusedGraphExecute::new().build(inputs, scope)
}
/// Builder for the `RepeatDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RepeatDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RepeatDataset {
    /// Creates a new `RepeatDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RepeatDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        count: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), count.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        count: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RepeatDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(count);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RepeatDataset::new().build(input_dataset, count, scope)`.
pub fn repeat_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    count: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RepeatDataset::new().build(input_dataset, count, scope)
}
/// Builder for the `RequantizationRange` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RequantizationRange {
    Tinput: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RequantizationRange {
    /// Creates a new `RequantizationRange`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RequantizationRange` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_min: O1,
        input_max: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), input_min.into(), input_max.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_min: crate::Output,
        input_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RequantizationRange", |nd| {
            nd.add_input(input);
            nd.add_input(input_min);
            nd.add_input(input_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RequantizationRange::new().build(input, input_min, input_max, scope)`.
pub fn requantization_range<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_min: O1,
    input_max: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RequantizationRange::new().build(input, input_min, input_max, scope)
}
/// Builder for the `RequantizationRangePerChannel` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RequantizationRangePerChannel {
    T: ::std::option::Option<crate::DataType>,
    clip_value_max: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RequantizationRangePerChannel {
    /// Creates a new `RequantizationRangePerChannel`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `clip_value_max` attribute.
    pub fn clip_value_max<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.clip_value_max = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RequantizationRangePerChannel` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_min: O1,
        input_max: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), input_min.into(), input_max.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_min: crate::Output,
        input_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RequantizationRangePerChannel", |nd| {
            nd.add_input(input);
            nd.add_input(input_min);
            nd.add_input(input_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.clip_value_max {
                nd.set_attr_float("clip_value_max", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RequantizationRangePerChannel::new().build(input, input_min, input_max, scope)`.
pub fn requantization_range_per_channel<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_min: O1,
    input_max: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RequantizationRangePerChannel::new().build(input, input_min, input_max, scope)
}
/// Builder for the `Requantize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Requantize {
    Tinput: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Requantize {
    /// Creates a new `Requantize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tinput` attribute.
    pub fn Tinput<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tinput = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Requantize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_min: O1,
        input_max: O2,
        requested_output_min: O3,
        requested_output_max: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_min.into(),
            input_max.into(),
            requested_output_min.into(),
            requested_output_max.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_min: crate::Output,
        input_max: crate::Output,
        requested_output_min: crate::Output,
        requested_output_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Requantize", |nd| {
            nd.add_input(input);
            nd.add_input(input_min);
            nd.add_input(input_max);
            nd.add_input(requested_output_min);
            nd.add_input(requested_output_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tinput {
                nd.set_attr_type("Tinput", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Requantize::new().build(input, input_min, input_max, requested_output_min, requested_output_max, scope)`.
pub fn requantize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_min: O1,
    input_max: O2,
    requested_output_min: O3,
    requested_output_max: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Requantize::new().build(
        input,
        input_min,
        input_max,
        requested_output_min,
        requested_output_max,
        scope,
    )
}
/// Builder for the `RequantizePerChannel` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RequantizePerChannel {
    T: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RequantizePerChannel {
    /// Creates a new `RequantizePerChannel`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RequantizePerChannel` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        input_min: O1,
        input_max: O2,
        requested_output_min: O3,
        requested_output_max: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            input_min.into(),
            input_max.into(),
            requested_output_min.into(),
            requested_output_max.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        input_min: crate::Output,
        input_max: crate::Output,
        requested_output_min: crate::Output,
        requested_output_max: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RequantizePerChannel", |nd| {
            nd.add_input(input);
            nd.add_input(input_min);
            nd.add_input(input_max);
            nd.add_input(requested_output_min);
            nd.add_input(requested_output_max);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RequantizePerChannel::new().build(input, input_min, input_max, requested_output_min, requested_output_max, scope)`.
pub fn requantize_per_channel<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    input_min: O1,
    input_max: O2,
    requested_output_min: O3,
    requested_output_max: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RequantizePerChannel::new().build(
        input,
        input_min,
        input_max,
        requested_output_min,
        requested_output_max,
        scope,
    )
}
/// Builder for the `Reshape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Reshape {
    T: ::std::option::Option<crate::DataType>,
    Tshape: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Reshape {
    /// Creates a new `Reshape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tshape` attribute.
    pub fn Tshape<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tshape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Reshape` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        shape: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Reshape", |nd| {
            nd.add_input(tensor);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tshape {
                nd.set_attr_type("Tshape", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Reshape::new().build(tensor, shape, scope)`.
pub fn reshape<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    tensor: O0,
    shape: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Reshape::new().build(tensor, shape, scope)
}
/// Builder for the `ResizeArea` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeArea {
    T: ::std::option::Option<crate::DataType>,
    align_corners: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResizeArea {
    /// Creates a new `ResizeArea`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align_corners` attribute.
    pub fn align_corners<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResizeArea` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), size.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResizeArea", |nd| {
            nd.add_input(images);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align_corners {
                nd.set_attr_bool("align_corners", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResizeArea::new().build(images, size, scope)`.
pub fn resize_area<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResizeArea::new().build(images, size, scope)
}
/// Builder for the `ResizeBicubic` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeBicubic {
    T: ::std::option::Option<crate::DataType>,
    align_corners: ::std::option::Option<bool>,
    half_pixel_centers: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResizeBicubic {
    /// Creates a new `ResizeBicubic`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align_corners` attribute.
    pub fn align_corners<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `half_pixel_centers` attribute.
    pub fn half_pixel_centers<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.half_pixel_centers = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResizeBicubic` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), size.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResizeBicubic", |nd| {
            nd.add_input(images);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align_corners {
                nd.set_attr_bool("align_corners", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.half_pixel_centers {
                nd.set_attr_bool("half_pixel_centers", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResizeBicubic::new().build(images, size, scope)`.
pub fn resize_bicubic<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResizeBicubic::new().build(images, size, scope)
}
/// Builder for the `ResizeBicubicGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeBicubicGrad {
    T: ::std::option::Option<crate::DataType>,
    align_corners: ::std::option::Option<bool>,
    half_pixel_centers: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResizeBicubicGrad {
    /// Creates a new `ResizeBicubicGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align_corners` attribute.
    pub fn align_corners<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `half_pixel_centers` attribute.
    pub fn half_pixel_centers<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.half_pixel_centers = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResizeBicubicGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        grads: O0,
        original_image: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(grads.into(), original_image.into(), scope)
    }

    fn build_impl(
        &self,
        grads: crate::Output,
        original_image: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResizeBicubicGrad", |nd| {
            nd.add_input(grads);
            nd.add_input(original_image);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align_corners {
                nd.set_attr_bool("align_corners", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.half_pixel_centers {
                nd.set_attr_bool("half_pixel_centers", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResizeBicubicGrad::new().build(grads, original_image, scope)`.
pub fn resize_bicubic_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    grads: O0,
    original_image: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResizeBicubicGrad::new().build(grads, original_image, scope)
}
/// Builder for the `ResizeBilinear` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeBilinear {
    T: ::std::option::Option<crate::DataType>,
    align_corners: ::std::option::Option<bool>,
    half_pixel_centers: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResizeBilinear {
    /// Creates a new `ResizeBilinear`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align_corners` attribute.
    pub fn align_corners<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `half_pixel_centers` attribute.
    pub fn half_pixel_centers<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.half_pixel_centers = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResizeBilinear` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), size.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResizeBilinear", |nd| {
            nd.add_input(images);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align_corners {
                nd.set_attr_bool("align_corners", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.half_pixel_centers {
                nd.set_attr_bool("half_pixel_centers", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResizeBilinear::new().build(images, size, scope)`.
pub fn resize_bilinear<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResizeBilinear::new().build(images, size, scope)
}
/// Builder for the `ResizeBilinearGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeBilinearGrad {
    T: ::std::option::Option<crate::DataType>,
    align_corners: ::std::option::Option<bool>,
    half_pixel_centers: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResizeBilinearGrad {
    /// Creates a new `ResizeBilinearGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align_corners` attribute.
    pub fn align_corners<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `half_pixel_centers` attribute.
    pub fn half_pixel_centers<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.half_pixel_centers = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResizeBilinearGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        grads: O0,
        original_image: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(grads.into(), original_image.into(), scope)
    }

    fn build_impl(
        &self,
        grads: crate::Output,
        original_image: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResizeBilinearGrad", |nd| {
            nd.add_input(grads);
            nd.add_input(original_image);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align_corners {
                nd.set_attr_bool("align_corners", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.half_pixel_centers {
                nd.set_attr_bool("half_pixel_centers", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResizeBilinearGrad::new().build(grads, original_image, scope)`.
pub fn resize_bilinear_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    grads: O0,
    original_image: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResizeBilinearGrad::new().build(grads, original_image, scope)
}
/// Builder for the `ResizeNearestNeighbor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeNearestNeighbor {
    T: ::std::option::Option<crate::DataType>,
    align_corners: ::std::option::Option<bool>,
    half_pixel_centers: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResizeNearestNeighbor {
    /// Creates a new `ResizeNearestNeighbor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align_corners` attribute.
    pub fn align_corners<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `half_pixel_centers` attribute.
    pub fn half_pixel_centers<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.half_pixel_centers = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResizeNearestNeighbor` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(images.into(), size.into(), scope)
    }

    fn build_impl(
        &self,
        images: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResizeNearestNeighbor", |nd| {
            nd.add_input(images);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align_corners {
                nd.set_attr_bool("align_corners", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.half_pixel_centers {
                nd.set_attr_bool("half_pixel_centers", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResizeNearestNeighbor::new().build(images, size, scope)`.
pub fn resize_nearest_neighbor<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResizeNearestNeighbor::new().build(images, size, scope)
}
/// Builder for the `ResizeNearestNeighborGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResizeNearestNeighborGrad {
    T: ::std::option::Option<crate::DataType>,
    align_corners: ::std::option::Option<bool>,
    half_pixel_centers: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResizeNearestNeighborGrad {
    /// Creates a new `ResizeNearestNeighborGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `align_corners` attribute.
    pub fn align_corners<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.align_corners = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `half_pixel_centers` attribute.
    pub fn half_pixel_centers<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.half_pixel_centers = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResizeNearestNeighborGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        grads: O0,
        size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(grads.into(), size.into(), scope)
    }

    fn build_impl(
        &self,
        grads: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResizeNearestNeighborGrad", |nd| {
            nd.add_input(grads);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.align_corners {
                nd.set_attr_bool("align_corners", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.half_pixel_centers {
                nd.set_attr_bool("half_pixel_centers", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResizeNearestNeighborGrad::new().build(grads, size, scope)`.
pub fn resize_nearest_neighbor_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    grads: O0,
    size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResizeNearestNeighborGrad::new().build(grads, size, scope)
}
/// Builder for the `ResourceAccumulatorApplyGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceAccumulatorApplyGradient {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceAccumulatorApplyGradient {
    /// Creates a new `ResourceAccumulatorApplyGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceAccumulatorApplyGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        local_step: O1,
        gradient: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), local_step.into(), gradient.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        local_step: crate::Output,
        gradient: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceAccumulatorApplyGradient", |nd| {
            nd.add_input(handle);
            nd.add_input(local_step);
            nd.add_input(gradient);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceAccumulatorApplyGradient::new().build(handle, local_step, gradient, scope)`.
pub fn resource_accumulator_apply_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    local_step: O1,
    gradient: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceAccumulatorApplyGradient::new().build(handle, local_step, gradient, scope)
}
/// Builder for the `ResourceAccumulatorNumAccumulated` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceAccumulatorNumAccumulated {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceAccumulatorNumAccumulated {
    /// Creates a new `ResourceAccumulatorNumAccumulated`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceAccumulatorNumAccumulated` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceAccumulatorNumAccumulated", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceAccumulatorNumAccumulated::new().build(handle, scope)`.
pub fn resource_accumulator_num_accumulated<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceAccumulatorNumAccumulated::new().build(handle, scope)
}
/// Builder for the `ResourceAccumulatorSetGlobalStep` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceAccumulatorSetGlobalStep {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceAccumulatorSetGlobalStep {
    /// Creates a new `ResourceAccumulatorSetGlobalStep`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceAccumulatorSetGlobalStep` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        new_global_step: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), new_global_step.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        new_global_step: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceAccumulatorSetGlobalStep", |nd| {
            nd.add_input(handle);
            nd.add_input(new_global_step);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceAccumulatorSetGlobalStep::new().build(handle, new_global_step, scope)`.
pub fn resource_accumulator_set_global_step<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    new_global_step: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceAccumulatorSetGlobalStep::new().build(handle, new_global_step, scope)
}
/// Builder for the `ResourceAccumulatorTakeGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceAccumulatorTakeGradient {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceAccumulatorTakeGradient {
    /// Creates a new `ResourceAccumulatorTakeGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceAccumulatorTakeGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        num_required: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), num_required.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        num_required: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceAccumulatorTakeGradient", |nd| {
            nd.add_input(handle);
            nd.add_input(num_required);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceAccumulatorTakeGradient::new().build(handle, num_required, scope)`.
pub fn resource_accumulator_take_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    num_required: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceAccumulatorTakeGradient::new().build(handle, num_required, scope)
}
/// Builder for the `ResourceApplyAdaMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdaMax {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyAdaMax {
    /// Creates a new `ResourceApplyAdaMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyAdaMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        v: O2,
        beta1_power: O3,
        lr: O4,
        beta1: O5,
        beta2: O6,
        epsilon: O7,
        grad: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            v.into(),
            beta1_power.into(),
            lr.into(),
            beta1.into(),
            beta2.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        v: crate::Output,
        beta1_power: crate::Output,
        lr: crate::Output,
        beta1: crate::Output,
        beta2: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyAdaMax", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(v);
            nd.add_input(beta1_power);
            nd.add_input(lr);
            nd.add_input(beta1);
            nd.add_input(beta2);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyAdaMax::new().build(var, m, v, beta1_power, lr, beta1, beta2, epsilon, grad, scope)`.
pub fn resource_apply_ada_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    v: O2,
    beta1_power: O3,
    lr: O4,
    beta1: O5,
    beta2: O6,
    epsilon: O7,
    grad: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyAdaMax::new().build(
        var,
        m,
        v,
        beta1_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        scope,
    )
}
/// Builder for the `ResourceApplyAdadelta` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdadelta {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyAdadelta {
    /// Creates a new `ResourceApplyAdadelta`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyAdadelta` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        accum_update: O2,
        lr: O3,
        rho: O4,
        epsilon: O5,
        grad: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            accum_update.into(),
            lr.into(),
            rho.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        accum_update: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyAdadelta", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(accum_update);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyAdadelta::new().build(var, accum, accum_update, lr, rho, epsilon, grad, scope)`.
pub fn resource_apply_adadelta<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    accum_update: O2,
    lr: O3,
    rho: O4,
    epsilon: O5,
    grad: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyAdadelta::new().build(var, accum, accum_update, lr, rho, epsilon, grad, scope)
}
/// Builder for the `ResourceApplyAdagrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdagrad {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    update_slots: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyAdagrad {
    /// Creates a new `ResourceApplyAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `update_slots` attribute.
    pub fn update_slots<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.update_slots = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyAdagrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(var.into(), accum.into(), lr.into(), grad.into(), scope)
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyAdagrad", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.update_slots {
                nd.set_attr_bool("update_slots", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyAdagrad::new().build(var, accum, lr, grad, scope)`.
pub fn resource_apply_adagrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyAdagrad::new().build(var, accum, lr, grad, scope)
}
/// Builder for the `ResourceApplyAdagradDA` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdagradDA {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyAdagradDA {
    /// Creates a new `ResourceApplyAdagradDA`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyAdagradDA` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        gradient_accumulator: O1,
        gradient_squared_accumulator: O2,
        grad: O3,
        lr: O4,
        l1: O5,
        l2: O6,
        global_step: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            gradient_accumulator.into(),
            gradient_squared_accumulator.into(),
            grad.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            global_step.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        gradient_accumulator: crate::Output,
        gradient_squared_accumulator: crate::Output,
        grad: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        global_step: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyAdagradDA", |nd| {
            nd.add_input(var);
            nd.add_input(gradient_accumulator);
            nd.add_input(gradient_squared_accumulator);
            nd.add_input(grad);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(global_step);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyAdagradDA::new().build(var, gradient_accumulator, gradient_squared_accumulator, grad, lr, l1, l2, global_step, scope)`.
pub fn resource_apply_adagrad_da<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    gradient_accumulator: O1,
    gradient_squared_accumulator: O2,
    grad: O3,
    lr: O4,
    l1: O5,
    l2: O6,
    global_step: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyAdagradDA::new().build(
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        lr,
        l1,
        l2,
        global_step,
        scope,
    )
}
/// Builder for the `ResourceApplyAdagradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdagradV2 {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    update_slots: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyAdagradV2 {
    /// Creates a new `ResourceApplyAdagradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `update_slots` attribute.
    pub fn update_slots<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.update_slots = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyAdagradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        epsilon: O3,
        grad: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyAdagradV2", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.update_slots {
                nd.set_attr_bool("update_slots", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyAdagradV2::new().build(var, accum, lr, epsilon, grad, scope)`.
pub fn resource_apply_adagrad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    epsilon: O3,
    grad: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyAdagradV2::new().build(var, accum, lr, epsilon, grad, scope)
}
/// Builder for the `ResourceApplyAdam` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdam {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    use_nesterov: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyAdam {
    /// Creates a new `ResourceApplyAdam`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_nesterov` attribute.
    pub fn use_nesterov<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_nesterov = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyAdam` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        v: O2,
        beta1_power: O3,
        beta2_power: O4,
        lr: O5,
        beta1: O6,
        beta2: O7,
        epsilon: O8,
        grad: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            v.into(),
            beta1_power.into(),
            beta2_power.into(),
            lr.into(),
            beta1.into(),
            beta2.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        v: crate::Output,
        beta1_power: crate::Output,
        beta2_power: crate::Output,
        lr: crate::Output,
        beta1: crate::Output,
        beta2: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyAdam", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(v);
            nd.add_input(beta1_power);
            nd.add_input(beta2_power);
            nd.add_input(lr);
            nd.add_input(beta1);
            nd.add_input(beta2);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_nesterov {
                nd.set_attr_bool("use_nesterov", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyAdam::new().build(var, m, v, beta1_power, beta2_power, lr, beta1, beta2, epsilon, grad, scope)`.
pub fn resource_apply_adam<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    v: O2,
    beta1_power: O3,
    beta2_power: O4,
    lr: O5,
    beta1: O6,
    beta2: O7,
    epsilon: O8,
    grad: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyAdam::new().build(
        var,
        m,
        v,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        scope,
    )
}
/// Builder for the `ResourceApplyAdamWithAmsgrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAdamWithAmsgrad {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyAdamWithAmsgrad {
    /// Creates a new `ResourceApplyAdamWithAmsgrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyAdamWithAmsgrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
        O10: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        v: O2,
        vhat: O3,
        beta1_power: O4,
        beta2_power: O5,
        lr: O6,
        beta1: O7,
        beta2: O8,
        epsilon: O9,
        grad: O10,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            v.into(),
            vhat.into(),
            beta1_power.into(),
            beta2_power.into(),
            lr.into(),
            beta1.into(),
            beta2.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        v: crate::Output,
        vhat: crate::Output,
        beta1_power: crate::Output,
        beta2_power: crate::Output,
        lr: crate::Output,
        beta1: crate::Output,
        beta2: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyAdamWithAmsgrad", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(v);
            nd.add_input(vhat);
            nd.add_input(beta1_power);
            nd.add_input(beta2_power);
            nd.add_input(lr);
            nd.add_input(beta1);
            nd.add_input(beta2);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyAdamWithAmsgrad::new().build(var, m, v, vhat, beta1_power, beta2_power, lr, beta1, beta2, epsilon, grad, scope)`.
pub fn resource_apply_adam_with_amsgrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
    O10: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    v: O2,
    vhat: O3,
    beta1_power: O4,
    beta2_power: O5,
    lr: O6,
    beta1: O7,
    beta2: O8,
    epsilon: O9,
    grad: O10,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyAdamWithAmsgrad::new().build(
        var,
        m,
        v,
        vhat,
        beta1_power,
        beta2_power,
        lr,
        beta1,
        beta2,
        epsilon,
        grad,
        scope,
    )
}
/// Builder for the `ResourceApplyAddSign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyAddSign {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyAddSign {
    /// Creates a new `ResourceApplyAddSign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyAddSign` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        lr: O2,
        alpha: O3,
        sign_decay: O4,
        beta: O5,
        grad: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            lr.into(),
            alpha.into(),
            sign_decay.into(),
            beta.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        lr: crate::Output,
        alpha: crate::Output,
        sign_decay: crate::Output,
        beta: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyAddSign", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(lr);
            nd.add_input(alpha);
            nd.add_input(sign_decay);
            nd.add_input(beta);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyAddSign::new().build(var, m, lr, alpha, sign_decay, beta, grad, scope)`.
pub fn resource_apply_add_sign<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    lr: O2,
    alpha: O3,
    sign_decay: O4,
    beta: O5,
    grad: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyAddSign::new().build(var, m, lr, alpha, sign_decay, beta, grad, scope)
}
/// Builder for the `ResourceApplyCenteredRMSProp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyCenteredRMSProp {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyCenteredRMSProp {
    /// Creates a new `ResourceApplyCenteredRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyCenteredRMSProp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        mg: O1,
        ms: O2,
        mom: O3,
        lr: O4,
        rho: O5,
        momentum: O6,
        epsilon: O7,
        grad: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            mg.into(),
            ms.into(),
            mom.into(),
            lr.into(),
            rho.into(),
            momentum.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        mg: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        momentum: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyCenteredRMSProp", |nd| {
            nd.add_input(var);
            nd.add_input(mg);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(momentum);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyCenteredRMSProp::new().build(var, mg, ms, mom, lr, rho, momentum, epsilon, grad, scope)`.
pub fn resource_apply_centered_rmsprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    mg: O1,
    ms: O2,
    mom: O3,
    lr: O4,
    rho: O5,
    momentum: O6,
    epsilon: O7,
    grad: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyCenteredRMSProp::new()
        .build(var, mg, ms, mom, lr, rho, momentum, epsilon, grad, scope)
}
/// Builder for the `ResourceApplyFtrl` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyFtrl {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    multiply_linear_by_lr: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyFtrl {
    /// Creates a new `ResourceApplyFtrl`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `multiply_linear_by_lr` attribute.
    pub fn multiply_linear_by_lr<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.multiply_linear_by_lr = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyFtrl` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        linear: O2,
        grad: O3,
        lr: O4,
        l1: O5,
        l2: O6,
        lr_power: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            linear.into(),
            grad.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            lr_power.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        linear: crate::Output,
        grad: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        lr_power: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyFtrl", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(linear);
            nd.add_input(grad);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(lr_power);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.multiply_linear_by_lr {
                nd.set_attr_bool("multiply_linear_by_lr", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyFtrl::new().build(var, accum, linear, grad, lr, l1, l2, lr_power, scope)`.
pub fn resource_apply_ftrl<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    linear: O2,
    grad: O3,
    lr: O4,
    l1: O5,
    l2: O6,
    lr_power: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyFtrl::new().build(var, accum, linear, grad, lr, l1, l2, lr_power, scope)
}
/// Builder for the `ResourceApplyFtrlV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyFtrlV2 {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    multiply_linear_by_lr: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyFtrlV2 {
    /// Creates a new `ResourceApplyFtrlV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `multiply_linear_by_lr` attribute.
    pub fn multiply_linear_by_lr<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.multiply_linear_by_lr = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyFtrlV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        linear: O2,
        grad: O3,
        lr: O4,
        l1: O5,
        l2: O6,
        l2_shrinkage: O7,
        lr_power: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            linear.into(),
            grad.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            l2_shrinkage.into(),
            lr_power.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        linear: crate::Output,
        grad: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        l2_shrinkage: crate::Output,
        lr_power: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyFtrlV2", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(linear);
            nd.add_input(grad);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(l2_shrinkage);
            nd.add_input(lr_power);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.multiply_linear_by_lr {
                nd.set_attr_bool("multiply_linear_by_lr", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyFtrlV2::new().build(var, accum, linear, grad, lr, l1, l2, l2_shrinkage, lr_power, scope)`.
pub fn resource_apply_ftrl_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    linear: O2,
    grad: O3,
    lr: O4,
    l1: O5,
    l2: O6,
    l2_shrinkage: O7,
    lr_power: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyFtrlV2::new().build(
        var,
        accum,
        linear,
        grad,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        scope,
    )
}
/// Builder for the `ResourceApplyGradientDescent` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyGradientDescent {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyGradientDescent {
    /// Creates a new `ResourceApplyGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyGradientDescent` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        alpha: O1,
        delta: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(var.into(), alpha.into(), delta.into(), scope)
    }

    fn build_impl(
        &self,
        var: crate::Output,
        alpha: crate::Output,
        delta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyGradientDescent", |nd| {
            nd.add_input(var);
            nd.add_input(alpha);
            nd.add_input(delta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyGradientDescent::new().build(var, alpha, delta, scope)`.
pub fn resource_apply_gradient_descent<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    alpha: O1,
    delta: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyGradientDescent::new().build(var, alpha, delta, scope)
}
/// Builder for the `ResourceApplyKerasMomentum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyKerasMomentum {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    use_nesterov: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyKerasMomentum {
    /// Creates a new `ResourceApplyKerasMomentum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_nesterov` attribute.
    pub fn use_nesterov<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_nesterov = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyKerasMomentum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        momentum: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            grad.into(),
            momentum.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        momentum: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyKerasMomentum", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            nd.add_input(momentum);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_nesterov {
                nd.set_attr_bool("use_nesterov", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyKerasMomentum::new().build(var, accum, lr, grad, momentum, scope)`.
pub fn resource_apply_keras_momentum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    momentum: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyKerasMomentum::new().build(var, accum, lr, grad, momentum, scope)
}
/// Builder for the `ResourceApplyMomentum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyMomentum {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    use_nesterov: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyMomentum {
    /// Creates a new `ResourceApplyMomentum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_nesterov` attribute.
    pub fn use_nesterov<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_nesterov = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyMomentum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        momentum: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            grad.into(),
            momentum.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        momentum: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyMomentum", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            nd.add_input(momentum);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_nesterov {
                nd.set_attr_bool("use_nesterov", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyMomentum::new().build(var, accum, lr, grad, momentum, scope)`.
pub fn resource_apply_momentum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    momentum: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyMomentum::new().build(var, accum, lr, grad, momentum, scope)
}
/// Builder for the `ResourceApplyPowerSign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyPowerSign {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyPowerSign {
    /// Creates a new `ResourceApplyPowerSign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyPowerSign` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        m: O1,
        lr: O2,
        logbase: O3,
        sign_decay: O4,
        beta: O5,
        grad: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            m.into(),
            lr.into(),
            logbase.into(),
            sign_decay.into(),
            beta.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        m: crate::Output,
        lr: crate::Output,
        logbase: crate::Output,
        sign_decay: crate::Output,
        beta: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyPowerSign", |nd| {
            nd.add_input(var);
            nd.add_input(m);
            nd.add_input(lr);
            nd.add_input(logbase);
            nd.add_input(sign_decay);
            nd.add_input(beta);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyPowerSign::new().build(var, m, lr, logbase, sign_decay, beta, grad, scope)`.
pub fn resource_apply_power_sign<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    m: O1,
    lr: O2,
    logbase: O3,
    sign_decay: O4,
    beta: O5,
    grad: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyPowerSign::new().build(var, m, lr, logbase, sign_decay, beta, grad, scope)
}
/// Builder for the `ResourceApplyProximalAdagrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyProximalAdagrad {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyProximalAdagrad {
    /// Creates a new `ResourceApplyProximalAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyProximalAdagrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        l1: O3,
        l2: O4,
        grad: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyProximalAdagrad", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyProximalAdagrad::new().build(var, accum, lr, l1, l2, grad, scope)`.
pub fn resource_apply_proximal_adagrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    l1: O3,
    l2: O4,
    grad: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyProximalAdagrad::new().build(var, accum, lr, l1, l2, grad, scope)
}
/// Builder for the `ResourceApplyProximalGradientDescent` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyProximalGradientDescent {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyProximalGradientDescent {
    /// Creates a new `ResourceApplyProximalGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyProximalGradientDescent` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        alpha: O1,
        l1: O2,
        l2: O3,
        delta: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            alpha.into(),
            l1.into(),
            l2.into(),
            delta.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        alpha: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        delta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyProximalGradientDescent", |nd| {
            nd.add_input(var);
            nd.add_input(alpha);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(delta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyProximalGradientDescent::new().build(var, alpha, l1, l2, delta, scope)`.
pub fn resource_apply_proximal_gradient_descent<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    alpha: O1,
    l1: O2,
    l2: O3,
    delta: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyProximalGradientDescent::new().build(var, alpha, l1, l2, delta, scope)
}
/// Builder for the `ResourceApplyRMSProp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceApplyRMSProp {
    T: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceApplyRMSProp {
    /// Creates a new `ResourceApplyRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceApplyRMSProp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        ms: O1,
        mom: O2,
        lr: O3,
        rho: O4,
        momentum: O5,
        epsilon: O6,
        grad: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            ms.into(),
            mom.into(),
            lr.into(),
            rho.into(),
            momentum.into(),
            epsilon.into(),
            grad.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        momentum: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceApplyRMSProp", |nd| {
            nd.add_input(var);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(momentum);
            nd.add_input(epsilon);
            nd.add_input(grad);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceApplyRMSProp::new().build(var, ms, mom, lr, rho, momentum, epsilon, grad, scope)`.
pub fn resource_apply_rmsprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    ms: O1,
    mom: O2,
    lr: O3,
    rho: O4,
    momentum: O5,
    epsilon: O6,
    grad: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceApplyRMSProp::new().build(var, ms, mom, lr, rho, momentum, epsilon, grad, scope)
}
/// Builder for the `ResourceConditionalAccumulator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceConditionalAccumulator {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    reduction_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceConditionalAccumulator {
    /// Creates a new `ResourceConditionalAccumulator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reduction_type` attribute.
    pub fn reduction_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduction_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceConditionalAccumulator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceConditionalAccumulator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reduction_type {
                nd.set_attr_string("reduction_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceConditionalAccumulator::new().build(scope)`.
pub fn resource_conditional_accumulator(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceConditionalAccumulator::new().build(scope)
}
/// Builder for the `ResourceCountUpTo` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceCountUpTo {
    limit: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceCountUpTo {
    /// Creates a new `ResourceCountUpTo`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `limit` attribute.
    pub fn limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceCountUpTo` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceCountUpTo", |nd| {
            nd.add_input(resource);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.limit {
                nd.set_attr_int("limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceCountUpTo::new().build(resource, scope)`.
pub fn resource_count_up_to<O0: ::std::convert::Into<crate::Output>>(
    resource: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceCountUpTo::new().build(resource, scope)
}
/// Builder for the `ResourceGather` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceGather {
    batch_dims: ::std::option::Option<i64>,
    validate_indices: ::std::option::Option<bool>,
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceGather {
    /// Creates a new `ResourceGather`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `batch_dims` attribute.
    pub fn batch_dims<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.batch_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `validate_indices` attribute.
    pub fn validate_indices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.validate_indices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceGather` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceGather", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.batch_dims {
                nd.set_attr_int("batch_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.validate_indices {
                nd.set_attr_bool("validate_indices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceGather::new().build(resource, indices, scope)`.
pub fn resource_gather<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceGather::new().build(resource, indices, scope)
}
/// Builder for the `ResourceGatherNd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceGatherNd {
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceGatherNd {
    /// Creates a new `ResourceGatherNd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceGatherNd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceGatherNd", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceGatherNd::new().build(resource, indices, scope)`.
pub fn resource_gather_nd<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceGatherNd::new().build(resource, indices, scope)
}
/// Builder for the `ResourceScatterAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterAdd {
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterAdd {
    /// Creates a new `ResourceScatterAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterAdd", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterAdd::new().build(resource, indices, updates, scope)`.
pub fn resource_scatter_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterAdd::new().build(resource, indices, updates, scope)
}
/// Builder for the `ResourceScatterDiv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterDiv {
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterDiv {
    /// Creates a new `ResourceScatterDiv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterDiv` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterDiv", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterDiv::new().build(resource, indices, updates, scope)`.
pub fn resource_scatter_div<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterDiv::new().build(resource, indices, updates, scope)
}
/// Builder for the `ResourceScatterMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterMax {
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterMax {
    /// Creates a new `ResourceScatterMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterMax", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterMax::new().build(resource, indices, updates, scope)`.
pub fn resource_scatter_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterMax::new().build(resource, indices, updates, scope)
}
/// Builder for the `ResourceScatterMin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterMin {
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterMin {
    /// Creates a new `ResourceScatterMin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterMin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterMin", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterMin::new().build(resource, indices, updates, scope)`.
pub fn resource_scatter_min<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterMin::new().build(resource, indices, updates, scope)
}
/// Builder for the `ResourceScatterMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterMul {
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterMul {
    /// Creates a new `ResourceScatterMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterMul", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterMul::new().build(resource, indices, updates, scope)`.
pub fn resource_scatter_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterMul::new().build(resource, indices, updates, scope)
}
/// Builder for the `ResourceScatterNdAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdAdd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterNdAdd {
    /// Creates a new `ResourceScatterNdAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterNdAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterNdAdd", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterNdAdd::new().build(ref_, indices, updates, scope)`.
pub fn resource_scatter_nd_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterNdAdd::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ResourceScatterNdMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdMax {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterNdMax {
    /// Creates a new `ResourceScatterNdMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterNdMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterNdMax", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterNdMax::new().build(ref_, indices, updates, scope)`.
pub fn resource_scatter_nd_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterNdMax::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ResourceScatterNdMin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdMin {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterNdMin {
    /// Creates a new `ResourceScatterNdMin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterNdMin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterNdMin", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterNdMin::new().build(ref_, indices, updates, scope)`.
pub fn resource_scatter_nd_min<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterNdMin::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ResourceScatterNdSub` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdSub {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterNdSub {
    /// Creates a new `ResourceScatterNdSub`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterNdSub` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterNdSub", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterNdSub::new().build(ref_, indices, updates, scope)`.
pub fn resource_scatter_nd_sub<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterNdSub::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ResourceScatterNdUpdate` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterNdUpdate {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterNdUpdate {
    /// Creates a new `ResourceScatterNdUpdate`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterNdUpdate` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterNdUpdate", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterNdUpdate::new().build(ref_, indices, updates, scope)`.
pub fn resource_scatter_nd_update<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterNdUpdate::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ResourceScatterSub` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterSub {
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterSub {
    /// Creates a new `ResourceScatterSub`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterSub` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterSub", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterSub::new().build(resource, indices, updates, scope)`.
pub fn resource_scatter_sub<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterSub::new().build(resource, indices, updates, scope)
}
/// Builder for the `ResourceScatterUpdate` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceScatterUpdate {
    dtype: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceScatterUpdate {
    /// Creates a new `ResourceScatterUpdate`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceScatterUpdate` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceScatterUpdate", |nd| {
            nd.add_input(resource);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceScatterUpdate::new().build(resource, indices, updates, scope)`.
pub fn resource_scatter_update<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceScatterUpdate::new().build(resource, indices, updates, scope)
}
/// Builder for the `ResourceSparseApplyAdadelta` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyAdadelta {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyAdadelta {
    /// Creates a new `ResourceSparseApplyAdadelta`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyAdadelta` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        accum_update: O2,
        lr: O3,
        rho: O4,
        epsilon: O5,
        grad: O6,
        indices: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            accum_update.into(),
            lr.into(),
            rho.into(),
            epsilon.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        accum_update: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyAdadelta", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(accum_update);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(epsilon);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyAdadelta::new().build(var, accum, accum_update, lr, rho, epsilon, grad, indices, scope)`.
pub fn resource_sparse_apply_adadelta<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    accum_update: O2,
    lr: O3,
    rho: O4,
    epsilon: O5,
    grad: O6,
    indices: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyAdadelta::new().build(
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        indices,
        scope,
    )
}
/// Builder for the `ResourceSparseApplyAdagrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyAdagrad {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    update_slots: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyAdagrad {
    /// Creates a new `ResourceSparseApplyAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `update_slots` attribute.
    pub fn update_slots<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.update_slots = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyAdagrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        indices: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyAdagrad", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.update_slots {
                nd.set_attr_bool("update_slots", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyAdagrad::new().build(var, accum, lr, grad, indices, scope)`.
pub fn resource_sparse_apply_adagrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    indices: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyAdagrad::new().build(var, accum, lr, grad, indices, scope)
}
/// Builder for the `ResourceSparseApplyAdagradDA` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyAdagradDA {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyAdagradDA {
    /// Creates a new `ResourceSparseApplyAdagradDA`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyAdagradDA` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        gradient_accumulator: O1,
        gradient_squared_accumulator: O2,
        grad: O3,
        indices: O4,
        lr: O5,
        l1: O6,
        l2: O7,
        global_step: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            gradient_accumulator.into(),
            gradient_squared_accumulator.into(),
            grad.into(),
            indices.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            global_step.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        gradient_accumulator: crate::Output,
        gradient_squared_accumulator: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        global_step: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyAdagradDA", |nd| {
            nd.add_input(var);
            nd.add_input(gradient_accumulator);
            nd.add_input(gradient_squared_accumulator);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(global_step);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyAdagradDA::new().build(var, gradient_accumulator, gradient_squared_accumulator, grad, indices, lr, l1, l2, global_step, scope)`.
pub fn resource_sparse_apply_adagrad_da<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    gradient_accumulator: O1,
    gradient_squared_accumulator: O2,
    grad: O3,
    indices: O4,
    lr: O5,
    l1: O6,
    l2: O7,
    global_step: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyAdagradDA::new().build(
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        indices,
        lr,
        l1,
        l2,
        global_step,
        scope,
    )
}
/// Builder for the `ResourceSparseApplyAdagradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyAdagradV2 {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    update_slots: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyAdagradV2 {
    /// Creates a new `ResourceSparseApplyAdagradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `update_slots` attribute.
    pub fn update_slots<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.update_slots = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyAdagradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        epsilon: O3,
        grad: O4,
        indices: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            epsilon.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyAdagradV2", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(epsilon);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.update_slots {
                nd.set_attr_bool("update_slots", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyAdagradV2::new().build(var, accum, lr, epsilon, grad, indices, scope)`.
pub fn resource_sparse_apply_adagrad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    epsilon: O3,
    grad: O4,
    indices: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyAdagradV2::new().build(var, accum, lr, epsilon, grad, indices, scope)
}
/// Builder for the `ResourceSparseApplyCenteredRMSProp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyCenteredRMSProp {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyCenteredRMSProp {
    /// Creates a new `ResourceSparseApplyCenteredRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyCenteredRMSProp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        mg: O1,
        ms: O2,
        mom: O3,
        lr: O4,
        rho: O5,
        momentum: O6,
        epsilon: O7,
        grad: O8,
        indices: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            mg.into(),
            ms.into(),
            mom.into(),
            lr.into(),
            rho.into(),
            momentum.into(),
            epsilon.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        mg: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        momentum: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyCenteredRMSProp", |nd| {
            nd.add_input(var);
            nd.add_input(mg);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(momentum);
            nd.add_input(epsilon);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyCenteredRMSProp::new().build(var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices, scope)`.
pub fn resource_sparse_apply_centered_rmsprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    mg: O1,
    ms: O2,
    mom: O3,
    lr: O4,
    rho: O5,
    momentum: O6,
    epsilon: O7,
    grad: O8,
    indices: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyCenteredRMSProp::new().build(
        var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices, scope,
    )
}
/// Builder for the `ResourceSparseApplyFtrl` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyFtrl {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    multiply_linear_by_lr: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyFtrl {
    /// Creates a new `ResourceSparseApplyFtrl`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `multiply_linear_by_lr` attribute.
    pub fn multiply_linear_by_lr<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.multiply_linear_by_lr = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyFtrl` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        linear: O2,
        grad: O3,
        indices: O4,
        lr: O5,
        l1: O6,
        l2: O7,
        lr_power: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            linear.into(),
            grad.into(),
            indices.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            lr_power.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        linear: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        lr_power: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyFtrl", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(linear);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(lr_power);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.multiply_linear_by_lr {
                nd.set_attr_bool("multiply_linear_by_lr", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyFtrl::new().build(var, accum, linear, grad, indices, lr, l1, l2, lr_power, scope)`.
pub fn resource_sparse_apply_ftrl<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    linear: O2,
    grad: O3,
    indices: O4,
    lr: O5,
    l1: O6,
    l2: O7,
    lr_power: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyFtrl::new().build(
        var, accum, linear, grad, indices, lr, l1, l2, lr_power, scope,
    )
}
/// Builder for the `ResourceSparseApplyFtrlV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyFtrlV2 {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    multiply_linear_by_lr: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyFtrlV2 {
    /// Creates a new `ResourceSparseApplyFtrlV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `multiply_linear_by_lr` attribute.
    pub fn multiply_linear_by_lr<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.multiply_linear_by_lr = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyFtrlV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        linear: O2,
        grad: O3,
        indices: O4,
        lr: O5,
        l1: O6,
        l2: O7,
        l2_shrinkage: O8,
        lr_power: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            linear.into(),
            grad.into(),
            indices.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            l2_shrinkage.into(),
            lr_power.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        linear: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        l2_shrinkage: crate::Output,
        lr_power: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyFtrlV2", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(linear);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(l2_shrinkage);
            nd.add_input(lr_power);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.multiply_linear_by_lr {
                nd.set_attr_bool("multiply_linear_by_lr", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyFtrlV2::new().build(var, accum, linear, grad, indices, lr, l1, l2, l2_shrinkage, lr_power, scope)`.
pub fn resource_sparse_apply_ftrl_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    linear: O2,
    grad: O3,
    indices: O4,
    lr: O5,
    l1: O6,
    l2: O7,
    l2_shrinkage: O8,
    lr_power: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyFtrlV2::new().build(
        var,
        accum,
        linear,
        grad,
        indices,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        scope,
    )
}
/// Builder for the `ResourceSparseApplyKerasMomentum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyKerasMomentum {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    use_nesterov: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyKerasMomentum {
    /// Creates a new `ResourceSparseApplyKerasMomentum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_nesterov` attribute.
    pub fn use_nesterov<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_nesterov = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyKerasMomentum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        indices: O4,
        momentum: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            grad.into(),
            indices.into(),
            momentum.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        momentum: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyKerasMomentum", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(momentum);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_nesterov {
                nd.set_attr_bool("use_nesterov", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyKerasMomentum::new().build(var, accum, lr, grad, indices, momentum, scope)`.
pub fn resource_sparse_apply_keras_momentum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    indices: O4,
    momentum: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyKerasMomentum::new().build(var, accum, lr, grad, indices, momentum, scope)
}
/// Builder for the `ResourceSparseApplyMomentum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyMomentum {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    use_nesterov: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyMomentum {
    /// Creates a new `ResourceSparseApplyMomentum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_nesterov` attribute.
    pub fn use_nesterov<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_nesterov = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyMomentum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        indices: O4,
        momentum: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            grad.into(),
            indices.into(),
            momentum.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        momentum: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyMomentum", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(momentum);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_nesterov {
                nd.set_attr_bool("use_nesterov", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyMomentum::new().build(var, accum, lr, grad, indices, momentum, scope)`.
pub fn resource_sparse_apply_momentum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    indices: O4,
    momentum: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyMomentum::new().build(var, accum, lr, grad, indices, momentum, scope)
}
/// Builder for the `ResourceSparseApplyProximalAdagrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyProximalAdagrad {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyProximalAdagrad {
    /// Creates a new `ResourceSparseApplyProximalAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyProximalAdagrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        l1: O3,
        l2: O4,
        grad: O5,
        indices: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyProximalAdagrad", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyProximalAdagrad::new().build(var, accum, lr, l1, l2, grad, indices, scope)`.
pub fn resource_sparse_apply_proximal_adagrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    l1: O3,
    l2: O4,
    grad: O5,
    indices: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyProximalAdagrad::new().build(var, accum, lr, l1, l2, grad, indices, scope)
}
/// Builder for the `ResourceSparseApplyProximalGradientDescent` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyProximalGradientDescent {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyProximalGradientDescent {
    /// Creates a new `ResourceSparseApplyProximalGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyProximalGradientDescent` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        alpha: O1,
        l1: O2,
        l2: O3,
        grad: O4,
        indices: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            alpha.into(),
            l1.into(),
            l2.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        alpha: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyProximalGradientDescent", |nd| {
            nd.add_input(var);
            nd.add_input(alpha);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyProximalGradientDescent::new().build(var, alpha, l1, l2, grad, indices, scope)`.
pub fn resource_sparse_apply_proximal_gradient_descent<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    alpha: O1,
    l1: O2,
    l2: O3,
    grad: O4,
    indices: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyProximalGradientDescent::new()
        .build(var, alpha, l1, l2, grad, indices, scope)
}
/// Builder for the `ResourceSparseApplyRMSProp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceSparseApplyRMSProp {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceSparseApplyRMSProp {
    /// Creates a new `ResourceSparseApplyRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceSparseApplyRMSProp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        ms: O1,
        mom: O2,
        lr: O3,
        rho: O4,
        momentum: O5,
        epsilon: O6,
        grad: O7,
        indices: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            ms.into(),
            mom.into(),
            lr.into(),
            rho.into(),
            momentum.into(),
            epsilon.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        momentum: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceSparseApplyRMSProp", |nd| {
            nd.add_input(var);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(momentum);
            nd.add_input(epsilon);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceSparseApplyRMSProp::new().build(var, ms, mom, lr, rho, momentum, epsilon, grad, indices, scope)`.
pub fn resource_sparse_apply_rmsprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    ms: O1,
    mom: O2,
    lr: O3,
    rho: O4,
    momentum: O5,
    epsilon: O6,
    grad: O7,
    indices: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceSparseApplyRMSProp::new().build(
        var, ms, mom, lr, rho, momentum, epsilon, grad, indices, scope,
    )
}
/// Builder for the `ResourceStridedSliceAssign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ResourceStridedSliceAssign {
    T: ::std::option::Option<crate::DataType>,
    Index: ::std::option::Option<crate::DataType>,
    begin_mask: ::std::option::Option<i64>,
    end_mask: ::std::option::Option<i64>,
    ellipsis_mask: ::std::option::Option<i64>,
    new_axis_mask: ::std::option::Option<i64>,
    shrink_axis_mask: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ResourceStridedSliceAssign {
    /// Creates a new `ResourceStridedSliceAssign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Index` attribute.
    pub fn Index<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `begin_mask` attribute.
    pub fn begin_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.begin_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `end_mask` attribute.
    pub fn end_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.end_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ellipsis_mask` attribute.
    pub fn ellipsis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.ellipsis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `new_axis_mask` attribute.
    pub fn new_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.new_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shrink_axis_mask` attribute.
    pub fn shrink_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shrink_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ResourceStridedSliceAssign` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        begin: O1,
        end: O2,
        strides: O3,
        value: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            ref_.into(),
            begin.into(),
            end.into(),
            strides.into(),
            value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        begin: crate::Output,
        end: crate::Output,
        strides: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ResourceStridedSliceAssign", |nd| {
            nd.add_input(ref_);
            nd.add_input(begin);
            nd.add_input(end);
            nd.add_input(strides);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Index {
                nd.set_attr_type("Index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.begin_mask {
                nd.set_attr_int("begin_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.end_mask {
                nd.set_attr_int("end_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ellipsis_mask {
                nd.set_attr_int("ellipsis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.new_axis_mask {
                nd.set_attr_int("new_axis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shrink_axis_mask {
                nd.set_attr_int("shrink_axis_mask", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ResourceStridedSliceAssign::new().build(ref_, begin, end, strides, value, scope)`.
pub fn resource_strided_slice_assign<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    begin: O1,
    end: O2,
    strides: O3,
    value: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ResourceStridedSliceAssign::new().build(ref_, begin, end, strides, value, scope)
}
/// Builder for the `Restore` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Restore {
    dt: ::std::option::Option<crate::DataType>,
    preferred_shard: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Restore {
    /// Creates a new `Restore`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dt` attribute.
    pub fn dt<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dt = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preferred_shard` attribute.
    pub fn preferred_shard<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.preferred_shard = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Restore` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        file_pattern: O0,
        tensor_name: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(file_pattern.into(), tensor_name.into(), scope)
    }

    fn build_impl(
        &self,
        file_pattern: crate::Output,
        tensor_name: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Restore", |nd| {
            nd.add_input(file_pattern);
            nd.add_input(tensor_name);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dt {
                nd.set_attr_type("dt", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preferred_shard {
                nd.set_attr_int("preferred_shard", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Restore::new().build(file_pattern, tensor_name, scope)`.
pub fn restore<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    file_pattern: O0,
    tensor_name: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Restore::new().build(file_pattern, tensor_name, scope)
}
/// Builder for the `RestoreSlice` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RestoreSlice {
    dt: ::std::option::Option<crate::DataType>,
    preferred_shard: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RestoreSlice {
    /// Creates a new `RestoreSlice`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dt` attribute.
    pub fn dt<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dt = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preferred_shard` attribute.
    pub fn preferred_shard<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.preferred_shard = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RestoreSlice` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        file_pattern: O0,
        tensor_name: O1,
        shape_and_slice: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            file_pattern.into(),
            tensor_name.into(),
            shape_and_slice.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        file_pattern: crate::Output,
        tensor_name: crate::Output,
        shape_and_slice: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RestoreSlice", |nd| {
            nd.add_input(file_pattern);
            nd.add_input(tensor_name);
            nd.add_input(shape_and_slice);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dt {
                nd.set_attr_type("dt", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preferred_shard {
                nd.set_attr_int("preferred_shard", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RestoreSlice::new().build(file_pattern, tensor_name, shape_and_slice, scope)`.
pub fn restore_slice<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    file_pattern: O0,
    tensor_name: O1,
    shape_and_slice: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RestoreSlice::new().build(file_pattern, tensor_name, shape_and_slice, scope)
}
/// Builder for the `RestoreV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RestoreV2 {
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RestoreV2 {
    /// Creates a new `RestoreV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RestoreV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        prefix: O0,
        tensor_names: O1,
        shape_and_slices: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            prefix.into(),
            tensor_names.into(),
            shape_and_slices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        prefix: crate::Output,
        tensor_names: crate::Output,
        shape_and_slices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RestoreV2", |nd| {
            nd.add_input(prefix);
            nd.add_input(tensor_names);
            nd.add_input(shape_and_slices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RestoreV2::new().build(prefix, tensor_names, shape_and_slices, scope)`.
pub fn restore_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    prefix: O0,
    tensor_names: O1,
    shape_and_slices: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RestoreV2::new().build(prefix, tensor_names, shape_and_slices, scope)
}
/// Builder for the `RetrieveTPUEmbeddingADAMParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingADAMParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingADAMParameters {
    /// Creates a new `RetrieveTPUEmbeddingADAMParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingADAMParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingADAMParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingADAMParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_adamparameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingADAMParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingADAMParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingADAMParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingADAMParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingADAMParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingADAMParametersGradAccumDebug", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingADAMParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_adamparameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingADAMParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingAdadeltaParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingAdadeltaParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingAdadeltaParameters {
    /// Creates a new `RetrieveTPUEmbeddingAdadeltaParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingAdadeltaParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingAdadeltaParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingAdadeltaParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_adadelta_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingAdadeltaParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug",
            |nd| {
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_adadelta_parameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingAdagradParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingAdagradParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingAdagradParameters {
    /// Creates a new `RetrieveTPUEmbeddingAdagradParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingAdagradParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingAdagradParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingAdagradParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_adagrad_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingAdagradParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingAdagradParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingAdagradParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingAdagradParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingAdagradParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "RetrieveTPUEmbeddingAdagradParametersGradAccumDebug",
            |nd| {
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `RetrieveTPUEmbeddingAdagradParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_adagrad_parameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingAdagradParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingCenteredRMSPropParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingCenteredRMSPropParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingCenteredRMSPropParameters {
    /// Creates a new `RetrieveTPUEmbeddingCenteredRMSPropParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingCenteredRMSPropParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingCenteredRMSPropParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingCenteredRMSPropParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_centered_rmsprop_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingCenteredRMSPropParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingFTRLParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingFTRLParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingFTRLParameters {
    /// Creates a new `RetrieveTPUEmbeddingFTRLParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingFTRLParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingFTRLParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingFTRLParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_ftrlparameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingFTRLParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingFTRLParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingFTRLParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingFTRLParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingFTRLParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingFTRLParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_ftrlparameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingFTRLParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingMDLAdagradLightParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingMDLAdagradLightParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingMDLAdagradLightParameters {
    /// Creates a new `RetrieveTPUEmbeddingMDLAdagradLightParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingMDLAdagradLightParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingMDLAdagradLightParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingMDLAdagradLightParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_mdladagrad_light_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingMDLAdagradLightParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingMomentumParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingMomentumParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingMomentumParameters {
    /// Creates a new `RetrieveTPUEmbeddingMomentumParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingMomentumParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingMomentumParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingMomentumParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_momentum_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingMomentumParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingMomentumParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingMomentumParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingMomentumParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingMomentumParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "RetrieveTPUEmbeddingMomentumParametersGradAccumDebug",
            |nd| {
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `RetrieveTPUEmbeddingMomentumParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_momentum_parameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingMomentumParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingProximalAdagradParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingProximalAdagradParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingProximalAdagradParameters {
    /// Creates a new `RetrieveTPUEmbeddingProximalAdagradParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingProximalAdagradParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingProximalAdagradParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingProximalAdagradParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_proximal_adagrad_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingProximalAdagradParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug",
            |nd| {
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_proximal_adagrad_parameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingProximalYogiParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingProximalYogiParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingProximalYogiParameters {
    /// Creates a new `RetrieveTPUEmbeddingProximalYogiParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingProximalYogiParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingProximalYogiParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingProximalYogiParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_proximal_yogi_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingProximalYogiParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug",
            |nd| {
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_proximal_yogi_parameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingRMSPropParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingRMSPropParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingRMSPropParameters {
    /// Creates a new `RetrieveTPUEmbeddingRMSPropParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingRMSPropParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("RetrieveTPUEmbeddingRMSPropParameters", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.table_name {
                nd.set_attr_string("table_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_shards {
                nd.set_attr_int("num_shards", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_id {
                nd.set_attr_int("shard_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RetrieveTPUEmbeddingRMSPropParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_rmsprop_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingRMSPropParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug",
            |nd| {
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_rmsprop_parameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingStochasticGradientDescentParameters` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingStochasticGradientDescentParameters {
    /// Creates a new `RetrieveTPUEmbeddingStochasticGradientDescentParameters`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingStochasticGradientDescentParameters` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "RetrieveTPUEmbeddingStochasticGradientDescentParameters",
            |nd| {
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `RetrieveTPUEmbeddingStochasticGradientDescentParameters::new().build(scope)`.
pub fn retrieve_tpuembedding_stochastic_gradient_descent_parameters(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingStochasticGradientDescentParameters::new().build(scope)
}
/// Builder for the `RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug {
    table_id: ::std::option::Option<i64>,
    table_name: ::std::option::Option<::std::string::String>,
    num_shards: ::std::option::Option<i64>,
    shard_id: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug {
    /// Creates a new `RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `table_name` attribute.
    pub fn table_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.table_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_shards` attribute.
    pub fn num_shards<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_shards = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_id` attribute.
    pub fn shard_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation(
            "RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug",
            |nd| {
                for op in &self.control_inputs {
                    nd.add_control_input(op);
                }
                if let ::std::option::Option::Some(value) = &self.table_id {
                    nd.set_attr_int("table_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.table_name {
                    nd.set_attr_string("table_name", value)?;
                }
                if let ::std::option::Option::Some(value) = &self.num_shards {
                    nd.set_attr_int("num_shards", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.shard_id {
                    nd.set_attr_int("shard_id", *value)?;
                }
                if let ::std::option::Option::Some(value) = &self.config {
                    nd.set_attr_string("config", value)?;
                }
                ::std::result::Result::Ok(())
            },
        )
    }
}

/// Shorthand for `RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug::new().build(scope)`.
pub fn retrieve_tpuembedding_stochastic_gradient_descent_parameters_grad_accum_debug(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug::new().build(scope)
}
/// Builder for the `Reverse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Reverse {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Reverse {
    /// Creates a new `Reverse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Reverse` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        dims: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), dims.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        dims: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Reverse", |nd| {
            nd.add_input(tensor);
            nd.add_input(dims);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Reverse::new().build(tensor, dims, scope)`.
pub fn reverse<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    tensor: O0,
    dims: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Reverse::new().build(tensor, dims, scope)
}
/// Builder for the `ReverseSequence` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReverseSequence {
    seq_dim: ::std::option::Option<i64>,
    batch_dim: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    Tlen: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReverseSequence {
    /// Creates a new `ReverseSequence`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seq_dim` attribute.
    pub fn seq_dim<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seq_dim = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `batch_dim` attribute.
    pub fn batch_dim<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.batch_dim = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tlen` attribute.
    pub fn Tlen<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tlen = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReverseSequence` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        seq_lengths: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), seq_lengths.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        seq_lengths: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReverseSequence", |nd| {
            nd.add_input(input);
            nd.add_input(seq_lengths);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seq_dim {
                nd.set_attr_int("seq_dim", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.batch_dim {
                nd.set_attr_int("batch_dim", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tlen {
                nd.set_attr_type("Tlen", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReverseSequence::new().build(input, seq_lengths, scope)`.
pub fn reverse_sequence<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    seq_lengths: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReverseSequence::new().build(input, seq_lengths, scope)
}
/// Builder for the `ReverseV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ReverseV2 {
    Tidx: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ReverseV2 {
    /// Creates a new `ReverseV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ReverseV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        axis: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ReverseV2", |nd| {
            nd.add_input(tensor);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ReverseV2::new().build(tensor, axis, scope)`.
pub fn reverse_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    axis: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ReverseV2::new().build(tensor, axis, scope)
}
/// Builder for the `RightShift` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RightShift {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RightShift {
    /// Creates a new `RightShift`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RightShift` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RightShift", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RightShift::new().build(x, y, scope)`.
pub fn right_shift<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RightShift::new().build(x, y, scope)
}
/// Builder for the `Rint` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Rint {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Rint {
    /// Creates a new `Rint`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Rint` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Rint", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Rint::new().build(x, scope)`.
pub fn rint<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Rint::new().build(x, scope)
}
/// Builder for the `RngSkip` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RngSkip {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RngSkip {
    /// Creates a new `RngSkip`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RngSkip` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        algorithm: O1,
        delta: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), algorithm.into(), delta.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        algorithm: crate::Output,
        delta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RngSkip", |nd| {
            nd.add_input(resource);
            nd.add_input(algorithm);
            nd.add_input(delta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RngSkip::new().build(resource, algorithm, delta, scope)`.
pub fn rng_skip<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    algorithm: O1,
    delta: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RngSkip::new().build(resource, algorithm, delta, scope)
}
/// Builder for the `Roll` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Roll {
    T: ::std::option::Option<crate::DataType>,
    Tshift: ::std::option::Option<crate::DataType>,
    Taxis: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Roll {
    /// Creates a new `Roll`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tshift` attribute.
    pub fn Tshift<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tshift = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Taxis` attribute.
    pub fn Taxis<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Taxis = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Roll` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        shift: O1,
        axis: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), shift.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        shift: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Roll", |nd| {
            nd.add_input(input);
            nd.add_input(shift);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tshift {
                nd.set_attr_type("Tshift", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Taxis {
                nd.set_attr_type("Taxis", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Roll::new().build(input, shift, axis, scope)`.
pub fn roll<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    shift: O1,
    axis: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Roll::new().build(input, shift, axis, scope)
}
/// Builder for the `Round` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Round {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Round {
    /// Creates a new `Round`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Round` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Round", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Round::new().build(x, scope)`.
pub fn round<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Round::new().build(x, scope)
}
/// Builder for the `Rpc` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Rpc {
    protocol: ::std::option::Option<::std::string::String>,
    fail_fast: ::std::option::Option<bool>,
    timeout_in_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Rpc {
    /// Creates a new `Rpc`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `protocol` attribute.
    pub fn protocol<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.protocol = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fail_fast` attribute.
    pub fn fail_fast<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.fail_fast = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_in_ms` attribute.
    pub fn timeout_in_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_in_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Rpc` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        address: O0,
        method: O1,
        request: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(address.into(), method.into(), request.into(), scope)
    }

    fn build_impl(
        &self,
        address: crate::Output,
        method: crate::Output,
        request: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Rpc", |nd| {
            nd.add_input(address);
            nd.add_input(method);
            nd.add_input(request);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.protocol {
                nd.set_attr_string("protocol", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fail_fast {
                nd.set_attr_bool("fail_fast", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_in_ms {
                nd.set_attr_int("timeout_in_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Rpc::new().build(address, method, request, scope)`.
pub fn rpc<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    address: O0,
    method: O1,
    request: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Rpc::new().build(address, method, request, scope)
}
/// Builder for the `Rsqrt` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Rsqrt {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Rsqrt {
    /// Creates a new `Rsqrt`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Rsqrt` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Rsqrt", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Rsqrt::new().build(x, scope)`.
pub fn rsqrt<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Rsqrt::new().build(x, scope)
}
/// Builder for the `RsqrtGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct RsqrtGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl RsqrtGrad {
    /// Creates a new `RsqrtGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `RsqrtGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y: O0,
        dy: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(y.into(), dy.into(), scope)
    }

    fn build_impl(
        &self,
        y: crate::Output,
        dy: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("RsqrtGrad", |nd| {
            nd.add_input(y);
            nd.add_input(dy);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `RsqrtGrad::new().build(y, dy, scope)`.
pub fn rsqrt_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    y: O0,
    dy: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    RsqrtGrad::new().build(y, dy, scope)
}
/// Builder for the `SampleDistortedBoundingBox` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SampleDistortedBoundingBox {
    T: ::std::option::Option<crate::DataType>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    min_object_covered: ::std::option::Option<f32>,
    aspect_ratio_range: ::std::option::Option<::std::vec::Vec<f32>>,
    area_range: ::std::option::Option<::std::vec::Vec<f32>>,
    max_attempts: ::std::option::Option<i64>,
    use_image_if_no_bounding_boxes: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SampleDistortedBoundingBox {
    /// Creates a new `SampleDistortedBoundingBox`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `min_object_covered` attribute.
    pub fn min_object_covered<ArgType: ::std::convert::Into<f32>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.min_object_covered = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `aspect_ratio_range` attribute.
    pub fn aspect_ratio_range<ArgType: ::std::convert::Into<::std::vec::Vec<f32>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.aspect_ratio_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `area_range` attribute.
    pub fn area_range<ArgType: ::std::convert::Into<::std::vec::Vec<f32>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.area_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_attempts` attribute.
    pub fn max_attempts<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_attempts = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_image_if_no_bounding_boxes` attribute.
    pub fn use_image_if_no_bounding_boxes<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_image_if_no_bounding_boxes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SampleDistortedBoundingBox` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        image_size: O0,
        bounding_boxes: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(image_size.into(), bounding_boxes.into(), scope)
    }

    fn build_impl(
        &self,
        image_size: crate::Output,
        bounding_boxes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SampleDistortedBoundingBox", |nd| {
            nd.add_input(image_size);
            nd.add_input(bounding_boxes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.min_object_covered {
                nd.set_attr_float("min_object_covered", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.aspect_ratio_range {
                nd.set_attr_float_list("aspect_ratio_range", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.area_range {
                nd.set_attr_float_list("area_range", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_attempts {
                nd.set_attr_int("max_attempts", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_image_if_no_bounding_boxes {
                nd.set_attr_bool("use_image_if_no_bounding_boxes", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SampleDistortedBoundingBox::new().build(image_size, bounding_boxes, scope)`.
pub fn sample_distorted_bounding_box<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    image_size: O0,
    bounding_boxes: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SampleDistortedBoundingBox::new().build(image_size, bounding_boxes, scope)
}
/// Builder for the `SampleDistortedBoundingBoxV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SampleDistortedBoundingBoxV2 {
    T: ::std::option::Option<crate::DataType>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    aspect_ratio_range: ::std::option::Option<::std::vec::Vec<f32>>,
    area_range: ::std::option::Option<::std::vec::Vec<f32>>,
    max_attempts: ::std::option::Option<i64>,
    use_image_if_no_bounding_boxes: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SampleDistortedBoundingBoxV2 {
    /// Creates a new `SampleDistortedBoundingBoxV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `aspect_ratio_range` attribute.
    pub fn aspect_ratio_range<ArgType: ::std::convert::Into<::std::vec::Vec<f32>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.aspect_ratio_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `area_range` attribute.
    pub fn area_range<ArgType: ::std::convert::Into<::std::vec::Vec<f32>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.area_range = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_attempts` attribute.
    pub fn max_attempts<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_attempts = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_image_if_no_bounding_boxes` attribute.
    pub fn use_image_if_no_bounding_boxes<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_image_if_no_bounding_boxes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SampleDistortedBoundingBoxV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        image_size: O0,
        bounding_boxes: O1,
        min_object_covered: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            image_size.into(),
            bounding_boxes.into(),
            min_object_covered.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        image_size: crate::Output,
        bounding_boxes: crate::Output,
        min_object_covered: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SampleDistortedBoundingBoxV2", |nd| {
            nd.add_input(image_size);
            nd.add_input(bounding_boxes);
            nd.add_input(min_object_covered);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.aspect_ratio_range {
                nd.set_attr_float_list("aspect_ratio_range", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.area_range {
                nd.set_attr_float_list("area_range", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_attempts {
                nd.set_attr_int("max_attempts", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_image_if_no_bounding_boxes {
                nd.set_attr_bool("use_image_if_no_bounding_boxes", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SampleDistortedBoundingBoxV2::new().build(image_size, bounding_boxes, min_object_covered, scope)`.
pub fn sample_distorted_bounding_box_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    image_size: O0,
    bounding_boxes: O1,
    min_object_covered: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SampleDistortedBoundingBoxV2::new().build(image_size, bounding_boxes, min_object_covered, scope)
}
/// Builder for the `SamplingDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SamplingDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SamplingDataset {
    /// Creates a new `SamplingDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SamplingDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        rate: O1,
        seed: O2,
        seed2: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            rate.into(),
            seed.into(),
            seed2.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        rate: crate::Output,
        seed: crate::Output,
        seed2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SamplingDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(rate);
            nd.add_input(seed);
            nd.add_input(seed2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SamplingDataset::new().build(input_dataset, rate, seed, seed2, scope)`.
pub fn sampling_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    rate: O1,
    seed: O2,
    seed2: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SamplingDataset::new().build(input_dataset, rate, seed, seed2, scope)
}
/// Builder for the `Save` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Save {
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Save {
    /// Creates a new `Save`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Save` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filename: O0,
        tensor_names: O1,
        data: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(filename.into(), tensor_names.into(), data.into(), scope)
    }

    fn build_impl(
        &self,
        filename: crate::Output,
        tensor_names: crate::Output,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Save", |nd| {
            nd.add_input(filename);
            nd.add_input(tensor_names);
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Save::new().build(filename, tensor_names, data, scope)`.
pub fn save<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    filename: O0,
    tensor_names: O1,
    data: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Save::new().build(filename, tensor_names, data, scope)
}
/// Builder for the `SaveDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SaveDataset {
    compression: ::std::option::Option<::std::string::String>,
    shard_func: ::std::option::Option<::std::string::String>,
    use_shard_func: ::std::option::Option<bool>,
    Tshard_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SaveDataset {
    /// Creates a new `SaveDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `compression` attribute.
    pub fn compression<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compression = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_func` attribute.
    pub fn shard_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shard_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_shard_func` attribute.
    pub fn use_shard_func<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_shard_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tshard_func_args` attribute.
    pub fn Tshard_func_args<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tshard_func_args = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SaveDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        path: O1,
        shard_func_other_args: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            path.into(),
            shard_func_other_args.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        path: crate::Output,
        shard_func_other_args: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SaveDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(path);
            nd.add_input(shard_func_other_args);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.compression {
                nd.set_attr_string("compression", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_func {
                nd.set_attr_string("shard_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_shard_func {
                nd.set_attr_bool("use_shard_func", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tshard_func_args {
                nd.set_attr_type_list("Tshard_func_args", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SaveDataset::new().build(input_dataset, path, shard_func_other_args, scope)`.
pub fn save_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    path: O1,
    shard_func_other_args: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SaveDataset::new().build(input_dataset, path, shard_func_other_args, scope)
}
/// Builder for the `SaveSlices` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SaveSlices {
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SaveSlices {
    /// Creates a new `SaveSlices`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SaveSlices` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filename: O0,
        tensor_names: O1,
        shapes_and_slices: O2,
        data: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            filename.into(),
            tensor_names.into(),
            shapes_and_slices.into(),
            data.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        filename: crate::Output,
        tensor_names: crate::Output,
        shapes_and_slices: crate::Output,
        data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SaveSlices", |nd| {
            nd.add_input(filename);
            nd.add_input(tensor_names);
            nd.add_input(shapes_and_slices);
            nd.add_input(data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SaveSlices::new().build(filename, tensor_names, shapes_and_slices, data, scope)`.
pub fn save_slices<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    filename: O0,
    tensor_names: O1,
    shapes_and_slices: O2,
    data: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SaveSlices::new().build(filename, tensor_names, shapes_and_slices, data, scope)
}
/// Builder for the `SaveV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SaveV2 {
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SaveV2 {
    /// Creates a new `SaveV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SaveV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        prefix: O0,
        tensor_names: O1,
        shape_and_slices: O2,
        tensors: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            prefix.into(),
            tensor_names.into(),
            shape_and_slices.into(),
            tensors.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        prefix: crate::Output,
        tensor_names: crate::Output,
        shape_and_slices: crate::Output,
        tensors: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SaveV2", |nd| {
            nd.add_input(prefix);
            nd.add_input(tensor_names);
            nd.add_input(shape_and_slices);
            nd.add_input(tensors);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SaveV2::new().build(prefix, tensor_names, shape_and_slices, tensors, scope)`.
pub fn save_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    prefix: O0,
    tensor_names: O1,
    shape_and_slices: O2,
    tensors: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SaveV2::new().build(prefix, tensor_names, shape_and_slices, tensors, scope)
}
/// Builder for the `ScalarSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScalarSummary {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScalarSummary {
    /// Creates a new `ScalarSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScalarSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tags: O0,
        values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tags.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        tags: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScalarSummary", |nd| {
            nd.add_input(tags);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScalarSummary::new().build(tags, values, scope)`.
pub fn scalar_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tags: O0,
    values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScalarSummary::new().build(tags, values, scope)
}
/// Builder for the `ScaleAndTranslate` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScaleAndTranslate {
    T: ::std::option::Option<crate::DataType>,
    kernel_type: ::std::option::Option<::std::string::String>,
    antialias: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScaleAndTranslate {
    /// Creates a new `ScaleAndTranslate`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `kernel_type` attribute.
    pub fn kernel_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.kernel_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `antialias` attribute.
    pub fn antialias<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.antialias = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScaleAndTranslate` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        images: O0,
        size: O1,
        scale: O2,
        translation: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            images.into(),
            size.into(),
            scale.into(),
            translation.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        images: crate::Output,
        size: crate::Output,
        scale: crate::Output,
        translation: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScaleAndTranslate", |nd| {
            nd.add_input(images);
            nd.add_input(size);
            nd.add_input(scale);
            nd.add_input(translation);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.kernel_type {
                nd.set_attr_string("kernel_type", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.antialias {
                nd.set_attr_bool("antialias", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScaleAndTranslate::new().build(images, size, scale, translation, scope)`.
pub fn scale_and_translate<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    images: O0,
    size: O1,
    scale: O2,
    translation: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScaleAndTranslate::new().build(images, size, scale, translation, scope)
}
/// Builder for the `ScaleAndTranslateGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScaleAndTranslateGrad {
    T: ::std::option::Option<crate::DataType>,
    kernel_type: ::std::option::Option<::std::string::String>,
    antialias: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScaleAndTranslateGrad {
    /// Creates a new `ScaleAndTranslateGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `kernel_type` attribute.
    pub fn kernel_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.kernel_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `antialias` attribute.
    pub fn antialias<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.antialias = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScaleAndTranslateGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        grads: O0,
        original_image: O1,
        scale: O2,
        translation: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            grads.into(),
            original_image.into(),
            scale.into(),
            translation.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        grads: crate::Output,
        original_image: crate::Output,
        scale: crate::Output,
        translation: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScaleAndTranslateGrad", |nd| {
            nd.add_input(grads);
            nd.add_input(original_image);
            nd.add_input(scale);
            nd.add_input(translation);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.kernel_type {
                nd.set_attr_string("kernel_type", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.antialias {
                nd.set_attr_bool("antialias", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScaleAndTranslateGrad::new().build(grads, original_image, scale, translation, scope)`.
pub fn scale_and_translate_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    grads: O0,
    original_image: O1,
    scale: O2,
    translation: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScaleAndTranslateGrad::new().build(grads, original_image, scale, translation, scope)
}
/// Builder for the `ScanDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScanDataset {
    f: ::std::option::Option<::std::string::String>,
    Tstate: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    preserve_cardinality: ::std::option::Option<bool>,
    use_default_device: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScanDataset {
    /// Creates a new `ScanDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tstate` attribute.
    pub fn Tstate<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tstate = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_cardinality` attribute.
    pub fn preserve_cardinality<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_cardinality = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_default_device` attribute.
    pub fn use_default_device<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.use_default_device = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScanDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        initial_state: O1,
        other_arguments: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            initial_state.into(),
            other_arguments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        initial_state: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScanDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(initial_state);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tstate {
                nd.set_attr_type_list("Tstate", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_cardinality {
                nd.set_attr_bool("preserve_cardinality", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_default_device {
                nd.set_attr_bool("use_default_device", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScanDataset::new().build(input_dataset, initial_state, other_arguments, scope)`.
pub fn scan_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    initial_state: O1,
    other_arguments: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScanDataset::new().build(input_dataset, initial_state, other_arguments, scope)
}
/// Builder for the `ScatterAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterAdd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterAdd {
    /// Creates a new `ScatterAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterAdd", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterAdd::new().build(ref_, indices, updates, scope)`.
pub fn scatter_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterAdd::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterDiv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterDiv {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterDiv {
    /// Creates a new `ScatterDiv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterDiv` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterDiv", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterDiv::new().build(ref_, indices, updates, scope)`.
pub fn scatter_div<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterDiv::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterMax {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterMax {
    /// Creates a new `ScatterMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterMax", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterMax::new().build(ref_, indices, updates, scope)`.
pub fn scatter_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterMax::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterMin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterMin {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterMin {
    /// Creates a new `ScatterMin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterMin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterMin", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterMin::new().build(ref_, indices, updates, scope)`.
pub fn scatter_min<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterMin::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterMul {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterMul {
    /// Creates a new `ScatterMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterMul", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterMul::new().build(ref_, indices, updates, scope)`.
pub fn scatter_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterMul::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterNd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterNd {
    /// Creates a new `ScatterNd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterNd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        updates: O1,
        shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), updates.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        updates: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterNd", |nd| {
            nd.add_input(indices);
            nd.add_input(updates);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterNd::new().build(indices, updates, shape, scope)`.
pub fn scatter_nd<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    updates: O1,
    shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterNd::new().build(indices, updates, shape, scope)
}
/// Builder for the `ScatterNdAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdAdd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterNdAdd {
    /// Creates a new `ScatterNdAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterNdAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterNdAdd", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterNdAdd::new().build(ref_, indices, updates, scope)`.
pub fn scatter_nd_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterNdAdd::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterNdMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdMax {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterNdMax {
    /// Creates a new `ScatterNdMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterNdMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterNdMax", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterNdMax::new().build(ref_, indices, updates, scope)`.
pub fn scatter_nd_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterNdMax::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterNdMin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdMin {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterNdMin {
    /// Creates a new `ScatterNdMin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterNdMin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterNdMin", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterNdMin::new().build(ref_, indices, updates, scope)`.
pub fn scatter_nd_min<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterNdMin::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterNdNonAliasingAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdNonAliasingAdd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterNdNonAliasingAdd {
    /// Creates a new `ScatterNdNonAliasingAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterNdNonAliasingAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterNdNonAliasingAdd", |nd| {
            nd.add_input(input);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterNdNonAliasingAdd::new().build(input, indices, updates, scope)`.
pub fn scatter_nd_non_aliasing_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterNdNonAliasingAdd::new().build(input, indices, updates, scope)
}
/// Builder for the `ScatterNdSub` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdSub {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterNdSub {
    /// Creates a new `ScatterNdSub`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterNdSub` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterNdSub", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterNdSub::new().build(ref_, indices, updates, scope)`.
pub fn scatter_nd_sub<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterNdSub::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterNdUpdate` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterNdUpdate {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterNdUpdate {
    /// Creates a new `ScatterNdUpdate`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterNdUpdate` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterNdUpdate", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterNdUpdate::new().build(ref_, indices, updates, scope)`.
pub fn scatter_nd_update<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterNdUpdate::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterSub` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterSub {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterSub {
    /// Creates a new `ScatterSub`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterSub` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterSub", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterSub::new().build(ref_, indices, updates, scope)`.
pub fn scatter_sub<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterSub::new().build(ref_, indices, updates, scope)
}
/// Builder for the `ScatterUpdate` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ScatterUpdate {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ScatterUpdate {
    /// Creates a new `ScatterUpdate`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ScatterUpdate` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(ref_.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ScatterUpdate", |nd| {
            nd.add_input(ref_);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ScatterUpdate::new().build(ref_, indices, updates, scope)`.
pub fn scatter_update<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ScatterUpdate::new().build(ref_, indices, updates, scope)
}
/// Builder for the `SdcaFprint` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SdcaFprint {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SdcaFprint {
    /// Creates a new `SdcaFprint`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SdcaFprint` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SdcaFprint", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SdcaFprint::new().build(input, scope)`.
pub fn sdca_fprint<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SdcaFprint::new().build(input, scope)
}
/// Builder for the `SdcaOptimizer` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SdcaOptimizer {
    loss_type: ::std::option::Option<::std::string::String>,
    adaptative: ::std::option::Option<bool>,
    num_sparse_features: ::std::option::Option<i64>,
    num_sparse_features_with_values: ::std::option::Option<i64>,
    num_dense_features: ::std::option::Option<i64>,
    l1: ::std::option::Option<f32>,
    l2: ::std::option::Option<f32>,
    num_loss_partitions: ::std::option::Option<i64>,
    num_inner_iterations: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SdcaOptimizer {
    /// Creates a new `SdcaOptimizer`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `loss_type` attribute.
    pub fn loss_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.loss_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adaptative` attribute.
    pub fn adaptative<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adaptative = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sparse_features` attribute.
    pub fn num_sparse_features<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_sparse_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sparse_features_with_values` attribute.
    pub fn num_sparse_features_with_values<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_sparse_features_with_values = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_dense_features` attribute.
    pub fn num_dense_features<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_dense_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `l1` attribute.
    pub fn l1<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.l1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `l2` attribute.
    pub fn l2<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.l2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_loss_partitions` attribute.
    pub fn num_loss_partitions<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_loss_partitions = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_inner_iterations` attribute.
    pub fn num_inner_iterations<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_inner_iterations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SdcaOptimizer` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sparse_example_indices: O0,
        sparse_feature_indices: O1,
        sparse_feature_values: O2,
        dense_features: O3,
        example_weights: O4,
        example_labels: O5,
        sparse_indices: O6,
        sparse_weights: O7,
        dense_weights: O8,
        example_state_data: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sparse_example_indices.into(),
            sparse_feature_indices.into(),
            sparse_feature_values.into(),
            dense_features.into(),
            example_weights.into(),
            example_labels.into(),
            sparse_indices.into(),
            sparse_weights.into(),
            dense_weights.into(),
            example_state_data.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sparse_example_indices: crate::Output,
        sparse_feature_indices: crate::Output,
        sparse_feature_values: crate::Output,
        dense_features: crate::Output,
        example_weights: crate::Output,
        example_labels: crate::Output,
        sparse_indices: crate::Output,
        sparse_weights: crate::Output,
        dense_weights: crate::Output,
        example_state_data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SdcaOptimizer", |nd| {
            nd.add_input(sparse_example_indices);
            nd.add_input(sparse_feature_indices);
            nd.add_input(sparse_feature_values);
            nd.add_input(dense_features);
            nd.add_input(example_weights);
            nd.add_input(example_labels);
            nd.add_input(sparse_indices);
            nd.add_input(sparse_weights);
            nd.add_input(dense_weights);
            nd.add_input(example_state_data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.loss_type {
                nd.set_attr_string("loss_type", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adaptative {
                nd.set_attr_bool("adaptative", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sparse_features {
                nd.set_attr_int("num_sparse_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sparse_features_with_values {
                nd.set_attr_int("num_sparse_features_with_values", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_dense_features {
                nd.set_attr_int("num_dense_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.l1 {
                nd.set_attr_float("l1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.l2 {
                nd.set_attr_float("l2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_loss_partitions {
                nd.set_attr_int("num_loss_partitions", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_inner_iterations {
                nd.set_attr_int("num_inner_iterations", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SdcaOptimizer::new().build(sparse_example_indices, sparse_feature_indices, sparse_feature_values, dense_features, example_weights, example_labels, sparse_indices, sparse_weights, dense_weights, example_state_data, scope)`.
pub fn sdca_optimizer<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    sparse_example_indices: O0,
    sparse_feature_indices: O1,
    sparse_feature_values: O2,
    dense_features: O3,
    example_weights: O4,
    example_labels: O5,
    sparse_indices: O6,
    sparse_weights: O7,
    dense_weights: O8,
    example_state_data: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SdcaOptimizer::new().build(
        sparse_example_indices,
        sparse_feature_indices,
        sparse_feature_values,
        dense_features,
        example_weights,
        example_labels,
        sparse_indices,
        sparse_weights,
        dense_weights,
        example_state_data,
        scope,
    )
}
/// Builder for the `SdcaOptimizerV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SdcaOptimizerV2 {
    loss_type: ::std::option::Option<::std::string::String>,
    adaptive: ::std::option::Option<bool>,
    num_sparse_features: ::std::option::Option<i64>,
    num_sparse_features_with_values: ::std::option::Option<i64>,
    num_dense_features: ::std::option::Option<i64>,
    l1: ::std::option::Option<f32>,
    l2: ::std::option::Option<f32>,
    num_loss_partitions: ::std::option::Option<i64>,
    num_inner_iterations: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SdcaOptimizerV2 {
    /// Creates a new `SdcaOptimizerV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `loss_type` attribute.
    pub fn loss_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.loss_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adaptive` attribute.
    pub fn adaptive<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adaptive = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sparse_features` attribute.
    pub fn num_sparse_features<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_sparse_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sparse_features_with_values` attribute.
    pub fn num_sparse_features_with_values<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_sparse_features_with_values = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_dense_features` attribute.
    pub fn num_dense_features<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_dense_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `l1` attribute.
    pub fn l1<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.l1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `l2` attribute.
    pub fn l2<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.l2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_loss_partitions` attribute.
    pub fn num_loss_partitions<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_loss_partitions = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_inner_iterations` attribute.
    pub fn num_inner_iterations<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_inner_iterations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SdcaOptimizerV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sparse_example_indices: O0,
        sparse_feature_indices: O1,
        sparse_feature_values: O2,
        dense_features: O3,
        example_weights: O4,
        example_labels: O5,
        sparse_indices: O6,
        sparse_weights: O7,
        dense_weights: O8,
        example_state_data: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sparse_example_indices.into(),
            sparse_feature_indices.into(),
            sparse_feature_values.into(),
            dense_features.into(),
            example_weights.into(),
            example_labels.into(),
            sparse_indices.into(),
            sparse_weights.into(),
            dense_weights.into(),
            example_state_data.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sparse_example_indices: crate::Output,
        sparse_feature_indices: crate::Output,
        sparse_feature_values: crate::Output,
        dense_features: crate::Output,
        example_weights: crate::Output,
        example_labels: crate::Output,
        sparse_indices: crate::Output,
        sparse_weights: crate::Output,
        dense_weights: crate::Output,
        example_state_data: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SdcaOptimizerV2", |nd| {
            nd.add_input(sparse_example_indices);
            nd.add_input(sparse_feature_indices);
            nd.add_input(sparse_feature_values);
            nd.add_input(dense_features);
            nd.add_input(example_weights);
            nd.add_input(example_labels);
            nd.add_input(sparse_indices);
            nd.add_input(sparse_weights);
            nd.add_input(dense_weights);
            nd.add_input(example_state_data);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.loss_type {
                nd.set_attr_string("loss_type", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adaptive {
                nd.set_attr_bool("adaptive", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sparse_features {
                nd.set_attr_int("num_sparse_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sparse_features_with_values {
                nd.set_attr_int("num_sparse_features_with_values", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_dense_features {
                nd.set_attr_int("num_dense_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.l1 {
                nd.set_attr_float("l1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.l2 {
                nd.set_attr_float("l2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_loss_partitions {
                nd.set_attr_int("num_loss_partitions", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_inner_iterations {
                nd.set_attr_int("num_inner_iterations", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SdcaOptimizerV2::new().build(sparse_example_indices, sparse_feature_indices, sparse_feature_values, dense_features, example_weights, example_labels, sparse_indices, sparse_weights, dense_weights, example_state_data, scope)`.
pub fn sdca_optimizer_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    sparse_example_indices: O0,
    sparse_feature_indices: O1,
    sparse_feature_values: O2,
    dense_features: O3,
    example_weights: O4,
    example_labels: O5,
    sparse_indices: O6,
    sparse_weights: O7,
    dense_weights: O8,
    example_state_data: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SdcaOptimizerV2::new().build(
        sparse_example_indices,
        sparse_feature_indices,
        sparse_feature_values,
        dense_features,
        example_weights,
        example_labels,
        sparse_indices,
        sparse_weights,
        dense_weights,
        example_state_data,
        scope,
    )
}
/// Builder for the `SdcaShrinkL1` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SdcaShrinkL1 {
    num_features: ::std::option::Option<i64>,
    l1: ::std::option::Option<f32>,
    l2: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SdcaShrinkL1 {
    /// Creates a new `SdcaShrinkL1`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_features` attribute.
    pub fn num_features<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_features = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `l1` attribute.
    pub fn l1<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.l1 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `l2` attribute.
    pub fn l2<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.l2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SdcaShrinkL1` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        weights: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(weights.into(), scope)
    }

    fn build_impl(
        &self,
        weights: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SdcaShrinkL1", |nd| {
            nd.add_input(weights);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_features {
                nd.set_attr_int("num_features", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.l1 {
                nd.set_attr_float("l1", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.l2 {
                nd.set_attr_float("l2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SdcaShrinkL1::new().build(weights, scope)`.
pub fn sdca_shrink_l1<O0: ::std::convert::Into<crate::Output>>(
    weights: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SdcaShrinkL1::new().build(weights, scope)
}
/// Builder for the `SegmentMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentMax {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SegmentMax {
    /// Creates a new `SegmentMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SegmentMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SegmentMax", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SegmentMax::new().build(data, segment_ids, scope)`.
pub fn segment_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SegmentMax::new().build(data, segment_ids, scope)
}
/// Builder for the `SegmentMean` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentMean {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SegmentMean {
    /// Creates a new `SegmentMean`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SegmentMean` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SegmentMean", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SegmentMean::new().build(data, segment_ids, scope)`.
pub fn segment_mean<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SegmentMean::new().build(data, segment_ids, scope)
}
/// Builder for the `SegmentMin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentMin {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SegmentMin {
    /// Creates a new `SegmentMin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SegmentMin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SegmentMin", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SegmentMin::new().build(data, segment_ids, scope)`.
pub fn segment_min<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SegmentMin::new().build(data, segment_ids, scope)
}
/// Builder for the `SegmentProd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentProd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SegmentProd {
    /// Creates a new `SegmentProd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SegmentProd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SegmentProd", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SegmentProd::new().build(data, segment_ids, scope)`.
pub fn segment_prod<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SegmentProd::new().build(data, segment_ids, scope)
}
/// Builder for the `SegmentSum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SegmentSum {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SegmentSum {
    /// Creates a new `SegmentSum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SegmentSum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SegmentSum", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SegmentSum::new().build(data, segment_ids, scope)`.
pub fn segment_sum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SegmentSum::new().build(data, segment_ids, scope)
}
/// Builder for the `Select` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Select {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Select {
    /// Creates a new `Select`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Select` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        condition: O0,
        t: O1,
        e: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(condition.into(), t.into(), e.into(), scope)
    }

    fn build_impl(
        &self,
        condition: crate::Output,
        t: crate::Output,
        e: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Select", |nd| {
            nd.add_input(condition);
            nd.add_input(t);
            nd.add_input(e);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Select::new().build(condition, t, e, scope)`.
pub fn select<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    condition: O0,
    t: O1,
    e: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Select::new().build(condition, t, e, scope)
}
/// Builder for the `SelectV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SelectV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SelectV2 {
    /// Creates a new `SelectV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SelectV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        condition: O0,
        t: O1,
        e: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(condition.into(), t.into(), e.into(), scope)
    }

    fn build_impl(
        &self,
        condition: crate::Output,
        t: crate::Output,
        e: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SelectV2", |nd| {
            nd.add_input(condition);
            nd.add_input(t);
            nd.add_input(e);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SelectV2::new().build(condition, t, e, scope)`.
pub fn select_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    condition: O0,
    t: O1,
    e: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SelectV2::new().build(condition, t, e, scope)
}
/// Builder for the `SelfAdjointEig` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SelfAdjointEig {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SelfAdjointEig {
    /// Creates a new `SelfAdjointEig`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SelfAdjointEig` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SelfAdjointEig", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SelfAdjointEig::new().build(input, scope)`.
pub fn self_adjoint_eig<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SelfAdjointEig::new().build(input, scope)
}
/// Builder for the `SelfAdjointEigV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SelfAdjointEigV2 {
    compute_v: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SelfAdjointEigV2 {
    /// Creates a new `SelfAdjointEigV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `compute_v` attribute.
    pub fn compute_v<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.compute_v = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SelfAdjointEigV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SelfAdjointEigV2", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.compute_v {
                nd.set_attr_bool("compute_v", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SelfAdjointEigV2::new().build(input, scope)`.
pub fn self_adjoint_eig_v2<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SelfAdjointEigV2::new().build(input, scope)
}
/// Builder for the `Selu` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Selu {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Selu {
    /// Creates a new `Selu`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Selu` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        features: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Selu", |nd| {
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Selu::new().build(features, scope)`.
pub fn selu<O0: ::std::convert::Into<crate::Output>>(
    features: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Selu::new().build(features, scope)
}
/// Builder for the `SeluGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SeluGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SeluGrad {
    /// Creates a new `SeluGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SeluGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        outputs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(gradients.into(), outputs.into(), scope)
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        outputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SeluGrad", |nd| {
            nd.add_input(gradients);
            nd.add_input(outputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SeluGrad::new().build(gradients, outputs, scope)`.
pub fn selu_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    outputs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SeluGrad::new().build(gradients, outputs, scope)
}
/// Builder for the `Send` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Send {
    T: ::std::option::Option<crate::DataType>,
    tensor_name: ::std::option::Option<::std::string::String>,
    send_device: ::std::option::Option<::std::string::String>,
    send_device_incarnation: ::std::option::Option<i64>,
    recv_device: ::std::option::Option<::std::string::String>,
    client_terminated: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Send {
    /// Creates a new `Send`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_name` attribute.
    pub fn tensor_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `send_device` attribute.
    pub fn send_device<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.send_device = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `send_device_incarnation` attribute.
    pub fn send_device_incarnation<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.send_device_incarnation = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `recv_device` attribute.
    pub fn recv_device<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.recv_device = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `client_terminated` attribute.
    pub fn client_terminated<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.client_terminated = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Send` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tensor: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Send", |nd| {
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_name {
                nd.set_attr_string("tensor_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.send_device {
                nd.set_attr_string("send_device", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.send_device_incarnation {
                nd.set_attr_int("send_device_incarnation", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.recv_device {
                nd.set_attr_string("recv_device", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.client_terminated {
                nd.set_attr_bool("client_terminated", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Send::new().build(tensor, scope)`.
pub fn send<O0: ::std::convert::Into<crate::Output>>(
    tensor: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Send::new().build(tensor, scope)
}
/// Builder for the `SendTPUEmbeddingGradients` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SendTPUEmbeddingGradients {
    N: ::std::option::Option<i64>,
    NN: ::std::option::Option<i64>,
    config: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SendTPUEmbeddingGradients {
    /// Creates a new `SendTPUEmbeddingGradients`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `NN` attribute.
    pub fn NN<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.NN = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SendTPUEmbeddingGradients` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        learning_rates: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), learning_rates.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        learning_rates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SendTPUEmbeddingGradients", |nd| {
            nd.add_input(inputs);
            nd.add_input(learning_rates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.NN {
                nd.set_attr_int("NN", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SendTPUEmbeddingGradients::new().build(inputs, learning_rates, scope)`.
pub fn send_tpuembedding_gradients<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    learning_rates: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SendTPUEmbeddingGradients::new().build(inputs, learning_rates, scope)
}
/// Builder for the `SerializeIterator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SerializeIterator {
    external_state_policy: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SerializeIterator {
    /// Creates a new `SerializeIterator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `external_state_policy` attribute.
    pub fn external_state_policy<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.external_state_policy = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SerializeIterator` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource_handle.into(), scope)
    }

    fn build_impl(
        &self,
        resource_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SerializeIterator", |nd| {
            nd.add_input(resource_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.external_state_policy {
                nd.set_attr_int("external_state_policy", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SerializeIterator::new().build(resource_handle, scope)`.
pub fn serialize_iterator<O0: ::std::convert::Into<crate::Output>>(
    resource_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SerializeIterator::new().build(resource_handle, scope)
}
/// Builder for the `SerializeManySparse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SerializeManySparse {
    T: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SerializeManySparse {
    /// Creates a new `SerializeManySparse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SerializeManySparse` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sparse_indices: O0,
        sparse_values: O1,
        sparse_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sparse_indices.into(),
            sparse_values.into(),
            sparse_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sparse_indices: crate::Output,
        sparse_values: crate::Output,
        sparse_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SerializeManySparse", |nd| {
            nd.add_input(sparse_indices);
            nd.add_input(sparse_values);
            nd.add_input(sparse_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SerializeManySparse::new().build(sparse_indices, sparse_values, sparse_shape, scope)`.
pub fn serialize_many_sparse<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    sparse_indices: O0,
    sparse_values: O1,
    sparse_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SerializeManySparse::new().build(sparse_indices, sparse_values, sparse_shape, scope)
}
/// Builder for the `SerializeSparse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SerializeSparse {
    T: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SerializeSparse {
    /// Creates a new `SerializeSparse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SerializeSparse` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sparse_indices: O0,
        sparse_values: O1,
        sparse_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sparse_indices.into(),
            sparse_values.into(),
            sparse_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sparse_indices: crate::Output,
        sparse_values: crate::Output,
        sparse_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SerializeSparse", |nd| {
            nd.add_input(sparse_indices);
            nd.add_input(sparse_values);
            nd.add_input(sparse_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SerializeSparse::new().build(sparse_indices, sparse_values, sparse_shape, scope)`.
pub fn serialize_sparse<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    sparse_indices: O0,
    sparse_values: O1,
    sparse_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SerializeSparse::new().build(sparse_indices, sparse_values, sparse_shape, scope)
}
/// Builder for the `SerializeTensor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SerializeTensor {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SerializeTensor {
    /// Creates a new `SerializeTensor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SerializeTensor` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tensor: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SerializeTensor", |nd| {
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SerializeTensor::new().build(tensor, scope)`.
pub fn serialize_tensor<O0: ::std::convert::Into<crate::Output>>(
    tensor: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SerializeTensor::new().build(tensor, scope)
}
/// Builder for the `SetSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SetSize {
    validate_indices: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SetSize {
    /// Creates a new `SetSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `validate_indices` attribute.
    pub fn validate_indices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.validate_indices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SetSize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        set_indices: O0,
        set_values: O1,
        set_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            set_indices.into(),
            set_values.into(),
            set_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        set_indices: crate::Output,
        set_values: crate::Output,
        set_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SetSize", |nd| {
            nd.add_input(set_indices);
            nd.add_input(set_values);
            nd.add_input(set_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.validate_indices {
                nd.set_attr_bool("validate_indices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SetSize::new().build(set_indices, set_values, set_shape, scope)`.
pub fn set_size<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    set_indices: O0,
    set_values: O1,
    set_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SetSize::new().build(set_indices, set_values, set_shape, scope)
}
/// Builder for the `SetStatsAggregatorDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SetStatsAggregatorDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SetStatsAggregatorDataset {
    /// Creates a new `SetStatsAggregatorDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SetStatsAggregatorDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        stats_aggregator: O1,
        tag: O2,
        counter_prefix: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            stats_aggregator.into(),
            tag.into(),
            counter_prefix.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        stats_aggregator: crate::Output,
        tag: crate::Output,
        counter_prefix: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SetStatsAggregatorDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(stats_aggregator);
            nd.add_input(tag);
            nd.add_input(counter_prefix);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SetStatsAggregatorDataset::new().build(input_dataset, stats_aggregator, tag, counter_prefix, scope)`.
pub fn set_stats_aggregator_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    stats_aggregator: O1,
    tag: O2,
    counter_prefix: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SetStatsAggregatorDataset::new().build(
        input_dataset,
        stats_aggregator,
        tag,
        counter_prefix,
        scope,
    )
}
/// Builder for the `Shape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Shape {
    T: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Shape {
    /// Creates a new `Shape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Shape` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Shape", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Shape::new().build(input, scope)`.
pub fn shape<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Shape::new().build(input, scope)
}
/// Builder for the `ShapeN` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShapeN {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShapeN {
    /// Creates a new `ShapeN`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShapeN` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShapeN", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShapeN::new().build(input, scope)`.
pub fn shape_n<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShapeN::new().build(input, scope)
}
/// Builder for the `ShardDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShardDataset {
    require_non_empty: ::std::option::Option<bool>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShardDataset {
    /// Creates a new `ShardDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `require_non_empty` attribute.
    pub fn require_non_empty<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.require_non_empty = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShardDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        num_shards: O1,
        index: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), num_shards.into(), index.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        num_shards: crate::Output,
        index: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShardDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(num_shards);
            nd.add_input(index);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.require_non_empty {
                nd.set_attr_bool("require_non_empty", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShardDataset::new().build(input_dataset, num_shards, index, scope)`.
pub fn shard_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    num_shards: O1,
    index: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShardDataset::new().build(input_dataset, num_shards, index, scope)
}
/// Builder for the `ShardedFilename` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShardedFilename {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShardedFilename {
    /// Creates a new `ShardedFilename`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShardedFilename` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        basename: O0,
        shard: O1,
        num_shards: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(basename.into(), shard.into(), num_shards.into(), scope)
    }

    fn build_impl(
        &self,
        basename: crate::Output,
        shard: crate::Output,
        num_shards: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShardedFilename", |nd| {
            nd.add_input(basename);
            nd.add_input(shard);
            nd.add_input(num_shards);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShardedFilename::new().build(basename, shard, num_shards, scope)`.
pub fn sharded_filename<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    basename: O0,
    shard: O1,
    num_shards: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShardedFilename::new().build(basename, shard, num_shards, scope)
}
/// Builder for the `ShardedFilespec` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShardedFilespec {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShardedFilespec {
    /// Creates a new `ShardedFilespec`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShardedFilespec` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        basename: O0,
        num_shards: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(basename.into(), num_shards.into(), scope)
    }

    fn build_impl(
        &self,
        basename: crate::Output,
        num_shards: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShardedFilespec", |nd| {
            nd.add_input(basename);
            nd.add_input(num_shards);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShardedFilespec::new().build(basename, num_shards, scope)`.
pub fn sharded_filespec<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    basename: O0,
    num_shards: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShardedFilespec::new().build(basename, num_shards, scope)
}
/// Builder for the `ShuffleAndRepeatDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleAndRepeatDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    reshuffle_each_iteration: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShuffleAndRepeatDataset {
    /// Creates a new `ShuffleAndRepeatDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reshuffle_each_iteration` attribute.
    pub fn reshuffle_each_iteration<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reshuffle_each_iteration = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShuffleAndRepeatDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        buffer_size: O1,
        seed: O2,
        seed2: O3,
        count: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            buffer_size.into(),
            seed.into(),
            seed2.into(),
            count.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        buffer_size: crate::Output,
        seed: crate::Output,
        seed2: crate::Output,
        count: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShuffleAndRepeatDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(buffer_size);
            nd.add_input(seed);
            nd.add_input(seed2);
            nd.add_input(count);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reshuffle_each_iteration {
                nd.set_attr_bool("reshuffle_each_iteration", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShuffleAndRepeatDataset::new().build(input_dataset, buffer_size, seed, seed2, count, scope)`.
pub fn shuffle_and_repeat_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    buffer_size: O1,
    seed: O2,
    seed2: O3,
    count: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShuffleAndRepeatDataset::new().build(input_dataset, buffer_size, seed, seed2, count, scope)
}
/// Builder for the `ShuffleAndRepeatDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleAndRepeatDatasetV2 {
    reshuffle_each_iteration: ::std::option::Option<bool>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShuffleAndRepeatDatasetV2 {
    /// Creates a new `ShuffleAndRepeatDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `reshuffle_each_iteration` attribute.
    pub fn reshuffle_each_iteration<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reshuffle_each_iteration = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShuffleAndRepeatDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        buffer_size: O1,
        seed: O2,
        seed2: O3,
        count: O4,
        seed_generator: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            buffer_size.into(),
            seed.into(),
            seed2.into(),
            count.into(),
            seed_generator.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        buffer_size: crate::Output,
        seed: crate::Output,
        seed2: crate::Output,
        count: crate::Output,
        seed_generator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShuffleAndRepeatDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(buffer_size);
            nd.add_input(seed);
            nd.add_input(seed2);
            nd.add_input(count);
            nd.add_input(seed_generator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.reshuffle_each_iteration {
                nd.set_attr_bool("reshuffle_each_iteration", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShuffleAndRepeatDatasetV2::new().build(input_dataset, buffer_size, seed, seed2, count, seed_generator, scope)`.
pub fn shuffle_and_repeat_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    buffer_size: O1,
    seed: O2,
    seed2: O3,
    count: O4,
    seed_generator: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShuffleAndRepeatDatasetV2::new().build(
        input_dataset,
        buffer_size,
        seed,
        seed2,
        count,
        seed_generator,
        scope,
    )
}
/// Builder for the `ShuffleDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleDataset {
    reshuffle_each_iteration: ::std::option::Option<bool>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShuffleDataset {
    /// Creates a new `ShuffleDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `reshuffle_each_iteration` attribute.
    pub fn reshuffle_each_iteration<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reshuffle_each_iteration = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShuffleDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        buffer_size: O1,
        seed: O2,
        seed2: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            buffer_size.into(),
            seed.into(),
            seed2.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        buffer_size: crate::Output,
        seed: crate::Output,
        seed2: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShuffleDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(buffer_size);
            nd.add_input(seed);
            nd.add_input(seed2);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.reshuffle_each_iteration {
                nd.set_attr_bool("reshuffle_each_iteration", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShuffleDataset::new().build(input_dataset, buffer_size, seed, seed2, scope)`.
pub fn shuffle_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    buffer_size: O1,
    seed: O2,
    seed2: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShuffleDataset::new().build(input_dataset, buffer_size, seed, seed2, scope)
}
/// Builder for the `ShuffleDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleDatasetV2 {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShuffleDatasetV2 {
    /// Creates a new `ShuffleDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShuffleDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        buffer_size: O1,
        seed_generator: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            buffer_size.into(),
            seed_generator.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        buffer_size: crate::Output,
        seed_generator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShuffleDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(buffer_size);
            nd.add_input(seed_generator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShuffleDatasetV2::new().build(input_dataset, buffer_size, seed_generator, scope)`.
pub fn shuffle_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    buffer_size: O1,
    seed_generator: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShuffleDatasetV2::new().build(input_dataset, buffer_size, seed_generator, scope)
}
/// Builder for the `ShuffleDatasetV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShuffleDatasetV3 {
    reshuffle_each_iteration: ::std::option::Option<bool>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShuffleDatasetV3 {
    /// Creates a new `ShuffleDatasetV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `reshuffle_each_iteration` attribute.
    pub fn reshuffle_each_iteration<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reshuffle_each_iteration = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShuffleDatasetV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        buffer_size: O1,
        seed: O2,
        seed2: O3,
        seed_generator: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            buffer_size.into(),
            seed.into(),
            seed2.into(),
            seed_generator.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        buffer_size: crate::Output,
        seed: crate::Output,
        seed2: crate::Output,
        seed_generator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ShuffleDatasetV3", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(buffer_size);
            nd.add_input(seed);
            nd.add_input(seed2);
            nd.add_input(seed_generator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.reshuffle_each_iteration {
                nd.set_attr_bool("reshuffle_each_iteration", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShuffleDatasetV3::new().build(input_dataset, buffer_size, seed, seed2, seed_generator, scope)`.
pub fn shuffle_dataset_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    buffer_size: O1,
    seed: O2,
    seed2: O3,
    seed_generator: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ShuffleDatasetV3::new().build(
        input_dataset,
        buffer_size,
        seed,
        seed2,
        seed_generator,
        scope,
    )
}
/// Builder for the `ShutdownDistributedTPU` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ShutdownDistributedTPU {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ShutdownDistributedTPU {
    /// Creates a new `ShutdownDistributedTPU`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ShutdownDistributedTPU` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ShutdownDistributedTPU", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ShutdownDistributedTPU::new().build(scope)`.
pub fn shutdown_distributed_tpu(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    ShutdownDistributedTPU::new().build(scope)
}
/// Builder for the `Sigmoid` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sigmoid {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Sigmoid {
    /// Creates a new `Sigmoid`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Sigmoid` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Sigmoid", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Sigmoid::new().build(x, scope)`.
pub fn sigmoid<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Sigmoid::new().build(x, scope)
}
/// Builder for the `SigmoidGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SigmoidGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SigmoidGrad {
    /// Creates a new `SigmoidGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SigmoidGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y: O0,
        dy: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(y.into(), dy.into(), scope)
    }

    fn build_impl(
        &self,
        y: crate::Output,
        dy: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SigmoidGrad", |nd| {
            nd.add_input(y);
            nd.add_input(dy);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SigmoidGrad::new().build(y, dy, scope)`.
pub fn sigmoid_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    y: O0,
    dy: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SigmoidGrad::new().build(y, dy, scope)
}
/// Builder for the `Sign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sign {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Sign {
    /// Creates a new `Sign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Sign` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Sign", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Sign::new().build(x, scope)`.
pub fn sign<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Sign::new().build(x, scope)
}
/// Builder for the `Sin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sin {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Sin {
    /// Creates a new `Sin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Sin` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Sin", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Sin::new().build(x, scope)`.
pub fn sin<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Sin::new().build(x, scope)
}
/// Builder for the `Sinh` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sinh {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Sinh {
    /// Creates a new `Sinh`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Sinh` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Sinh", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Sinh::new().build(x, scope)`.
pub fn sinh<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Sinh::new().build(x, scope)
}
/// Builder for the `Size` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Size {
    T: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Size {
    /// Creates a new `Size`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Size` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Size", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Size::new().build(input, scope)`.
pub fn size<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Size::new().build(input, scope)
}
/// Builder for the `SkipDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SkipDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SkipDataset {
    /// Creates a new `SkipDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SkipDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        count: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), count.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        count: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SkipDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(count);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SkipDataset::new().build(input_dataset, count, scope)`.
pub fn skip_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    count: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SkipDataset::new().build(input_dataset, count, scope)
}
/// Builder for the `Skipgram` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Skipgram {
    filename: ::std::option::Option<::std::string::String>,
    batch_size: ::std::option::Option<i64>,
    window_size: ::std::option::Option<i64>,
    min_count: ::std::option::Option<i64>,
    subsample: ::std::option::Option<f32>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Skipgram {
    /// Creates a new `Skipgram`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `filename` attribute.
    pub fn filename<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.filename = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `batch_size` attribute.
    pub fn batch_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.batch_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `window_size` attribute.
    pub fn window_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.window_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `min_count` attribute.
    pub fn min_count<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.min_count = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `subsample` attribute.
    pub fn subsample<ArgType: ::std::convert::Into<f32>>(mut self, value: ArgType) -> Self {
        self.subsample = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Skipgram` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Skipgram", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.filename {
                nd.set_attr_string("filename", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.batch_size {
                nd.set_attr_int("batch_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.window_size {
                nd.set_attr_int("window_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.min_count {
                nd.set_attr_int("min_count", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.subsample {
                nd.set_attr_float("subsample", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Skipgram::new().build(scope)`.
pub fn skipgram(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Skipgram::new().build(scope)
}
/// Builder for the `SleepDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SleepDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SleepDataset {
    /// Creates a new `SleepDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SleepDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        sleep_microseconds: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), sleep_microseconds.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        sleep_microseconds: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SleepDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(sleep_microseconds);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SleepDataset::new().build(input_dataset, sleep_microseconds, scope)`.
pub fn sleep_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    sleep_microseconds: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SleepDataset::new().build(input_dataset, sleep_microseconds, scope)
}
/// Builder for the `Slice` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Slice {
    T: ::std::option::Option<crate::DataType>,
    Index: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Slice {
    /// Creates a new `Slice`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Index` attribute.
    pub fn Index<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Index = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Slice` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        begin: O1,
        size: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), begin.into(), size.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        begin: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Slice", |nd| {
            nd.add_input(input);
            nd.add_input(begin);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Index {
                nd.set_attr_type("Index", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Slice::new().build(input, begin, size, scope)`.
pub fn slice<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    begin: O1,
    size: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Slice::new().build(input, begin, size, scope)
}
/// Builder for the `SlidingWindowDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SlidingWindowDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SlidingWindowDataset {
    /// Creates a new `SlidingWindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SlidingWindowDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        window_size: O1,
        window_shift: O2,
        window_stride: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            window_size.into(),
            window_shift.into(),
            window_stride.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        window_size: crate::Output,
        window_shift: crate::Output,
        window_stride: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SlidingWindowDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(window_size);
            nd.add_input(window_shift);
            nd.add_input(window_stride);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SlidingWindowDataset::new().build(input_dataset, window_size, window_shift, window_stride, scope)`.
pub fn sliding_window_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    window_size: O1,
    window_shift: O2,
    window_stride: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SlidingWindowDataset::new().build(
        input_dataset,
        window_size,
        window_shift,
        window_stride,
        scope,
    )
}
/// Builder for the `Snapshot` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Snapshot {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Snapshot {
    /// Creates a new `Snapshot`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Snapshot` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Snapshot", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Snapshot::new().build(input, scope)`.
pub fn snapshot<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Snapshot::new().build(input, scope)
}
/// Builder for the `SnapshotDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SnapshotDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    compression: ::std::option::Option<::std::string::String>,
    reader_path_prefix: ::std::option::Option<::std::string::String>,
    writer_path_prefix: ::std::option::Option<::std::string::String>,
    shard_size_bytes: ::std::option::Option<i64>,
    pending_snapshot_expiry_seconds: ::std::option::Option<i64>,
    num_reader_threads: ::std::option::Option<i64>,
    reader_buffer_size: ::std::option::Option<i64>,
    num_writer_threads: ::std::option::Option<i64>,
    writer_buffer_size: ::std::option::Option<i64>,
    shuffle_on_read: ::std::option::Option<bool>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    mode: ::std::option::Option<::std::string::String>,
    snapshot_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SnapshotDataset {
    /// Creates a new `SnapshotDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `compression` attribute.
    pub fn compression<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compression = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reader_path_prefix` attribute.
    pub fn reader_path_prefix<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reader_path_prefix = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `writer_path_prefix` attribute.
    pub fn writer_path_prefix<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.writer_path_prefix = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_size_bytes` attribute.
    pub fn shard_size_bytes<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shard_size_bytes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `pending_snapshot_expiry_seconds` attribute.
    pub fn pending_snapshot_expiry_seconds<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.pending_snapshot_expiry_seconds = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_reader_threads` attribute.
    pub fn num_reader_threads<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_reader_threads = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reader_buffer_size` attribute.
    pub fn reader_buffer_size<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reader_buffer_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_writer_threads` attribute.
    pub fn num_writer_threads<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_writer_threads = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `writer_buffer_size` attribute.
    pub fn writer_buffer_size<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.writer_buffer_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shuffle_on_read` attribute.
    pub fn shuffle_on_read<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.shuffle_on_read = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `mode` attribute.
    pub fn mode<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.mode = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `snapshot_name` attribute.
    pub fn snapshot_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.snapshot_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SnapshotDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        path: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), path.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        path: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SnapshotDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(path);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.compression {
                nd.set_attr_string("compression", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reader_path_prefix {
                nd.set_attr_string("reader_path_prefix", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.writer_path_prefix {
                nd.set_attr_string("writer_path_prefix", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_size_bytes {
                nd.set_attr_int("shard_size_bytes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.pending_snapshot_expiry_seconds {
                nd.set_attr_int("pending_snapshot_expiry_seconds", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_reader_threads {
                nd.set_attr_int("num_reader_threads", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reader_buffer_size {
                nd.set_attr_int("reader_buffer_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_writer_threads {
                nd.set_attr_int("num_writer_threads", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.writer_buffer_size {
                nd.set_attr_int("writer_buffer_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shuffle_on_read {
                nd.set_attr_bool("shuffle_on_read", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.mode {
                nd.set_attr_string("mode", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.snapshot_name {
                nd.set_attr_string("snapshot_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SnapshotDataset::new().build(input_dataset, path, scope)`.
pub fn snapshot_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    path: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SnapshotDataset::new().build(input_dataset, path, scope)
}
/// Builder for the `SnapshotDatasetV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SnapshotDatasetV2 {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    compression: ::std::option::Option<::std::string::String>,
    reader_func: ::std::option::Option<::std::string::String>,
    shard_func: ::std::option::Option<::std::string::String>,
    Treader_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tshard_func_args: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SnapshotDatasetV2 {
    /// Creates a new `SnapshotDatasetV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `compression` attribute.
    pub fn compression<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compression = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reader_func` attribute.
    pub fn reader_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reader_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shard_func` attribute.
    pub fn shard_func<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shard_func = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Treader_func_args` attribute.
    pub fn Treader_func_args<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Treader_func_args = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tshard_func_args` attribute.
    pub fn Tshard_func_args<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tshard_func_args = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SnapshotDatasetV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        path: O1,
        reader_func_other_args: O2,
        shard_func_other_args: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            path.into(),
            reader_func_other_args.into(),
            shard_func_other_args.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        path: crate::Output,
        reader_func_other_args: crate::Output,
        shard_func_other_args: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SnapshotDatasetV2", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(path);
            nd.add_input(reader_func_other_args);
            nd.add_input(shard_func_other_args);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.compression {
                nd.set_attr_string("compression", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reader_func {
                nd.set_attr_string("reader_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shard_func {
                nd.set_attr_string("shard_func", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Treader_func_args {
                nd.set_attr_type_list("Treader_func_args", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tshard_func_args {
                nd.set_attr_type_list("Tshard_func_args", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SnapshotDatasetV2::new().build(input_dataset, path, reader_func_other_args, shard_func_other_args, scope)`.
pub fn snapshot_dataset_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    path: O1,
    reader_func_other_args: O2,
    shard_func_other_args: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SnapshotDatasetV2::new().build(
        input_dataset,
        path,
        reader_func_other_args,
        shard_func_other_args,
        scope,
    )
}
/// Builder for the `SobolSample` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SobolSample {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SobolSample {
    /// Creates a new `SobolSample`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SobolSample` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        dim: O0,
        num_results: O1,
        skip: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(dim.into(), num_results.into(), skip.into(), scope)
    }

    fn build_impl(
        &self,
        dim: crate::Output,
        num_results: crate::Output,
        skip: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SobolSample", |nd| {
            nd.add_input(dim);
            nd.add_input(num_results);
            nd.add_input(skip);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SobolSample::new().build(dim, num_results, skip, scope)`.
pub fn sobol_sample<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    dim: O0,
    num_results: O1,
    skip: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SobolSample::new().build(dim, num_results, skip, scope)
}
/// Builder for the `Softmax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Softmax {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Softmax {
    /// Creates a new `Softmax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Softmax` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        logits: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(logits.into(), scope)
    }

    fn build_impl(
        &self,
        logits: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Softmax", |nd| {
            nd.add_input(logits);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Softmax::new().build(logits, scope)`.
pub fn softmax<O0: ::std::convert::Into<crate::Output>>(
    logits: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Softmax::new().build(logits, scope)
}
/// Builder for the `SoftmaxCrossEntropyWithLogits` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SoftmaxCrossEntropyWithLogits {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SoftmaxCrossEntropyWithLogits {
    /// Creates a new `SoftmaxCrossEntropyWithLogits`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SoftmaxCrossEntropyWithLogits` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        features: O0,
        labels: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), labels.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        labels: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SoftmaxCrossEntropyWithLogits", |nd| {
            nd.add_input(features);
            nd.add_input(labels);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SoftmaxCrossEntropyWithLogits::new().build(features, labels, scope)`.
pub fn softmax_cross_entropy_with_logits<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    features: O0,
    labels: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SoftmaxCrossEntropyWithLogits::new().build(features, labels, scope)
}
/// Builder for the `Softplus` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Softplus {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Softplus {
    /// Creates a new `Softplus`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Softplus` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        features: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Softplus", |nd| {
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Softplus::new().build(features, scope)`.
pub fn softplus<O0: ::std::convert::Into<crate::Output>>(
    features: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Softplus::new().build(features, scope)
}
/// Builder for the `SoftplusGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SoftplusGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SoftplusGrad {
    /// Creates a new `SoftplusGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SoftplusGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        features: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(gradients.into(), features.into(), scope)
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SoftplusGrad", |nd| {
            nd.add_input(gradients);
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SoftplusGrad::new().build(gradients, features, scope)`.
pub fn softplus_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    features: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SoftplusGrad::new().build(gradients, features, scope)
}
/// Builder for the `Softsign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Softsign {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Softsign {
    /// Creates a new `Softsign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Softsign` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        features: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Softsign", |nd| {
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Softsign::new().build(features, scope)`.
pub fn softsign<O0: ::std::convert::Into<crate::Output>>(
    features: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Softsign::new().build(features, scope)
}
/// Builder for the `SoftsignGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SoftsignGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SoftsignGrad {
    /// Creates a new `SoftsignGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SoftsignGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        gradients: O0,
        features: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(gradients.into(), features.into(), scope)
    }

    fn build_impl(
        &self,
        gradients: crate::Output,
        features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SoftsignGrad", |nd| {
            nd.add_input(gradients);
            nd.add_input(features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SoftsignGrad::new().build(gradients, features, scope)`.
pub fn softsign_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    gradients: O0,
    features: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SoftsignGrad::new().build(gradients, features, scope)
}
/// Builder for the `SpaceToBatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SpaceToBatch {
    T: ::std::option::Option<crate::DataType>,
    Tpaddings: ::std::option::Option<crate::DataType>,
    block_size: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SpaceToBatch {
    /// Creates a new `SpaceToBatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tpaddings` attribute.
    pub fn Tpaddings<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tpaddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `block_size` attribute.
    pub fn block_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.block_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SpaceToBatch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        paddings: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), paddings.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        paddings: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SpaceToBatch", |nd| {
            nd.add_input(input);
            nd.add_input(paddings);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tpaddings {
                nd.set_attr_type("Tpaddings", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.block_size {
                nd.set_attr_int("block_size", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SpaceToBatch::new().build(input, paddings, scope)`.
pub fn space_to_batch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    paddings: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SpaceToBatch::new().build(input, paddings, scope)
}
/// Builder for the `SpaceToBatchND` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SpaceToBatchND {
    T: ::std::option::Option<crate::DataType>,
    Tblock_shape: ::std::option::Option<crate::DataType>,
    Tpaddings: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SpaceToBatchND {
    /// Creates a new `SpaceToBatchND`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tblock_shape` attribute.
    pub fn Tblock_shape<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tblock_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tpaddings` attribute.
    pub fn Tpaddings<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tpaddings = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SpaceToBatchND` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        block_shape: O1,
        paddings: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), block_shape.into(), paddings.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        block_shape: crate::Output,
        paddings: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SpaceToBatchND", |nd| {
            nd.add_input(input);
            nd.add_input(block_shape);
            nd.add_input(paddings);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tblock_shape {
                nd.set_attr_type("Tblock_shape", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tpaddings {
                nd.set_attr_type("Tpaddings", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SpaceToBatchND::new().build(input, block_shape, paddings, scope)`.
pub fn space_to_batch_nd<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    block_shape: O1,
    paddings: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SpaceToBatchND::new().build(input, block_shape, paddings, scope)
}
/// Builder for the `SpaceToDepth` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SpaceToDepth {
    T: ::std::option::Option<crate::DataType>,
    block_size: ::std::option::Option<i64>,
    data_format: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SpaceToDepth {
    /// Creates a new `SpaceToDepth`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `block_size` attribute.
    pub fn block_size<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.block_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `data_format` attribute.
    pub fn data_format<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.data_format = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SpaceToDepth` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SpaceToDepth", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.block_size {
                nd.set_attr_int("block_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.data_format {
                nd.set_attr_string("data_format", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SpaceToDepth::new().build(input, scope)`.
pub fn space_to_depth<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SpaceToDepth::new().build(input, scope)
}
/// Builder for the `SparseAccumulatorApplyGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseAccumulatorApplyGradient {
    dtype: ::std::option::Option<crate::DataType>,
    has_known_shape: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseAccumulatorApplyGradient {
    /// Creates a new `SparseAccumulatorApplyGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `has_known_shape` attribute.
    pub fn has_known_shape<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.has_known_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseAccumulatorApplyGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        local_step: O1,
        gradient_indices: O2,
        gradient_values: O3,
        gradient_shape: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            local_step.into(),
            gradient_indices.into(),
            gradient_values.into(),
            gradient_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        local_step: crate::Output,
        gradient_indices: crate::Output,
        gradient_values: crate::Output,
        gradient_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseAccumulatorApplyGradient", |nd| {
            nd.add_input(handle);
            nd.add_input(local_step);
            nd.add_input(gradient_indices);
            nd.add_input(gradient_values);
            nd.add_input(gradient_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.has_known_shape {
                nd.set_attr_bool("has_known_shape", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseAccumulatorApplyGradient::new().build(handle, local_step, gradient_indices, gradient_values, gradient_shape, scope)`.
pub fn sparse_accumulator_apply_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    local_step: O1,
    gradient_indices: O2,
    gradient_values: O3,
    gradient_shape: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseAccumulatorApplyGradient::new().build(
        handle,
        local_step,
        gradient_indices,
        gradient_values,
        gradient_shape,
        scope,
    )
}
/// Builder for the `SparseAccumulatorTakeGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseAccumulatorTakeGradient {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseAccumulatorTakeGradient {
    /// Creates a new `SparseAccumulatorTakeGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseAccumulatorTakeGradient` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        num_required: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), num_required.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        num_required: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseAccumulatorTakeGradient", |nd| {
            nd.add_input(handle);
            nd.add_input(num_required);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseAccumulatorTakeGradient::new().build(handle, num_required, scope)`.
pub fn sparse_accumulator_take_gradient<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    num_required: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseAccumulatorTakeGradient::new().build(handle, num_required, scope)
}
/// Builder for the `SparseAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseAdd {
    T: ::std::option::Option<crate::DataType>,
    Treal: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseAdd {
    /// Creates a new `SparseAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Treal` attribute.
    pub fn Treal<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Treal = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a_indices: O0,
        a_values: O1,
        a_shape: O2,
        b_indices: O3,
        b_values: O4,
        b_shape: O5,
        thresh: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a_indices.into(),
            a_values.into(),
            a_shape.into(),
            b_indices.into(),
            b_values.into(),
            b_shape.into(),
            thresh.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a_indices: crate::Output,
        a_values: crate::Output,
        a_shape: crate::Output,
        b_indices: crate::Output,
        b_values: crate::Output,
        b_shape: crate::Output,
        thresh: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseAdd", |nd| {
            nd.add_input(a_indices);
            nd.add_input(a_values);
            nd.add_input(a_shape);
            nd.add_input(b_indices);
            nd.add_input(b_values);
            nd.add_input(b_shape);
            nd.add_input(thresh);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Treal {
                nd.set_attr_type("Treal", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseAdd::new().build(a_indices, a_values, a_shape, b_indices, b_values, b_shape, thresh, scope)`.
pub fn sparse_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    a_indices: O0,
    a_values: O1,
    a_shape: O2,
    b_indices: O3,
    b_values: O4,
    b_shape: O5,
    thresh: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseAdd::new().build(
        a_indices, a_values, a_shape, b_indices, b_values, b_shape, thresh, scope,
    )
}
/// Builder for the `SparseAddGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseAddGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseAddGrad {
    /// Creates a new `SparseAddGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseAddGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        backprop_val_grad: O0,
        a_indices: O1,
        b_indices: O2,
        sum_indices: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            backprop_val_grad.into(),
            a_indices.into(),
            b_indices.into(),
            sum_indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        backprop_val_grad: crate::Output,
        a_indices: crate::Output,
        b_indices: crate::Output,
        sum_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseAddGrad", |nd| {
            nd.add_input(backprop_val_grad);
            nd.add_input(a_indices);
            nd.add_input(b_indices);
            nd.add_input(sum_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseAddGrad::new().build(backprop_val_grad, a_indices, b_indices, sum_indices, scope)`.
pub fn sparse_add_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    backprop_val_grad: O0,
    a_indices: O1,
    b_indices: O2,
    sum_indices: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseAddGrad::new().build(backprop_val_grad, a_indices, b_indices, sum_indices, scope)
}
/// Builder for the `SparseApplyAdadelta` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyAdadelta {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyAdadelta {
    /// Creates a new `SparseApplyAdadelta`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyAdadelta` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        accum_update: O2,
        lr: O3,
        rho: O4,
        epsilon: O5,
        grad: O6,
        indices: O7,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            accum_update.into(),
            lr.into(),
            rho.into(),
            epsilon.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        accum_update: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyAdadelta", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(accum_update);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(epsilon);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyAdadelta::new().build(var, accum, accum_update, lr, rho, epsilon, grad, indices, scope)`.
pub fn sparse_apply_adadelta<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    accum_update: O2,
    lr: O3,
    rho: O4,
    epsilon: O5,
    grad: O6,
    indices: O7,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyAdadelta::new().build(
        var,
        accum,
        accum_update,
        lr,
        rho,
        epsilon,
        grad,
        indices,
        scope,
    )
}
/// Builder for the `SparseApplyAdagrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyAdagrad {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    update_slots: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyAdagrad {
    /// Creates a new `SparseApplyAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `update_slots` attribute.
    pub fn update_slots<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.update_slots = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyAdagrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        indices: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyAdagrad", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.update_slots {
                nd.set_attr_bool("update_slots", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyAdagrad::new().build(var, accum, lr, grad, indices, scope)`.
pub fn sparse_apply_adagrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    indices: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyAdagrad::new().build(var, accum, lr, grad, indices, scope)
}
/// Builder for the `SparseApplyAdagradDA` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyAdagradDA {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyAdagradDA {
    /// Creates a new `SparseApplyAdagradDA`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyAdagradDA` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        gradient_accumulator: O1,
        gradient_squared_accumulator: O2,
        grad: O3,
        indices: O4,
        lr: O5,
        l1: O6,
        l2: O7,
        global_step: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            gradient_accumulator.into(),
            gradient_squared_accumulator.into(),
            grad.into(),
            indices.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            global_step.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        gradient_accumulator: crate::Output,
        gradient_squared_accumulator: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        global_step: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyAdagradDA", |nd| {
            nd.add_input(var);
            nd.add_input(gradient_accumulator);
            nd.add_input(gradient_squared_accumulator);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(global_step);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyAdagradDA::new().build(var, gradient_accumulator, gradient_squared_accumulator, grad, indices, lr, l1, l2, global_step, scope)`.
pub fn sparse_apply_adagrad_da<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    gradient_accumulator: O1,
    gradient_squared_accumulator: O2,
    grad: O3,
    indices: O4,
    lr: O5,
    l1: O6,
    l2: O7,
    global_step: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyAdagradDA::new().build(
        var,
        gradient_accumulator,
        gradient_squared_accumulator,
        grad,
        indices,
        lr,
        l1,
        l2,
        global_step,
        scope,
    )
}
/// Builder for the `SparseApplyAdagradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyAdagradV2 {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    update_slots: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyAdagradV2 {
    /// Creates a new `SparseApplyAdagradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `update_slots` attribute.
    pub fn update_slots<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.update_slots = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyAdagradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        epsilon: O3,
        grad: O4,
        indices: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            epsilon.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyAdagradV2", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(epsilon);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.update_slots {
                nd.set_attr_bool("update_slots", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyAdagradV2::new().build(var, accum, lr, epsilon, grad, indices, scope)`.
pub fn sparse_apply_adagrad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    epsilon: O3,
    grad: O4,
    indices: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyAdagradV2::new().build(var, accum, lr, epsilon, grad, indices, scope)
}
/// Builder for the `SparseApplyCenteredRMSProp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyCenteredRMSProp {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyCenteredRMSProp {
    /// Creates a new `SparseApplyCenteredRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyCenteredRMSProp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        mg: O1,
        ms: O2,
        mom: O3,
        lr: O4,
        rho: O5,
        momentum: O6,
        epsilon: O7,
        grad: O8,
        indices: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            mg.into(),
            ms.into(),
            mom.into(),
            lr.into(),
            rho.into(),
            momentum.into(),
            epsilon.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        mg: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        momentum: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyCenteredRMSProp", |nd| {
            nd.add_input(var);
            nd.add_input(mg);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(momentum);
            nd.add_input(epsilon);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyCenteredRMSProp::new().build(var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices, scope)`.
pub fn sparse_apply_centered_rmsprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    mg: O1,
    ms: O2,
    mom: O3,
    lr: O4,
    rho: O5,
    momentum: O6,
    epsilon: O7,
    grad: O8,
    indices: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyCenteredRMSProp::new().build(
        var, mg, ms, mom, lr, rho, momentum, epsilon, grad, indices, scope,
    )
}
/// Builder for the `SparseApplyFtrl` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyFtrl {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    multiply_linear_by_lr: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyFtrl {
    /// Creates a new `SparseApplyFtrl`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `multiply_linear_by_lr` attribute.
    pub fn multiply_linear_by_lr<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.multiply_linear_by_lr = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyFtrl` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        linear: O2,
        grad: O3,
        indices: O4,
        lr: O5,
        l1: O6,
        l2: O7,
        lr_power: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            linear.into(),
            grad.into(),
            indices.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            lr_power.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        linear: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        lr_power: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyFtrl", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(linear);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(lr_power);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.multiply_linear_by_lr {
                nd.set_attr_bool("multiply_linear_by_lr", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyFtrl::new().build(var, accum, linear, grad, indices, lr, l1, l2, lr_power, scope)`.
pub fn sparse_apply_ftrl<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    linear: O2,
    grad: O3,
    indices: O4,
    lr: O5,
    l1: O6,
    l2: O7,
    lr_power: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyFtrl::new().build(
        var, accum, linear, grad, indices, lr, l1, l2, lr_power, scope,
    )
}
/// Builder for the `SparseApplyFtrlV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyFtrlV2 {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    multiply_linear_by_lr: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyFtrlV2 {
    /// Creates a new `SparseApplyFtrlV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `multiply_linear_by_lr` attribute.
    pub fn multiply_linear_by_lr<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.multiply_linear_by_lr = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyFtrlV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
        O9: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        linear: O2,
        grad: O3,
        indices: O4,
        lr: O5,
        l1: O6,
        l2: O7,
        l2_shrinkage: O8,
        lr_power: O9,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            linear.into(),
            grad.into(),
            indices.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            l2_shrinkage.into(),
            lr_power.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        linear: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        l2_shrinkage: crate::Output,
        lr_power: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyFtrlV2", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(linear);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(l2_shrinkage);
            nd.add_input(lr_power);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.multiply_linear_by_lr {
                nd.set_attr_bool("multiply_linear_by_lr", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyFtrlV2::new().build(var, accum, linear, grad, indices, lr, l1, l2, l2_shrinkage, lr_power, scope)`.
pub fn sparse_apply_ftrl_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
    O9: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    linear: O2,
    grad: O3,
    indices: O4,
    lr: O5,
    l1: O6,
    l2: O7,
    l2_shrinkage: O8,
    lr_power: O9,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyFtrlV2::new().build(
        var,
        accum,
        linear,
        grad,
        indices,
        lr,
        l1,
        l2,
        l2_shrinkage,
        lr_power,
        scope,
    )
}
/// Builder for the `SparseApplyMomentum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyMomentum {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    use_nesterov: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyMomentum {
    /// Creates a new `SparseApplyMomentum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_nesterov` attribute.
    pub fn use_nesterov<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_nesterov = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyMomentum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        grad: O3,
        indices: O4,
        momentum: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            grad.into(),
            indices.into(),
            momentum.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        momentum: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyMomentum", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(momentum);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_nesterov {
                nd.set_attr_bool("use_nesterov", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyMomentum::new().build(var, accum, lr, grad, indices, momentum, scope)`.
pub fn sparse_apply_momentum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    grad: O3,
    indices: O4,
    momentum: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyMomentum::new().build(var, accum, lr, grad, indices, momentum, scope)
}
/// Builder for the `SparseApplyProximalAdagrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyProximalAdagrad {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyProximalAdagrad {
    /// Creates a new `SparseApplyProximalAdagrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyProximalAdagrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        accum: O1,
        lr: O2,
        l1: O3,
        l2: O4,
        grad: O5,
        indices: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            accum.into(),
            lr.into(),
            l1.into(),
            l2.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        accum: crate::Output,
        lr: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyProximalAdagrad", |nd| {
            nd.add_input(var);
            nd.add_input(accum);
            nd.add_input(lr);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyProximalAdagrad::new().build(var, accum, lr, l1, l2, grad, indices, scope)`.
pub fn sparse_apply_proximal_adagrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    accum: O1,
    lr: O2,
    l1: O3,
    l2: O4,
    grad: O5,
    indices: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyProximalAdagrad::new().build(var, accum, lr, l1, l2, grad, indices, scope)
}
/// Builder for the `SparseApplyProximalGradientDescent` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyProximalGradientDescent {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyProximalGradientDescent {
    /// Creates a new `SparseApplyProximalGradientDescent`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyProximalGradientDescent` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        alpha: O1,
        l1: O2,
        l2: O3,
        grad: O4,
        indices: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            alpha.into(),
            l1.into(),
            l2.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        alpha: crate::Output,
        l1: crate::Output,
        l2: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyProximalGradientDescent", |nd| {
            nd.add_input(var);
            nd.add_input(alpha);
            nd.add_input(l1);
            nd.add_input(l2);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyProximalGradientDescent::new().build(var, alpha, l1, l2, grad, indices, scope)`.
pub fn sparse_apply_proximal_gradient_descent<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    alpha: O1,
    l1: O2,
    l2: O3,
    grad: O4,
    indices: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyProximalGradientDescent::new().build(var, alpha, l1, l2, grad, indices, scope)
}
/// Builder for the `SparseApplyRMSProp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseApplyRMSProp {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    use_locking: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseApplyRMSProp {
    /// Creates a new `SparseApplyRMSProp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_locking` attribute.
    pub fn use_locking<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_locking = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseApplyRMSProp` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
        O7: ::std::convert::Into<crate::Output>,
        O8: ::std::convert::Into<crate::Output>,
    >(
        &self,
        var: O0,
        ms: O1,
        mom: O2,
        lr: O3,
        rho: O4,
        momentum: O5,
        epsilon: O6,
        grad: O7,
        indices: O8,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            var.into(),
            ms.into(),
            mom.into(),
            lr.into(),
            rho.into(),
            momentum.into(),
            epsilon.into(),
            grad.into(),
            indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        var: crate::Output,
        ms: crate::Output,
        mom: crate::Output,
        lr: crate::Output,
        rho: crate::Output,
        momentum: crate::Output,
        epsilon: crate::Output,
        grad: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseApplyRMSProp", |nd| {
            nd.add_input(var);
            nd.add_input(ms);
            nd.add_input(mom);
            nd.add_input(lr);
            nd.add_input(rho);
            nd.add_input(momentum);
            nd.add_input(epsilon);
            nd.add_input(grad);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_locking {
                nd.set_attr_bool("use_locking", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseApplyRMSProp::new().build(var, ms, mom, lr, rho, momentum, epsilon, grad, indices, scope)`.
pub fn sparse_apply_rmsprop<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
    O7: ::std::convert::Into<crate::Output>,
    O8: ::std::convert::Into<crate::Output>,
>(
    var: O0,
    ms: O1,
    mom: O2,
    lr: O3,
    rho: O4,
    momentum: O5,
    epsilon: O6,
    grad: O7,
    indices: O8,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseApplyRMSProp::new().build(
        var, ms, mom, lr, rho, momentum, epsilon, grad, indices, scope,
    )
}
/// Builder for the `SparseBincount` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseBincount {
    Tidx: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    binary_output: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseBincount {
    /// Creates a new `SparseBincount`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `binary_output` attribute.
    pub fn binary_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.binary_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseBincount` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        dense_shape: O2,
        size: O3,
        weights: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            indices.into(),
            values.into(),
            dense_shape.into(),
            size.into(),
            weights.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        dense_shape: crate::Output,
        size: crate::Output,
        weights: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseBincount", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(dense_shape);
            nd.add_input(size);
            nd.add_input(weights);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.binary_output {
                nd.set_attr_bool("binary_output", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseBincount::new().build(indices, values, dense_shape, size, weights, scope)`.
pub fn sparse_bincount<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    dense_shape: O2,
    size: O3,
    weights: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseBincount::new().build(indices, values, dense_shape, size, weights, scope)
}
/// Builder for the `SparseConcat` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseConcat {
    concat_dim: ::std::option::Option<i64>,
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseConcat {
    /// Creates a new `SparseConcat`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `concat_dim` attribute.
    pub fn concat_dim<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.concat_dim = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseConcat` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        shapes: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), values.into(), shapes.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        shapes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseConcat", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(shapes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.concat_dim {
                nd.set_attr_int("concat_dim", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseConcat::new().build(indices, values, shapes, scope)`.
pub fn sparse_concat<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    shapes: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseConcat::new().build(indices, values, shapes, scope)
}
/// Builder for the `SparseConditionalAccumulator` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseConditionalAccumulator {
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    reduction_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseConditionalAccumulator {
    /// Creates a new `SparseConditionalAccumulator`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `reduction_type` attribute.
    pub fn reduction_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.reduction_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseConditionalAccumulator` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseConditionalAccumulator", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.reduction_type {
                nd.set_attr_string("reduction_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseConditionalAccumulator::new().build(scope)`.
pub fn sparse_conditional_accumulator(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    SparseConditionalAccumulator::new().build(scope)
}
/// Builder for the `SparseCountSparseOutput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseCountSparseOutput {
    T: ::std::option::Option<crate::DataType>,
    minlength: ::std::option::Option<i64>,
    maxlength: ::std::option::Option<i64>,
    binary_output: ::std::option::Option<bool>,
    output_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseCountSparseOutput {
    /// Creates a new `SparseCountSparseOutput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `minlength` attribute.
    pub fn minlength<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.minlength = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `maxlength` attribute.
    pub fn maxlength<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.maxlength = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `binary_output` attribute.
    pub fn binary_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.binary_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_type` attribute.
    pub fn output_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseCountSparseOutput` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        dense_shape: O2,
        weights: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            indices.into(),
            values.into(),
            dense_shape.into(),
            weights.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        dense_shape: crate::Output,
        weights: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseCountSparseOutput", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(dense_shape);
            nd.add_input(weights);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.minlength {
                nd.set_attr_int("minlength", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.maxlength {
                nd.set_attr_int("maxlength", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.binary_output {
                nd.set_attr_bool("binary_output", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_type {
                nd.set_attr_type("output_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseCountSparseOutput::new().build(indices, values, dense_shape, weights, scope)`.
pub fn sparse_count_sparse_output<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    dense_shape: O2,
    weights: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseCountSparseOutput::new().build(indices, values, dense_shape, weights, scope)
}
/// Builder for the `SparseCross` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseCross {
    N: ::std::option::Option<i64>,
    hashed_output: ::std::option::Option<bool>,
    num_buckets: ::std::option::Option<i64>,
    hash_key: ::std::option::Option<i64>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    out_type: ::std::option::Option<crate::DataType>,
    internal_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseCross {
    /// Creates a new `SparseCross`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `hashed_output` attribute.
    pub fn hashed_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.hashed_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_buckets` attribute.
    pub fn num_buckets<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `hash_key` attribute.
    pub fn hash_key<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.hash_key = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_types` attribute.
    pub fn dense_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `internal_type` attribute.
    pub fn internal_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.internal_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseCross` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        shapes: O2,
        dense_inputs: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            indices.into(),
            values.into(),
            shapes.into(),
            dense_inputs.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        shapes: crate::Output,
        dense_inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseCross", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(shapes);
            nd.add_input(dense_inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.hashed_output {
                nd.set_attr_bool("hashed_output", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_buckets {
                nd.set_attr_int("num_buckets", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.hash_key {
                nd.set_attr_int("hash_key", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_types {
                nd.set_attr_type_list("dense_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.internal_type {
                nd.set_attr_type("internal_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseCross::new().build(indices, values, shapes, dense_inputs, scope)`.
pub fn sparse_cross<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    shapes: O2,
    dense_inputs: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseCross::new().build(indices, values, shapes, dense_inputs, scope)
}
/// Builder for the `SparseCrossHashed` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseCrossHashed {
    N: ::std::option::Option<i64>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseCrossHashed {
    /// Creates a new `SparseCrossHashed`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_types` attribute.
    pub fn dense_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseCrossHashed` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
        O6: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        shapes: O2,
        dense_inputs: O3,
        num_buckets: O4,
        strong_hash: O5,
        salt: O6,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            indices.into(),
            values.into(),
            shapes.into(),
            dense_inputs.into(),
            num_buckets.into(),
            strong_hash.into(),
            salt.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        shapes: crate::Output,
        dense_inputs: crate::Output,
        num_buckets: crate::Output,
        strong_hash: crate::Output,
        salt: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseCrossHashed", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(shapes);
            nd.add_input(dense_inputs);
            nd.add_input(num_buckets);
            nd.add_input(strong_hash);
            nd.add_input(salt);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_types {
                nd.set_attr_type_list("dense_types", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseCrossHashed::new().build(indices, values, shapes, dense_inputs, num_buckets, strong_hash, salt, scope)`.
pub fn sparse_cross_hashed<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
    O6: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    shapes: O2,
    dense_inputs: O3,
    num_buckets: O4,
    strong_hash: O5,
    salt: O6,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseCrossHashed::new().build(
        indices,
        values,
        shapes,
        dense_inputs,
        num_buckets,
        strong_hash,
        salt,
        scope,
    )
}
/// Builder for the `SparseCrossV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseCrossV2 {
    N: ::std::option::Option<i64>,
    sparse_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    dense_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseCrossV2 {
    /// Creates a new `SparseCrossV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sparse_types` attribute.
    pub fn sparse_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.sparse_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dense_types` attribute.
    pub fn dense_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dense_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseCrossV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        shapes: O2,
        dense_inputs: O3,
        sep: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            indices.into(),
            values.into(),
            shapes.into(),
            dense_inputs.into(),
            sep.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        shapes: crate::Output,
        dense_inputs: crate::Output,
        sep: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseCrossV2", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(shapes);
            nd.add_input(dense_inputs);
            nd.add_input(sep);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sparse_types {
                nd.set_attr_type_list("sparse_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dense_types {
                nd.set_attr_type_list("dense_types", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseCrossV2::new().build(indices, values, shapes, dense_inputs, sep, scope)`.
pub fn sparse_cross_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    shapes: O2,
    dense_inputs: O3,
    sep: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseCrossV2::new().build(indices, values, shapes, dense_inputs, sep, scope)
}
/// Builder for the `SparseDenseCwiseAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseDenseCwiseAdd {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseDenseCwiseAdd {
    /// Creates a new `SparseDenseCwiseAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseDenseCwiseAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sp_indices: O0,
        sp_values: O1,
        sp_shape: O2,
        dense: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sp_indices.into(),
            sp_values.into(),
            sp_shape.into(),
            dense.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sp_indices: crate::Output,
        sp_values: crate::Output,
        sp_shape: crate::Output,
        dense: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseDenseCwiseAdd", |nd| {
            nd.add_input(sp_indices);
            nd.add_input(sp_values);
            nd.add_input(sp_shape);
            nd.add_input(dense);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseDenseCwiseAdd::new().build(sp_indices, sp_values, sp_shape, dense, scope)`.
pub fn sparse_dense_cwise_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    sp_indices: O0,
    sp_values: O1,
    sp_shape: O2,
    dense: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseDenseCwiseAdd::new().build(sp_indices, sp_values, sp_shape, dense, scope)
}
/// Builder for the `SparseDenseCwiseDiv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseDenseCwiseDiv {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseDenseCwiseDiv {
    /// Creates a new `SparseDenseCwiseDiv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseDenseCwiseDiv` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sp_indices: O0,
        sp_values: O1,
        sp_shape: O2,
        dense: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sp_indices.into(),
            sp_values.into(),
            sp_shape.into(),
            dense.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sp_indices: crate::Output,
        sp_values: crate::Output,
        sp_shape: crate::Output,
        dense: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseDenseCwiseDiv", |nd| {
            nd.add_input(sp_indices);
            nd.add_input(sp_values);
            nd.add_input(sp_shape);
            nd.add_input(dense);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseDenseCwiseDiv::new().build(sp_indices, sp_values, sp_shape, dense, scope)`.
pub fn sparse_dense_cwise_div<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    sp_indices: O0,
    sp_values: O1,
    sp_shape: O2,
    dense: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseDenseCwiseDiv::new().build(sp_indices, sp_values, sp_shape, dense, scope)
}
/// Builder for the `SparseDenseCwiseMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseDenseCwiseMul {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseDenseCwiseMul {
    /// Creates a new `SparseDenseCwiseMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseDenseCwiseMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sp_indices: O0,
        sp_values: O1,
        sp_shape: O2,
        dense: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sp_indices.into(),
            sp_values.into(),
            sp_shape.into(),
            dense.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sp_indices: crate::Output,
        sp_values: crate::Output,
        sp_shape: crate::Output,
        dense: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseDenseCwiseMul", |nd| {
            nd.add_input(sp_indices);
            nd.add_input(sp_values);
            nd.add_input(sp_shape);
            nd.add_input(dense);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseDenseCwiseMul::new().build(sp_indices, sp_values, sp_shape, dense, scope)`.
pub fn sparse_dense_cwise_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    sp_indices: O0,
    sp_values: O1,
    sp_shape: O2,
    dense: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseDenseCwiseMul::new().build(sp_indices, sp_values, sp_shape, dense, scope)
}
/// Builder for the `SparseFillEmptyRows` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseFillEmptyRows {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseFillEmptyRows {
    /// Creates a new `SparseFillEmptyRows`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseFillEmptyRows` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        dense_shape: O2,
        default_value: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            indices.into(),
            values.into(),
            dense_shape.into(),
            default_value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        dense_shape: crate::Output,
        default_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseFillEmptyRows", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(dense_shape);
            nd.add_input(default_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseFillEmptyRows::new().build(indices, values, dense_shape, default_value, scope)`.
pub fn sparse_fill_empty_rows<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    dense_shape: O2,
    default_value: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseFillEmptyRows::new().build(indices, values, dense_shape, default_value, scope)
}
/// Builder for the `SparseFillEmptyRowsGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseFillEmptyRowsGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseFillEmptyRowsGrad {
    /// Creates a new `SparseFillEmptyRowsGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseFillEmptyRowsGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        reverse_index_map: O0,
        grad_values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(reverse_index_map.into(), grad_values.into(), scope)
    }

    fn build_impl(
        &self,
        reverse_index_map: crate::Output,
        grad_values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseFillEmptyRowsGrad", |nd| {
            nd.add_input(reverse_index_map);
            nd.add_input(grad_values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseFillEmptyRowsGrad::new().build(reverse_index_map, grad_values, scope)`.
pub fn sparse_fill_empty_rows_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    reverse_index_map: O0,
    grad_values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseFillEmptyRowsGrad::new().build(reverse_index_map, grad_values, scope)
}
/// Builder for the `SparseMatMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatMul {
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    a_is_sparse: ::std::option::Option<bool>,
    b_is_sparse: ::std::option::Option<bool>,
    Ta: ::std::option::Option<crate::DataType>,
    Tb: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatMul {
    /// Creates a new `SparseMatMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `a_is_sparse` attribute.
    pub fn a_is_sparse<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.a_is_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `b_is_sparse` attribute.
    pub fn b_is_sparse<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.b_is_sparse = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Ta` attribute.
    pub fn Ta<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Ta = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tb` attribute.
    pub fn Tb<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tb = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), b.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatMul", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.a_is_sparse {
                nd.set_attr_bool("a_is_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.b_is_sparse {
                nd.set_attr_bool("b_is_sparse", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Ta {
                nd.set_attr_type("Ta", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tb {
                nd.set_attr_type("Tb", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatMul::new().build(a, b, scope)`.
pub fn sparse_mat_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatMul::new().build(a, b, scope)
}
/// Builder for the `SparseMatrixAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixAdd {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixAdd {
    /// Creates a new `SparseMatrixAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        alpha: O2,
        beta: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), b.into(), alpha.into(), beta.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        alpha: crate::Output,
        beta: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixAdd", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            nd.add_input(alpha);
            nd.add_input(beta);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixAdd::new().build(a, b, alpha, beta, scope)`.
pub fn sparse_matrix_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    alpha: O2,
    beta: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixAdd::new().build(a, b, alpha, beta, scope)
}
/// Builder for the `SparseMatrixMatMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixMatMul {
    T: ::std::option::Option<crate::DataType>,
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    adjoint_a: ::std::option::Option<bool>,
    adjoint_b: ::std::option::Option<bool>,
    transpose_output: ::std::option::Option<bool>,
    conjugate_output: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixMatMul {
    /// Creates a new `SparseMatrixMatMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint_a` attribute.
    pub fn adjoint_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint_b` attribute.
    pub fn adjoint_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_output` attribute.
    pub fn transpose_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `conjugate_output` attribute.
    pub fn conjugate_output<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.conjugate_output = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixMatMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), b.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixMatMul", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint_a {
                nd.set_attr_bool("adjoint_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint_b {
                nd.set_attr_bool("adjoint_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_output {
                nd.set_attr_bool("transpose_output", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.conjugate_output {
                nd.set_attr_bool("conjugate_output", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixMatMul::new().build(a, b, scope)`.
pub fn sparse_matrix_mat_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixMatMul::new().build(a, b, scope)
}
/// Builder for the `SparseMatrixMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixMul {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixMul {
    /// Creates a new `SparseMatrixMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), b.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixMul", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixMul::new().build(a, b, scope)`.
pub fn sparse_matrix_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixMul::new().build(a, b, scope)
}
/// Builder for the `SparseMatrixNNZ` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixNNZ {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixNNZ {
    /// Creates a new `SparseMatrixNNZ`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixNNZ` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        sparse_matrix: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(sparse_matrix.into(), scope)
    }

    fn build_impl(
        &self,
        sparse_matrix: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixNNZ", |nd| {
            nd.add_input(sparse_matrix);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixNNZ::new().build(sparse_matrix, scope)`.
pub fn sparse_matrix_nnz<O0: ::std::convert::Into<crate::Output>>(
    sparse_matrix: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixNNZ::new().build(sparse_matrix, scope)
}
/// Builder for the `SparseMatrixOrderingAMD` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixOrderingAMD {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixOrderingAMD {
    /// Creates a new `SparseMatrixOrderingAMD`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixOrderingAMD` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixOrderingAMD", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixOrderingAMD::new().build(input, scope)`.
pub fn sparse_matrix_ordering_amd<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixOrderingAMD::new().build(input, scope)
}
/// Builder for the `SparseMatrixSoftmax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixSoftmax {
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixSoftmax {
    /// Creates a new `SparseMatrixSoftmax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixSoftmax` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        logits: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(logits.into(), scope)
    }

    fn build_impl(
        &self,
        logits: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixSoftmax", |nd| {
            nd.add_input(logits);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixSoftmax::new().build(logits, scope)`.
pub fn sparse_matrix_softmax<O0: ::std::convert::Into<crate::Output>>(
    logits: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixSoftmax::new().build(logits, scope)
}
/// Builder for the `SparseMatrixSoftmaxGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixSoftmaxGrad {
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixSoftmaxGrad {
    /// Creates a new `SparseMatrixSoftmaxGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixSoftmaxGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        softmax: O0,
        grad_softmax: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(softmax.into(), grad_softmax.into(), scope)
    }

    fn build_impl(
        &self,
        softmax: crate::Output,
        grad_softmax: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixSoftmaxGrad", |nd| {
            nd.add_input(softmax);
            nd.add_input(grad_softmax);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixSoftmaxGrad::new().build(softmax, grad_softmax, scope)`.
pub fn sparse_matrix_softmax_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    softmax: O0,
    grad_softmax: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixSoftmaxGrad::new().build(softmax, grad_softmax, scope)
}
/// Builder for the `SparseMatrixSparseCholesky` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixSparseCholesky {
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixSparseCholesky {
    /// Creates a new `SparseMatrixSparseCholesky`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixSparseCholesky` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        permutation: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), permutation.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        permutation: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixSparseCholesky", |nd| {
            nd.add_input(input);
            nd.add_input(permutation);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixSparseCholesky::new().build(input, permutation, scope)`.
pub fn sparse_matrix_sparse_cholesky<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    permutation: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixSparseCholesky::new().build(input, permutation, scope)
}
/// Builder for the `SparseMatrixSparseMatMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixSparseMatMul {
    type_: ::std::option::Option<crate::DataType>,
    transpose_a: ::std::option::Option<bool>,
    transpose_b: ::std::option::Option<bool>,
    adjoint_a: ::std::option::Option<bool>,
    adjoint_b: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixSparseMatMul {
    /// Creates a new `SparseMatrixSparseMatMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_a` attribute.
    pub fn transpose_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `transpose_b` attribute.
    pub fn transpose_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.transpose_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint_a` attribute.
    pub fn adjoint_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint_b` attribute.
    pub fn adjoint_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixSparseMatMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a: O0,
        b: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(a.into(), b.into(), scope)
    }

    fn build_impl(
        &self,
        a: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixSparseMatMul", |nd| {
            nd.add_input(a);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_a {
                nd.set_attr_bool("transpose_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.transpose_b {
                nd.set_attr_bool("transpose_b", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint_a {
                nd.set_attr_bool("adjoint_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint_b {
                nd.set_attr_bool("adjoint_b", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixSparseMatMul::new().build(a, b, scope)`.
pub fn sparse_matrix_sparse_mat_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    a: O0,
    b: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixSparseMatMul::new().build(a, b, scope)
}
/// Builder for the `SparseMatrixTranspose` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixTranspose {
    conjugate: ::std::option::Option<bool>,
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixTranspose {
    /// Creates a new `SparseMatrixTranspose`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `conjugate` attribute.
    pub fn conjugate<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.conjugate = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixTranspose` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixTranspose", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.conjugate {
                nd.set_attr_bool("conjugate", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixTranspose::new().build(input, scope)`.
pub fn sparse_matrix_transpose<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixTranspose::new().build(input, scope)
}
/// Builder for the `SparseMatrixZeros` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseMatrixZeros {
    type_: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseMatrixZeros {
    /// Creates a new `SparseMatrixZeros`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `type` attribute.
    pub fn type_<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.type_ = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseMatrixZeros` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        dense_shape: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(dense_shape.into(), scope)
    }

    fn build_impl(
        &self,
        dense_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseMatrixZeros", |nd| {
            nd.add_input(dense_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.type_ {
                nd.set_attr_type("type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseMatrixZeros::new().build(dense_shape, scope)`.
pub fn sparse_matrix_zeros<O0: ::std::convert::Into<crate::Output>>(
    dense_shape: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseMatrixZeros::new().build(dense_shape, scope)
}
/// Builder for the `SparseReduceMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReduceMax {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseReduceMax {
    /// Creates a new `SparseReduceMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseReduceMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_indices: O0,
        input_values: O1,
        input_shape: O2,
        reduction_axes: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_indices.into(),
            input_values.into(),
            input_shape.into(),
            reduction_axes.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_indices: crate::Output,
        input_values: crate::Output,
        input_shape: crate::Output,
        reduction_axes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseReduceMax", |nd| {
            nd.add_input(input_indices);
            nd.add_input(input_values);
            nd.add_input(input_shape);
            nd.add_input(reduction_axes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseReduceMax::new().build(input_indices, input_values, input_shape, reduction_axes, scope)`.
pub fn sparse_reduce_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_indices: O0,
    input_values: O1,
    input_shape: O2,
    reduction_axes: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseReduceMax::new().build(
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        scope,
    )
}
/// Builder for the `SparseReduceMaxSparse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReduceMaxSparse {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseReduceMaxSparse {
    /// Creates a new `SparseReduceMaxSparse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseReduceMaxSparse` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_indices: O0,
        input_values: O1,
        input_shape: O2,
        reduction_axes: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_indices.into(),
            input_values.into(),
            input_shape.into(),
            reduction_axes.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_indices: crate::Output,
        input_values: crate::Output,
        input_shape: crate::Output,
        reduction_axes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseReduceMaxSparse", |nd| {
            nd.add_input(input_indices);
            nd.add_input(input_values);
            nd.add_input(input_shape);
            nd.add_input(reduction_axes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseReduceMaxSparse::new().build(input_indices, input_values, input_shape, reduction_axes, scope)`.
pub fn sparse_reduce_max_sparse<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_indices: O0,
    input_values: O1,
    input_shape: O2,
    reduction_axes: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseReduceMaxSparse::new().build(
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        scope,
    )
}
/// Builder for the `SparseReduceSum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReduceSum {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseReduceSum {
    /// Creates a new `SparseReduceSum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseReduceSum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_indices: O0,
        input_values: O1,
        input_shape: O2,
        reduction_axes: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_indices.into(),
            input_values.into(),
            input_shape.into(),
            reduction_axes.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_indices: crate::Output,
        input_values: crate::Output,
        input_shape: crate::Output,
        reduction_axes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseReduceSum", |nd| {
            nd.add_input(input_indices);
            nd.add_input(input_values);
            nd.add_input(input_shape);
            nd.add_input(reduction_axes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseReduceSum::new().build(input_indices, input_values, input_shape, reduction_axes, scope)`.
pub fn sparse_reduce_sum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_indices: O0,
    input_values: O1,
    input_shape: O2,
    reduction_axes: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseReduceSum::new().build(
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        scope,
    )
}
/// Builder for the `SparseReduceSumSparse` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReduceSumSparse {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseReduceSumSparse {
    /// Creates a new `SparseReduceSumSparse`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseReduceSumSparse` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_indices: O0,
        input_values: O1,
        input_shape: O2,
        reduction_axes: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_indices.into(),
            input_values.into(),
            input_shape.into(),
            reduction_axes.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_indices: crate::Output,
        input_values: crate::Output,
        input_shape: crate::Output,
        reduction_axes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseReduceSumSparse", |nd| {
            nd.add_input(input_indices);
            nd.add_input(input_values);
            nd.add_input(input_shape);
            nd.add_input(reduction_axes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseReduceSumSparse::new().build(input_indices, input_values, input_shape, reduction_axes, scope)`.
pub fn sparse_reduce_sum_sparse<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input_indices: O0,
    input_values: O1,
    input_shape: O2,
    reduction_axes: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseReduceSumSparse::new().build(
        input_indices,
        input_values,
        input_shape,
        reduction_axes,
        scope,
    )
}
/// Builder for the `SparseReorder` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReorder {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseReorder {
    /// Creates a new `SparseReorder`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseReorder` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_indices: O0,
        input_values: O1,
        input_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_indices.into(),
            input_values.into(),
            input_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_indices: crate::Output,
        input_values: crate::Output,
        input_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseReorder", |nd| {
            nd.add_input(input_indices);
            nd.add_input(input_values);
            nd.add_input(input_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseReorder::new().build(input_indices, input_values, input_shape, scope)`.
pub fn sparse_reorder<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_indices: O0,
    input_values: O1,
    input_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseReorder::new().build(input_indices, input_values, input_shape, scope)
}
/// Builder for the `SparseReshape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseReshape {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseReshape {
    /// Creates a new `SparseReshape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseReshape` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_indices: O0,
        input_shape: O1,
        new_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_indices.into(),
            input_shape.into(),
            new_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_indices: crate::Output,
        input_shape: crate::Output,
        new_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseReshape", |nd| {
            nd.add_input(input_indices);
            nd.add_input(input_shape);
            nd.add_input(new_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseReshape::new().build(input_indices, input_shape, new_shape, scope)`.
pub fn sparse_reshape<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_indices: O0,
    input_shape: O1,
    new_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseReshape::new().build(input_indices, input_shape, new_shape, scope)
}
/// Builder for the `SparseSegmentMean` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentMean {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    Tsegmentids: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSegmentMean {
    /// Creates a new `SparseSegmentMean`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsegmentids` attribute.
    pub fn Tsegmentids<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsegmentids = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSegmentMean` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        indices: O1,
        segment_ids: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), indices.into(), segment_ids.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        indices: crate::Output,
        segment_ids: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSegmentMean", |nd| {
            nd.add_input(data);
            nd.add_input(indices);
            nd.add_input(segment_ids);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsegmentids {
                nd.set_attr_type("Tsegmentids", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSegmentMean::new().build(data, indices, segment_ids, scope)`.
pub fn sparse_segment_mean<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    indices: O1,
    segment_ids: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSegmentMean::new().build(data, indices, segment_ids, scope)
}
/// Builder for the `SparseSegmentMeanGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentMeanGrad {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    Tsegmentids: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSegmentMeanGrad {
    /// Creates a new `SparseSegmentMeanGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsegmentids` attribute.
    pub fn Tsegmentids<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsegmentids = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSegmentMeanGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        grad: O0,
        indices: O1,
        segment_ids: O2,
        output_dim0: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            grad.into(),
            indices.into(),
            segment_ids.into(),
            output_dim0.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        grad: crate::Output,
        indices: crate::Output,
        segment_ids: crate::Output,
        output_dim0: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSegmentMeanGrad", |nd| {
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(segment_ids);
            nd.add_input(output_dim0);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsegmentids {
                nd.set_attr_type("Tsegmentids", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSegmentMeanGrad::new().build(grad, indices, segment_ids, output_dim0, scope)`.
pub fn sparse_segment_mean_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    grad: O0,
    indices: O1,
    segment_ids: O2,
    output_dim0: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSegmentMeanGrad::new().build(grad, indices, segment_ids, output_dim0, scope)
}
/// Builder for the `SparseSegmentMeanWithNumSegments` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentMeanWithNumSegments {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    Tnumsegments: ::std::option::Option<crate::DataType>,
    Tsegmentids: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSegmentMeanWithNumSegments {
    /// Creates a new `SparseSegmentMeanWithNumSegments`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnumsegments` attribute.
    pub fn Tnumsegments<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnumsegments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsegmentids` attribute.
    pub fn Tsegmentids<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsegmentids = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSegmentMeanWithNumSegments` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        indices: O1,
        segment_ids: O2,
        num_segments: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            data.into(),
            indices.into(),
            segment_ids.into(),
            num_segments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        data: crate::Output,
        indices: crate::Output,
        segment_ids: crate::Output,
        num_segments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSegmentMeanWithNumSegments", |nd| {
            nd.add_input(data);
            nd.add_input(indices);
            nd.add_input(segment_ids);
            nd.add_input(num_segments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnumsegments {
                nd.set_attr_type("Tnumsegments", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsegmentids {
                nd.set_attr_type("Tsegmentids", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSegmentMeanWithNumSegments::new().build(data, indices, segment_ids, num_segments, scope)`.
pub fn sparse_segment_mean_with_num_segments<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    indices: O1,
    segment_ids: O2,
    num_segments: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSegmentMeanWithNumSegments::new().build(data, indices, segment_ids, num_segments, scope)
}
/// Builder for the `SparseSegmentSqrtN` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSqrtN {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    Tsegmentids: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSegmentSqrtN {
    /// Creates a new `SparseSegmentSqrtN`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsegmentids` attribute.
    pub fn Tsegmentids<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsegmentids = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSegmentSqrtN` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        indices: O1,
        segment_ids: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), indices.into(), segment_ids.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        indices: crate::Output,
        segment_ids: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSegmentSqrtN", |nd| {
            nd.add_input(data);
            nd.add_input(indices);
            nd.add_input(segment_ids);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsegmentids {
                nd.set_attr_type("Tsegmentids", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSegmentSqrtN::new().build(data, indices, segment_ids, scope)`.
pub fn sparse_segment_sqrt_n<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    indices: O1,
    segment_ids: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSegmentSqrtN::new().build(data, indices, segment_ids, scope)
}
/// Builder for the `SparseSegmentSqrtNGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSqrtNGrad {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    Tsegmentids: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSegmentSqrtNGrad {
    /// Creates a new `SparseSegmentSqrtNGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsegmentids` attribute.
    pub fn Tsegmentids<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsegmentids = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSegmentSqrtNGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        grad: O0,
        indices: O1,
        segment_ids: O2,
        output_dim0: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            grad.into(),
            indices.into(),
            segment_ids.into(),
            output_dim0.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        grad: crate::Output,
        indices: crate::Output,
        segment_ids: crate::Output,
        output_dim0: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSegmentSqrtNGrad", |nd| {
            nd.add_input(grad);
            nd.add_input(indices);
            nd.add_input(segment_ids);
            nd.add_input(output_dim0);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsegmentids {
                nd.set_attr_type("Tsegmentids", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSegmentSqrtNGrad::new().build(grad, indices, segment_ids, output_dim0, scope)`.
pub fn sparse_segment_sqrt_ngrad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    grad: O0,
    indices: O1,
    segment_ids: O2,
    output_dim0: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSegmentSqrtNGrad::new().build(grad, indices, segment_ids, output_dim0, scope)
}
/// Builder for the `SparseSegmentSqrtNWithNumSegments` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSqrtNWithNumSegments {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    Tnumsegments: ::std::option::Option<crate::DataType>,
    Tsegmentids: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSegmentSqrtNWithNumSegments {
    /// Creates a new `SparseSegmentSqrtNWithNumSegments`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnumsegments` attribute.
    pub fn Tnumsegments<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnumsegments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsegmentids` attribute.
    pub fn Tsegmentids<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsegmentids = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSegmentSqrtNWithNumSegments` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        indices: O1,
        segment_ids: O2,
        num_segments: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            data.into(),
            indices.into(),
            segment_ids.into(),
            num_segments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        data: crate::Output,
        indices: crate::Output,
        segment_ids: crate::Output,
        num_segments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSegmentSqrtNWithNumSegments", |nd| {
            nd.add_input(data);
            nd.add_input(indices);
            nd.add_input(segment_ids);
            nd.add_input(num_segments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnumsegments {
                nd.set_attr_type("Tnumsegments", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsegmentids {
                nd.set_attr_type("Tsegmentids", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSegmentSqrtNWithNumSegments::new().build(data, indices, segment_ids, num_segments, scope)`.
pub fn sparse_segment_sqrt_nwith_num_segments<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    indices: O1,
    segment_ids: O2,
    num_segments: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSegmentSqrtNWithNumSegments::new().build(data, indices, segment_ids, num_segments, scope)
}
/// Builder for the `SparseSegmentSum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSum {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    Tsegmentids: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSegmentSum {
    /// Creates a new `SparseSegmentSum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsegmentids` attribute.
    pub fn Tsegmentids<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsegmentids = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSegmentSum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        indices: O1,
        segment_ids: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), indices.into(), segment_ids.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        indices: crate::Output,
        segment_ids: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSegmentSum", |nd| {
            nd.add_input(data);
            nd.add_input(indices);
            nd.add_input(segment_ids);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsegmentids {
                nd.set_attr_type("Tsegmentids", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSegmentSum::new().build(data, indices, segment_ids, scope)`.
pub fn sparse_segment_sum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    indices: O1,
    segment_ids: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSegmentSum::new().build(data, indices, segment_ids, scope)
}
/// Builder for the `SparseSegmentSumWithNumSegments` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSegmentSumWithNumSegments {
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    Tnumsegments: ::std::option::Option<crate::DataType>,
    Tsegmentids: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSegmentSumWithNumSegments {
    /// Creates a new `SparseSegmentSumWithNumSegments`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnumsegments` attribute.
    pub fn Tnumsegments<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnumsegments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsegmentids` attribute.
    pub fn Tsegmentids<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsegmentids = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSegmentSumWithNumSegments` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        indices: O1,
        segment_ids: O2,
        num_segments: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            data.into(),
            indices.into(),
            segment_ids.into(),
            num_segments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        data: crate::Output,
        indices: crate::Output,
        segment_ids: crate::Output,
        num_segments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSegmentSumWithNumSegments", |nd| {
            nd.add_input(data);
            nd.add_input(indices);
            nd.add_input(segment_ids);
            nd.add_input(num_segments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnumsegments {
                nd.set_attr_type("Tnumsegments", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsegmentids {
                nd.set_attr_type("Tsegmentids", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSegmentSumWithNumSegments::new().build(data, indices, segment_ids, num_segments, scope)`.
pub fn sparse_segment_sum_with_num_segments<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    indices: O1,
    segment_ids: O2,
    num_segments: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSegmentSumWithNumSegments::new().build(data, indices, segment_ids, num_segments, scope)
}
/// Builder for the `SparseSlice` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSlice {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSlice {
    /// Creates a new `SparseSlice`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSlice` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        shape: O2,
        start: O3,
        size: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            indices.into(),
            values.into(),
            shape.into(),
            start.into(),
            size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        shape: crate::Output,
        start: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSlice", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(shape);
            nd.add_input(start);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSlice::new().build(indices, values, shape, start, size, scope)`.
pub fn sparse_slice<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    shape: O2,
    start: O3,
    size: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSlice::new().build(indices, values, shape, start, size, scope)
}
/// Builder for the `SparseSliceGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSliceGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSliceGrad {
    /// Creates a new `SparseSliceGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSliceGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        backprop_val_grad: O0,
        input_indices: O1,
        input_start: O2,
        output_indices: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            backprop_val_grad.into(),
            input_indices.into(),
            input_start.into(),
            output_indices.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        backprop_val_grad: crate::Output,
        input_indices: crate::Output,
        input_start: crate::Output,
        output_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSliceGrad", |nd| {
            nd.add_input(backprop_val_grad);
            nd.add_input(input_indices);
            nd.add_input(input_start);
            nd.add_input(output_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSliceGrad::new().build(backprop_val_grad, input_indices, input_start, output_indices, scope)`.
pub fn sparse_slice_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    backprop_val_grad: O0,
    input_indices: O1,
    input_start: O2,
    output_indices: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSliceGrad::new().build(
        backprop_val_grad,
        input_indices,
        input_start,
        output_indices,
        scope,
    )
}
/// Builder for the `SparseSoftmax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSoftmax {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSoftmax {
    /// Creates a new `SparseSoftmax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSoftmax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sp_indices: O0,
        sp_values: O1,
        sp_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(sp_indices.into(), sp_values.into(), sp_shape.into(), scope)
    }

    fn build_impl(
        &self,
        sp_indices: crate::Output,
        sp_values: crate::Output,
        sp_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSoftmax", |nd| {
            nd.add_input(sp_indices);
            nd.add_input(sp_values);
            nd.add_input(sp_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSoftmax::new().build(sp_indices, sp_values, sp_shape, scope)`.
pub fn sparse_softmax<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    sp_indices: O0,
    sp_values: O1,
    sp_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSoftmax::new().build(sp_indices, sp_values, sp_shape, scope)
}
/// Builder for the `SparseSoftmaxCrossEntropyWithLogits` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSoftmaxCrossEntropyWithLogits {
    T: ::std::option::Option<crate::DataType>,
    Tlabels: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSoftmaxCrossEntropyWithLogits {
    /// Creates a new `SparseSoftmaxCrossEntropyWithLogits`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tlabels` attribute.
    pub fn Tlabels<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tlabels = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSoftmaxCrossEntropyWithLogits` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        features: O0,
        labels: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(features.into(), labels.into(), scope)
    }

    fn build_impl(
        &self,
        features: crate::Output,
        labels: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSoftmaxCrossEntropyWithLogits", |nd| {
            nd.add_input(features);
            nd.add_input(labels);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tlabels {
                nd.set_attr_type("Tlabels", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSoftmaxCrossEntropyWithLogits::new().build(features, labels, scope)`.
pub fn sparse_softmax_cross_entropy_with_logits<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    features: O0,
    labels: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSoftmaxCrossEntropyWithLogits::new().build(features, labels, scope)
}
/// Builder for the `SparseSparseMaximum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSparseMaximum {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSparseMaximum {
    /// Creates a new `SparseSparseMaximum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSparseMaximum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a_indices: O0,
        a_values: O1,
        a_shape: O2,
        b_indices: O3,
        b_values: O4,
        b_shape: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a_indices.into(),
            a_values.into(),
            a_shape.into(),
            b_indices.into(),
            b_values.into(),
            b_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a_indices: crate::Output,
        a_values: crate::Output,
        a_shape: crate::Output,
        b_indices: crate::Output,
        b_values: crate::Output,
        b_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSparseMaximum", |nd| {
            nd.add_input(a_indices);
            nd.add_input(a_values);
            nd.add_input(a_shape);
            nd.add_input(b_indices);
            nd.add_input(b_values);
            nd.add_input(b_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSparseMaximum::new().build(a_indices, a_values, a_shape, b_indices, b_values, b_shape, scope)`.
pub fn sparse_sparse_maximum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    a_indices: O0,
    a_values: O1,
    a_shape: O2,
    b_indices: O3,
    b_values: O4,
    b_shape: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSparseMaximum::new().build(
        a_indices, a_values, a_shape, b_indices, b_values, b_shape, scope,
    )
}
/// Builder for the `SparseSparseMinimum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSparseMinimum {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSparseMinimum {
    /// Creates a new `SparseSparseMinimum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSparseMinimum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a_indices: O0,
        a_values: O1,
        a_shape: O2,
        b_indices: O3,
        b_values: O4,
        b_shape: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a_indices.into(),
            a_values.into(),
            a_shape.into(),
            b_indices.into(),
            b_values.into(),
            b_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a_indices: crate::Output,
        a_values: crate::Output,
        a_shape: crate::Output,
        b_indices: crate::Output,
        b_values: crate::Output,
        b_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSparseMinimum", |nd| {
            nd.add_input(a_indices);
            nd.add_input(a_values);
            nd.add_input(a_shape);
            nd.add_input(b_indices);
            nd.add_input(b_values);
            nd.add_input(b_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSparseMinimum::new().build(a_indices, a_values, a_shape, b_indices, b_values, b_shape, scope)`.
pub fn sparse_sparse_minimum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    a_indices: O0,
    a_values: O1,
    a_shape: O2,
    b_indices: O3,
    b_values: O4,
    b_shape: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSparseMinimum::new().build(
        a_indices, a_values, a_shape, b_indices, b_values, b_shape, scope,
    )
}
/// Builder for the `SparseSplit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseSplit {
    num_split: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseSplit {
    /// Creates a new `SparseSplit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_split` attribute.
    pub fn num_split<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_split = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseSplit` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        split_dim: O0,
        indices: O1,
        values: O2,
        shape: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            split_dim.into(),
            indices.into(),
            values.into(),
            shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        split_dim: crate::Output,
        indices: crate::Output,
        values: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseSplit", |nd| {
            nd.add_input(split_dim);
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_split {
                nd.set_attr_int("num_split", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseSplit::new().build(split_dim, indices, values, shape, scope)`.
pub fn sparse_split<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    split_dim: O0,
    indices: O1,
    values: O2,
    shape: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseSplit::new().build(split_dim, indices, values, shape, scope)
}
/// Builder for the `SparseTensorDenseAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseTensorDenseAdd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseTensorDenseAdd {
    /// Creates a new `SparseTensorDenseAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseTensorDenseAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a_indices: O0,
        a_values: O1,
        a_shape: O2,
        b: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a_indices.into(),
            a_values.into(),
            a_shape.into(),
            b.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a_indices: crate::Output,
        a_values: crate::Output,
        a_shape: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseTensorDenseAdd", |nd| {
            nd.add_input(a_indices);
            nd.add_input(a_values);
            nd.add_input(a_shape);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseTensorDenseAdd::new().build(a_indices, a_values, a_shape, b, scope)`.
pub fn sparse_tensor_dense_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    a_indices: O0,
    a_values: O1,
    a_shape: O2,
    b: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseTensorDenseAdd::new().build(a_indices, a_values, a_shape, b, scope)
}
/// Builder for the `SparseTensorDenseMatMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseTensorDenseMatMul {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    adjoint_a: ::std::option::Option<bool>,
    adjoint_b: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseTensorDenseMatMul {
    /// Creates a new `SparseTensorDenseMatMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint_a` attribute.
    pub fn adjoint_a<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint_a = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `adjoint_b` attribute.
    pub fn adjoint_b<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.adjoint_b = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseTensorDenseMatMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        a_indices: O0,
        a_values: O1,
        a_shape: O2,
        b: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            a_indices.into(),
            a_values.into(),
            a_shape.into(),
            b.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        a_indices: crate::Output,
        a_values: crate::Output,
        a_shape: crate::Output,
        b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseTensorDenseMatMul", |nd| {
            nd.add_input(a_indices);
            nd.add_input(a_values);
            nd.add_input(a_shape);
            nd.add_input(b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint_a {
                nd.set_attr_bool("adjoint_a", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.adjoint_b {
                nd.set_attr_bool("adjoint_b", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseTensorDenseMatMul::new().build(a_indices, a_values, a_shape, b, scope)`.
pub fn sparse_tensor_dense_mat_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    a_indices: O0,
    a_values: O1,
    a_shape: O2,
    b: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseTensorDenseMatMul::new().build(a_indices, a_values, a_shape, b, scope)
}
/// Builder for the `SparseTensorSliceDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseTensorSliceDataset {
    Tvalues: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseTensorSliceDataset {
    /// Creates a new `SparseTensorSliceDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tvalues` attribute.
    pub fn Tvalues<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tvalues = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseTensorSliceDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        dense_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), values.into(), dense_shape.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        dense_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseTensorSliceDataset", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(dense_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tvalues {
                nd.set_attr_type("Tvalues", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseTensorSliceDataset::new().build(indices, values, dense_shape, scope)`.
pub fn sparse_tensor_slice_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    dense_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseTensorSliceDataset::new().build(indices, values, dense_shape, scope)
}
/// Builder for the `SparseTensorToCSRSparseMatrix` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseTensorToCSRSparseMatrix {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseTensorToCSRSparseMatrix {
    /// Creates a new `SparseTensorToCSRSparseMatrix`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseTensorToCSRSparseMatrix` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        values: O1,
        dense_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), values.into(), dense_shape.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        values: crate::Output,
        dense_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseTensorToCSRSparseMatrix", |nd| {
            nd.add_input(indices);
            nd.add_input(values);
            nd.add_input(dense_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseTensorToCSRSparseMatrix::new().build(indices, values, dense_shape, scope)`.
pub fn sparse_tensor_to_csrsparse_matrix<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    values: O1,
    dense_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseTensorToCSRSparseMatrix::new().build(indices, values, dense_shape, scope)
}
/// Builder for the `SparseToDense` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseToDense {
    validate_indices: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseToDense {
    /// Creates a new `SparseToDense`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `validate_indices` attribute.
    pub fn validate_indices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.validate_indices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseToDense` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sparse_indices: O0,
        output_shape: O1,
        sparse_values: O2,
        default_value: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            sparse_indices.into(),
            output_shape.into(),
            sparse_values.into(),
            default_value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        sparse_indices: crate::Output,
        output_shape: crate::Output,
        sparse_values: crate::Output,
        default_value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseToDense", |nd| {
            nd.add_input(sparse_indices);
            nd.add_input(output_shape);
            nd.add_input(sparse_values);
            nd.add_input(default_value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.validate_indices {
                nd.set_attr_bool("validate_indices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseToDense::new().build(sparse_indices, output_shape, sparse_values, default_value, scope)`.
pub fn sparse_to_dense<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    sparse_indices: O0,
    output_shape: O1,
    sparse_values: O2,
    default_value: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseToDense::new().build(
        sparse_indices,
        output_shape,
        sparse_values,
        default_value,
        scope,
    )
}
/// Builder for the `SparseToSparseSetOperation` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SparseToSparseSetOperation {
    set_operation: ::std::option::Option<::std::string::String>,
    validate_indices: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SparseToSparseSetOperation {
    /// Creates a new `SparseToSparseSetOperation`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `set_operation` attribute.
    pub fn set_operation<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.set_operation = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `validate_indices` attribute.
    pub fn validate_indices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.validate_indices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SparseToSparseSetOperation` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        set1_indices: O0,
        set1_values: O1,
        set1_shape: O2,
        set2_indices: O3,
        set2_values: O4,
        set2_shape: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            set1_indices.into(),
            set1_values.into(),
            set1_shape.into(),
            set2_indices.into(),
            set2_values.into(),
            set2_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        set1_indices: crate::Output,
        set1_values: crate::Output,
        set1_shape: crate::Output,
        set2_indices: crate::Output,
        set2_values: crate::Output,
        set2_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SparseToSparseSetOperation", |nd| {
            nd.add_input(set1_indices);
            nd.add_input(set1_values);
            nd.add_input(set1_shape);
            nd.add_input(set2_indices);
            nd.add_input(set2_values);
            nd.add_input(set2_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.set_operation {
                nd.set_attr_string("set_operation", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.validate_indices {
                nd.set_attr_bool("validate_indices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SparseToSparseSetOperation::new().build(set1_indices, set1_values, set1_shape, set2_indices, set2_values, set2_shape, scope)`.
pub fn sparse_to_sparse_set_operation<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    set1_indices: O0,
    set1_values: O1,
    set1_shape: O2,
    set2_indices: O3,
    set2_values: O4,
    set2_shape: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SparseToSparseSetOperation::new().build(
        set1_indices,
        set1_values,
        set1_shape,
        set2_indices,
        set2_values,
        set2_shape,
        scope,
    )
}
/// Builder for the `Spence` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Spence {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Spence {
    /// Creates a new `Spence`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Spence` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Spence", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Spence::new().build(x, scope)`.
pub fn spence<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Spence::new().build(x, scope)
}
/// Builder for the `Split` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Split {
    num_split: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Split {
    /// Creates a new `Split`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_split` attribute.
    pub fn num_split<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_split = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Split` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        split_dim: O0,
        value: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(split_dim.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        split_dim: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Split", |nd| {
            nd.add_input(split_dim);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_split {
                nd.set_attr_int("num_split", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Split::new().build(split_dim, value, scope)`.
pub fn split<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    split_dim: O0,
    value: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Split::new().build(split_dim, value, scope)
}
/// Builder for the `SplitV` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SplitV {
    num_split: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    Tlen: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SplitV {
    /// Creates a new `SplitV`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_split` attribute.
    pub fn num_split<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_split = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tlen` attribute.
    pub fn Tlen<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tlen = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SplitV` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        value: O0,
        size_splits: O1,
        split_dim: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), size_splits.into(), split_dim.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        size_splits: crate::Output,
        split_dim: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SplitV", |nd| {
            nd.add_input(value);
            nd.add_input(size_splits);
            nd.add_input(split_dim);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_split {
                nd.set_attr_int("num_split", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tlen {
                nd.set_attr_type("Tlen", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SplitV::new().build(value, size_splits, split_dim, scope)`.
pub fn split_v<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    value: O0,
    size_splits: O1,
    split_dim: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SplitV::new().build(value, size_splits, split_dim, scope)
}
/// Builder for the `SqlDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SqlDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SqlDataset {
    /// Creates a new `SqlDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SqlDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        driver_name: O0,
        data_source_name: O1,
        query: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            driver_name.into(),
            data_source_name.into(),
            query.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        driver_name: crate::Output,
        data_source_name: crate::Output,
        query: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SqlDataset", |nd| {
            nd.add_input(driver_name);
            nd.add_input(data_source_name);
            nd.add_input(query);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SqlDataset::new().build(driver_name, data_source_name, query, scope)`.
pub fn sql_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    driver_name: O0,
    data_source_name: O1,
    query: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SqlDataset::new().build(driver_name, data_source_name, query, scope)
}
/// Builder for the `Sqrt` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sqrt {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Sqrt {
    /// Creates a new `Sqrt`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Sqrt` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Sqrt", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Sqrt::new().build(x, scope)`.
pub fn sqrt<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Sqrt::new().build(x, scope)
}
/// Builder for the `SqrtGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SqrtGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SqrtGrad {
    /// Creates a new `SqrtGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SqrtGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y: O0,
        dy: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(y.into(), dy.into(), scope)
    }

    fn build_impl(
        &self,
        y: crate::Output,
        dy: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SqrtGrad", |nd| {
            nd.add_input(y);
            nd.add_input(dy);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SqrtGrad::new().build(y, dy, scope)`.
pub fn sqrt_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    y: O0,
    dy: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SqrtGrad::new().build(y, dy, scope)
}
/// Builder for the `Square` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Square {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Square {
    /// Creates a new `Square`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Square` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Square", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Square::new().build(x, scope)`.
pub fn square<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Square::new().build(x, scope)
}
/// Builder for the `SquaredDifference` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SquaredDifference {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SquaredDifference {
    /// Creates a new `SquaredDifference`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SquaredDifference` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SquaredDifference", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SquaredDifference::new().build(x, y, scope)`.
pub fn squared_difference<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SquaredDifference::new().build(x, y, scope)
}
/// Builder for the `Squeeze` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Squeeze {
    T: ::std::option::Option<crate::DataType>,
    squeeze_dims: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Squeeze {
    /// Creates a new `Squeeze`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `squeeze_dims` attribute.
    pub fn squeeze_dims<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.squeeze_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Squeeze` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Squeeze", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.squeeze_dims {
                nd.set_attr_int_list("squeeze_dims", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Squeeze::new().build(input, scope)`.
pub fn squeeze<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Squeeze::new().build(input, scope)
}
/// Builder for the `Stack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Stack {
    elem_type: ::std::option::Option<crate::DataType>,
    stack_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Stack {
    /// Creates a new `Stack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `elem_type` attribute.
    pub fn elem_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.elem_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `stack_name` attribute.
    pub fn stack_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.stack_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Stack` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Stack", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.elem_type {
                nd.set_attr_type("elem_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.stack_name {
                nd.set_attr_string("stack_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Stack::new().build(scope)`.
pub fn stack(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Stack::new().build(scope)
}
/// Builder for the `StackClose` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackClose {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StackClose {
    /// Creates a new `StackClose`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StackClose` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StackClose", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StackClose::new().build(handle, scope)`.
pub fn stack_close<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StackClose::new().build(handle, scope)
}
/// Builder for the `StackCloseV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackCloseV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StackCloseV2 {
    /// Creates a new `StackCloseV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StackCloseV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StackCloseV2", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StackCloseV2::new().build(handle, scope)`.
pub fn stack_close_v2<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StackCloseV2::new().build(handle, scope)
}
/// Builder for the `StackPop` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackPop {
    elem_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StackPop {
    /// Creates a new `StackPop`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `elem_type` attribute.
    pub fn elem_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.elem_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StackPop` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StackPop", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.elem_type {
                nd.set_attr_type("elem_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StackPop::new().build(handle, scope)`.
pub fn stack_pop<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StackPop::new().build(handle, scope)
}
/// Builder for the `StackPopV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackPopV2 {
    elem_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StackPopV2 {
    /// Creates a new `StackPopV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `elem_type` attribute.
    pub fn elem_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.elem_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StackPopV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StackPopV2", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.elem_type {
                nd.set_attr_type("elem_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StackPopV2::new().build(handle, scope)`.
pub fn stack_pop_v2<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StackPopV2::new().build(handle, scope)
}
/// Builder for the `StackPush` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackPush {
    T: ::std::option::Option<crate::DataType>,
    swap_memory: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StackPush {
    /// Creates a new `StackPush`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `swap_memory` attribute.
    pub fn swap_memory<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.swap_memory = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StackPush` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        elem: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), elem.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        elem: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StackPush", |nd| {
            nd.add_input(handle);
            nd.add_input(elem);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.swap_memory {
                nd.set_attr_bool("swap_memory", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StackPush::new().build(handle, elem, scope)`.
pub fn stack_push<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    elem: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StackPush::new().build(handle, elem, scope)
}
/// Builder for the `StackPushV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackPushV2 {
    T: ::std::option::Option<crate::DataType>,
    swap_memory: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StackPushV2 {
    /// Creates a new `StackPushV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `swap_memory` attribute.
    pub fn swap_memory<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.swap_memory = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StackPushV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        elem: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), elem.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        elem: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StackPushV2", |nd| {
            nd.add_input(handle);
            nd.add_input(elem);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.swap_memory {
                nd.set_attr_bool("swap_memory", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StackPushV2::new().build(handle, elem, scope)`.
pub fn stack_push_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    elem: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StackPushV2::new().build(handle, elem, scope)
}
/// Builder for the `StackV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StackV2 {
    elem_type: ::std::option::Option<crate::DataType>,
    stack_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StackV2 {
    /// Creates a new `StackV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `elem_type` attribute.
    pub fn elem_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.elem_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `stack_name` attribute.
    pub fn stack_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.stack_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StackV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        max_size: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(max_size.into(), scope)
    }

    fn build_impl(
        &self,
        max_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StackV2", |nd| {
            nd.add_input(max_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.elem_type {
                nd.set_attr_type("elem_type", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.stack_name {
                nd.set_attr_string("stack_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StackV2::new().build(max_size, scope)`.
pub fn stack_v2<O0: ::std::convert::Into<crate::Output>>(
    max_size: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StackV2::new().build(max_size, scope)
}
/// Builder for the `Stage` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Stage {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Stage {
    /// Creates a new `Stage`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Stage` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        values: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(values.into(), scope)
    }

    fn build_impl(
        &self,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Stage", |nd| {
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Stage::new().build(values, scope)`.
pub fn stage<O0: ::std::convert::Into<crate::Output>>(
    values: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Stage::new().build(values, scope)
}
/// Builder for the `StageClear` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StageClear {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StageClear {
    /// Creates a new `StageClear`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StageClear` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("StageClear", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StageClear::new().build(scope)`.
pub fn stage_clear(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    StageClear::new().build(scope)
}
/// Builder for the `StagePeek` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StagePeek {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StagePeek {
    /// Creates a new `StagePeek`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StagePeek` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        index: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(index.into(), scope)
    }

    fn build_impl(
        &self,
        index: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StagePeek", |nd| {
            nd.add_input(index);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StagePeek::new().build(index, scope)`.
pub fn stage_peek<O0: ::std::convert::Into<crate::Output>>(
    index: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StagePeek::new().build(index, scope)
}
/// Builder for the `StageSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StageSize {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StageSize {
    /// Creates a new `StageSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StageSize` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("StageSize", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StageSize::new().build(scope)`.
pub fn stage_size(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    StageSize::new().build(scope)
}
/// Builder for the `StatefulPartitionedCall` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulPartitionedCall {
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    f: ::std::option::Option<::std::string::String>,
    config: ::std::option::Option<::std::string::String>,
    config_proto: ::std::option::Option<::std::string::String>,
    executor_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatefulPartitionedCall {
    /// Creates a new `StatefulPartitionedCall`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config` attribute.
    pub fn config<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `config_proto` attribute.
    pub fn config_proto<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.config_proto = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `executor_type` attribute.
    pub fn executor_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.executor_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatefulPartitionedCall` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        args: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(args.into(), scope)
    }

    fn build_impl(
        &self,
        args: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatefulPartitionedCall", |nd| {
            nd.add_input(args);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config {
                nd.set_attr_string("config", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.config_proto {
                nd.set_attr_string("config_proto", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.executor_type {
                nd.set_attr_string("executor_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatefulPartitionedCall::new().build(args, scope)`.
pub fn stateful_partitioned_call<O0: ::std::convert::Into<crate::Output>>(
    args: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatefulPartitionedCall::new().build(args, scope)
}
/// Builder for the `StatefulRandomBinomial` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulRandomBinomial {
    S: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatefulRandomBinomial {
    /// Creates a new `StatefulRandomBinomial`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `S` attribute.
    pub fn S<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.S = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatefulRandomBinomial` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        algorithm: O1,
        shape: O2,
        counts: O3,
        probs: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            resource.into(),
            algorithm.into(),
            shape.into(),
            counts.into(),
            probs.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        algorithm: crate::Output,
        shape: crate::Output,
        counts: crate::Output,
        probs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatefulRandomBinomial", |nd| {
            nd.add_input(resource);
            nd.add_input(algorithm);
            nd.add_input(shape);
            nd.add_input(counts);
            nd.add_input(probs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.S {
                nd.set_attr_type("S", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatefulRandomBinomial::new().build(resource, algorithm, shape, counts, probs, scope)`.
pub fn stateful_random_binomial<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    algorithm: O1,
    shape: O2,
    counts: O3,
    probs: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatefulRandomBinomial::new().build(resource, algorithm, shape, counts, probs, scope)
}
/// Builder for the `StatefulStandardNormal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulStandardNormal {
    dtype: ::std::option::Option<crate::DataType>,
    shape_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatefulStandardNormal {
    /// Creates a new `StatefulStandardNormal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_dtype` attribute.
    pub fn shape_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatefulStandardNormal` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        shape: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatefulStandardNormal", |nd| {
            nd.add_input(resource);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_dtype {
                nd.set_attr_type("shape_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatefulStandardNormal::new().build(resource, shape, scope)`.
pub fn stateful_standard_normal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    shape: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatefulStandardNormal::new().build(resource, shape, scope)
}
/// Builder for the `StatefulStandardNormalV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulStandardNormalV2 {
    dtype: ::std::option::Option<crate::DataType>,
    shape_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatefulStandardNormalV2 {
    /// Creates a new `StatefulStandardNormalV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_dtype` attribute.
    pub fn shape_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatefulStandardNormalV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        algorithm: O1,
        shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), algorithm.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        algorithm: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatefulStandardNormalV2", |nd| {
            nd.add_input(resource);
            nd.add_input(algorithm);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_dtype {
                nd.set_attr_type("shape_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatefulStandardNormalV2::new().build(resource, algorithm, shape, scope)`.
pub fn stateful_standard_normal_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    algorithm: O1,
    shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatefulStandardNormalV2::new().build(resource, algorithm, shape, scope)
}
/// Builder for the `StatefulTruncatedNormal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulTruncatedNormal {
    dtype: ::std::option::Option<crate::DataType>,
    shape_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatefulTruncatedNormal {
    /// Creates a new `StatefulTruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_dtype` attribute.
    pub fn shape_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatefulTruncatedNormal` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        algorithm: O1,
        shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), algorithm.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        algorithm: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatefulTruncatedNormal", |nd| {
            nd.add_input(resource);
            nd.add_input(algorithm);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_dtype {
                nd.set_attr_type("shape_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatefulTruncatedNormal::new().build(resource, algorithm, shape, scope)`.
pub fn stateful_truncated_normal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    algorithm: O1,
    shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatefulTruncatedNormal::new().build(resource, algorithm, shape, scope)
}
/// Builder for the `StatefulUniform` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulUniform {
    dtype: ::std::option::Option<crate::DataType>,
    shape_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatefulUniform {
    /// Creates a new `StatefulUniform`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_dtype` attribute.
    pub fn shape_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatefulUniform` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        algorithm: O1,
        shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), algorithm.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        algorithm: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatefulUniform", |nd| {
            nd.add_input(resource);
            nd.add_input(algorithm);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_dtype {
                nd.set_attr_type("shape_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatefulUniform::new().build(resource, algorithm, shape, scope)`.
pub fn stateful_uniform<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    algorithm: O1,
    shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatefulUniform::new().build(resource, algorithm, shape, scope)
}
/// Builder for the `StatefulUniformFullInt` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulUniformFullInt {
    dtype: ::std::option::Option<crate::DataType>,
    shape_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatefulUniformFullInt {
    /// Creates a new `StatefulUniformFullInt`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_dtype` attribute.
    pub fn shape_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatefulUniformFullInt` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        algorithm: O1,
        shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), algorithm.into(), shape.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        algorithm: crate::Output,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatefulUniformFullInt", |nd| {
            nd.add_input(resource);
            nd.add_input(algorithm);
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_dtype {
                nd.set_attr_type("shape_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatefulUniformFullInt::new().build(resource, algorithm, shape, scope)`.
pub fn stateful_uniform_full_int<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    algorithm: O1,
    shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatefulUniformFullInt::new().build(resource, algorithm, shape, scope)
}
/// Builder for the `StatefulUniformInt` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatefulUniformInt {
    dtype: ::std::option::Option<crate::DataType>,
    shape_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatefulUniformInt {
    /// Creates a new `StatefulUniformInt`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_dtype` attribute.
    pub fn shape_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatefulUniformInt` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        resource: O0,
        algorithm: O1,
        shape: O2,
        minval: O3,
        maxval: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            resource.into(),
            algorithm.into(),
            shape.into(),
            minval.into(),
            maxval.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        algorithm: crate::Output,
        shape: crate::Output,
        minval: crate::Output,
        maxval: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatefulUniformInt", |nd| {
            nd.add_input(resource);
            nd.add_input(algorithm);
            nd.add_input(shape);
            nd.add_input(minval);
            nd.add_input(maxval);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_dtype {
                nd.set_attr_type("shape_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatefulUniformInt::new().build(resource, algorithm, shape, minval, maxval, scope)`.
pub fn stateful_uniform_int<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    resource: O0,
    algorithm: O1,
    shape: O2,
    minval: O3,
    maxval: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatefulUniformInt::new().build(resource, algorithm, shape, minval, maxval, scope)
}
/// Builder for the `StatelessIf` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessIf {
    Tcond: ::std::option::Option<crate::DataType>,
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    then_branch: ::std::option::Option<::std::string::String>,
    else_branch: ::std::option::Option<::std::string::String>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessIf {
    /// Creates a new `StatelessIf`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tcond` attribute.
    pub fn Tcond<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tcond = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `then_branch` attribute.
    pub fn then_branch<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.then_branch = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `else_branch` attribute.
    pub fn else_branch<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.else_branch = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessIf` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        cond: O0,
        input: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(cond.into(), input.into(), scope)
    }

    fn build_impl(
        &self,
        cond: crate::Output,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessIf", |nd| {
            nd.add_input(cond);
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tcond {
                nd.set_attr_type("Tcond", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.then_branch {
                nd.set_attr_string("then_branch", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.else_branch {
                nd.set_attr_string("else_branch", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessIf::new().build(cond, input, scope)`.
pub fn stateless_if<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    cond: O0,
    input: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessIf::new().build(cond, input, scope)
}
/// Builder for the `StatelessMultinomial` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessMultinomial {
    T: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    output_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessMultinomial {
    /// Creates a new `StatelessMultinomial`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_dtype` attribute.
    pub fn output_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessMultinomial` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        logits: O0,
        num_samples: O1,
        seed: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(logits.into(), num_samples.into(), seed.into(), scope)
    }

    fn build_impl(
        &self,
        logits: crate::Output,
        num_samples: crate::Output,
        seed: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessMultinomial", |nd| {
            nd.add_input(logits);
            nd.add_input(num_samples);
            nd.add_input(seed);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_dtype {
                nd.set_attr_type("output_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessMultinomial::new().build(logits, num_samples, seed, scope)`.
pub fn stateless_multinomial<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    logits: O0,
    num_samples: O1,
    seed: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessMultinomial::new().build(logits, num_samples, seed, scope)
}
/// Builder for the `StatelessParameterizedTruncatedNormal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessParameterizedTruncatedNormal {
    S: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessParameterizedTruncatedNormal {
    /// Creates a new `StatelessParameterizedTruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `S` attribute.
    pub fn S<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.S = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessParameterizedTruncatedNormal` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
        O5: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        means: O2,
        stddevs: O3,
        minvals: O4,
        maxvals: O5,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            shape.into(),
            seed.into(),
            means.into(),
            stddevs.into(),
            minvals.into(),
            maxvals.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        means: crate::Output,
        stddevs: crate::Output,
        minvals: crate::Output,
        maxvals: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessParameterizedTruncatedNormal", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            nd.add_input(means);
            nd.add_input(stddevs);
            nd.add_input(minvals);
            nd.add_input(maxvals);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.S {
                nd.set_attr_type("S", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessParameterizedTruncatedNormal::new().build(shape, seed, means, stddevs, minvals, maxvals, scope)`.
pub fn stateless_parameterized_truncated_normal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
    O5: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    means: O2,
    stddevs: O3,
    minvals: O4,
    maxvals: O5,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessParameterizedTruncatedNormal::new()
        .build(shape, seed, means, stddevs, minvals, maxvals, scope)
}
/// Builder for the `StatelessRandomBinomial` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomBinomial {
    S: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessRandomBinomial {
    /// Creates a new `StatelessRandomBinomial`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `S` attribute.
    pub fn S<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.S = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessRandomBinomial` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        counts: O2,
        probs: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            shape.into(),
            seed.into(),
            counts.into(),
            probs.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        counts: crate::Output,
        probs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessRandomBinomial", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            nd.add_input(counts);
            nd.add_input(probs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.S {
                nd.set_attr_type("S", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessRandomBinomial::new().build(shape, seed, counts, probs, scope)`.
pub fn stateless_random_binomial<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    counts: O2,
    probs: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessRandomBinomial::new().build(shape, seed, counts, probs, scope)
}
/// Builder for the `StatelessRandomGammaV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomGammaV2 {
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessRandomGammaV2 {
    /// Creates a new `StatelessRandomGammaV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessRandomGammaV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        alpha: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), seed.into(), alpha.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        alpha: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessRandomGammaV2", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            nd.add_input(alpha);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessRandomGammaV2::new().build(shape, seed, alpha, scope)`.
pub fn stateless_random_gamma_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    alpha: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessRandomGammaV2::new().build(shape, seed, alpha, scope)
}
/// Builder for the `StatelessRandomNormal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomNormal {
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessRandomNormal {
    /// Creates a new `StatelessRandomNormal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessRandomNormal` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), seed.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessRandomNormal", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessRandomNormal::new().build(shape, seed, scope)`.
pub fn stateless_random_normal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessRandomNormal::new().build(shape, seed, scope)
}
/// Builder for the `StatelessRandomPoisson` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomPoisson {
    Rtype: ::std::option::Option<crate::DataType>,
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessRandomPoisson {
    /// Creates a new `StatelessRandomPoisson`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Rtype` attribute.
    pub fn Rtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Rtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessRandomPoisson` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        lam: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), seed.into(), lam.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        lam: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessRandomPoisson", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            nd.add_input(lam);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Rtype {
                nd.set_attr_type("Rtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessRandomPoisson::new().build(shape, seed, lam, scope)`.
pub fn stateless_random_poisson<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    lam: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessRandomPoisson::new().build(shape, seed, lam, scope)
}
/// Builder for the `StatelessRandomUniform` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniform {
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessRandomUniform {
    /// Creates a new `StatelessRandomUniform`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessRandomUniform` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), seed.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessRandomUniform", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessRandomUniform::new().build(shape, seed, scope)`.
pub fn stateless_random_uniform<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessRandomUniform::new().build(shape, seed, scope)
}
/// Builder for the `StatelessRandomUniformFullInt` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniformFullInt {
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessRandomUniformFullInt {
    /// Creates a new `StatelessRandomUniformFullInt`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessRandomUniformFullInt` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), seed.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessRandomUniformFullInt", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessRandomUniformFullInt::new().build(shape, seed, scope)`.
pub fn stateless_random_uniform_full_int<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessRandomUniformFullInt::new().build(shape, seed, scope)
}
/// Builder for the `StatelessRandomUniformInt` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessRandomUniformInt {
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessRandomUniformInt {
    /// Creates a new `StatelessRandomUniformInt`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessRandomUniformInt` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        minval: O2,
        maxval: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            shape.into(),
            seed.into(),
            minval.into(),
            maxval.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        minval: crate::Output,
        maxval: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessRandomUniformInt", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            nd.add_input(minval);
            nd.add_input(maxval);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessRandomUniformInt::new().build(shape, seed, minval, maxval, scope)`.
pub fn stateless_random_uniform_int<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    minval: O2,
    maxval: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessRandomUniformInt::new().build(shape, seed, minval, maxval, scope)
}
/// Builder for the `StatelessTruncatedNormal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessTruncatedNormal {
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    Tseed: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessTruncatedNormal {
    /// Creates a new `StatelessTruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tseed` attribute.
    pub fn Tseed<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tseed = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessTruncatedNormal` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        seed: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), seed.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        seed: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessTruncatedNormal", |nd| {
            nd.add_input(shape);
            nd.add_input(seed);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tseed {
                nd.set_attr_type("Tseed", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessTruncatedNormal::new().build(shape, seed, scope)`.
pub fn stateless_truncated_normal<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    seed: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessTruncatedNormal::new().build(shape, seed, scope)
}
/// Builder for the `StatelessWhile` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatelessWhile {
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    cond: ::std::option::Option<::std::string::String>,
    body: ::std::option::Option<::std::string::String>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    parallel_iterations: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatelessWhile {
    /// Creates a new `StatelessWhile`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `cond` attribute.
    pub fn cond<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.cond = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `body` attribute.
    pub fn body<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.body = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `parallel_iterations` attribute.
    pub fn parallel_iterations<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.parallel_iterations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatelessWhile` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatelessWhile", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.cond {
                nd.set_attr_string("cond", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.body {
                nd.set_attr_string("body", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.parallel_iterations {
                nd.set_attr_int("parallel_iterations", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatelessWhile::new().build(input, scope)`.
pub fn stateless_while<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatelessWhile::new().build(input, scope)
}
/// Builder for the `StaticRegexFullMatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StaticRegexFullMatch {
    pattern: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StaticRegexFullMatch {
    /// Creates a new `StaticRegexFullMatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `pattern` attribute.
    pub fn pattern<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.pattern = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StaticRegexFullMatch` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StaticRegexFullMatch", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.pattern {
                nd.set_attr_string("pattern", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StaticRegexFullMatch::new().build(input, scope)`.
pub fn static_regex_full_match<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StaticRegexFullMatch::new().build(input, scope)
}
/// Builder for the `StaticRegexReplace` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StaticRegexReplace {
    pattern: ::std::option::Option<::std::string::String>,
    rewrite: ::std::option::Option<::std::string::String>,
    replace_global: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StaticRegexReplace {
    /// Creates a new `StaticRegexReplace`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `pattern` attribute.
    pub fn pattern<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.pattern = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `rewrite` attribute.
    pub fn rewrite<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.rewrite = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `replace_global` attribute.
    pub fn replace_global<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.replace_global = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StaticRegexReplace` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StaticRegexReplace", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.pattern {
                nd.set_attr_string("pattern", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.rewrite {
                nd.set_attr_string("rewrite", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.replace_global {
                nd.set_attr_bool("replace_global", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StaticRegexReplace::new().build(input, scope)`.
pub fn static_regex_replace<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StaticRegexReplace::new().build(input, scope)
}
/// Builder for the `StatsAggregatorHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatsAggregatorHandle {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatsAggregatorHandle {
    /// Creates a new `StatsAggregatorHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatsAggregatorHandle` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("StatsAggregatorHandle", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatsAggregatorHandle::new().build(scope)`.
pub fn stats_aggregator_handle(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    StatsAggregatorHandle::new().build(scope)
}
/// Builder for the `StatsAggregatorHandleV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatsAggregatorHandleV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatsAggregatorHandleV2 {
    /// Creates a new `StatsAggregatorHandleV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatsAggregatorHandleV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("StatsAggregatorHandleV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatsAggregatorHandleV2::new().build(scope)`.
pub fn stats_aggregator_handle_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    StatsAggregatorHandleV2::new().build(scope)
}
/// Builder for the `StatsAggregatorSetSummaryWriter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatsAggregatorSetSummaryWriter {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatsAggregatorSetSummaryWriter {
    /// Creates a new `StatsAggregatorSetSummaryWriter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatsAggregatorSetSummaryWriter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        stats_aggregator: O0,
        summary: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(stats_aggregator.into(), summary.into(), scope)
    }

    fn build_impl(
        &self,
        stats_aggregator: crate::Output,
        summary: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatsAggregatorSetSummaryWriter", |nd| {
            nd.add_input(stats_aggregator);
            nd.add_input(summary);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatsAggregatorSetSummaryWriter::new().build(stats_aggregator, summary, scope)`.
pub fn stats_aggregator_set_summary_writer<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    stats_aggregator: O0,
    summary: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatsAggregatorSetSummaryWriter::new().build(stats_aggregator, summary, scope)
}
/// Builder for the `StatsAggregatorSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StatsAggregatorSummary {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StatsAggregatorSummary {
    /// Creates a new `StatsAggregatorSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StatsAggregatorSummary` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        iterator: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(iterator.into(), scope)
    }

    fn build_impl(
        &self,
        iterator: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StatsAggregatorSummary", |nd| {
            nd.add_input(iterator);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StatsAggregatorSummary::new().build(iterator, scope)`.
pub fn stats_aggregator_summary<O0: ::std::convert::Into<crate::Output>>(
    iterator: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StatsAggregatorSummary::new().build(iterator, scope)
}
/// Builder for the `StopGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StopGradient {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StopGradient {
    /// Creates a new `StopGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StopGradient` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StopGradient", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StopGradient::new().build(input, scope)`.
pub fn stop_gradient<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StopGradient::new().build(input, scope)
}
/// Builder for the `StridedSlice` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StridedSlice {
    T: ::std::option::Option<crate::DataType>,
    Index: ::std::option::Option<crate::DataType>,
    begin_mask: ::std::option::Option<i64>,
    end_mask: ::std::option::Option<i64>,
    ellipsis_mask: ::std::option::Option<i64>,
    new_axis_mask: ::std::option::Option<i64>,
    shrink_axis_mask: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StridedSlice {
    /// Creates a new `StridedSlice`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Index` attribute.
    pub fn Index<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `begin_mask` attribute.
    pub fn begin_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.begin_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `end_mask` attribute.
    pub fn end_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.end_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ellipsis_mask` attribute.
    pub fn ellipsis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.ellipsis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `new_axis_mask` attribute.
    pub fn new_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.new_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shrink_axis_mask` attribute.
    pub fn shrink_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shrink_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StridedSlice` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        begin: O1,
        end: O2,
        strides: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            begin.into(),
            end.into(),
            strides.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        begin: crate::Output,
        end: crate::Output,
        strides: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StridedSlice", |nd| {
            nd.add_input(input);
            nd.add_input(begin);
            nd.add_input(end);
            nd.add_input(strides);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Index {
                nd.set_attr_type("Index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.begin_mask {
                nd.set_attr_int("begin_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.end_mask {
                nd.set_attr_int("end_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ellipsis_mask {
                nd.set_attr_int("ellipsis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.new_axis_mask {
                nd.set_attr_int("new_axis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shrink_axis_mask {
                nd.set_attr_int("shrink_axis_mask", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StridedSlice::new().build(input, begin, end, strides, scope)`.
pub fn strided_slice<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    begin: O1,
    end: O2,
    strides: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StridedSlice::new().build(input, begin, end, strides, scope)
}
/// Builder for the `StridedSliceAssign` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StridedSliceAssign {
    T: ::std::option::Option<crate::DataType>,
    Index: ::std::option::Option<crate::DataType>,
    begin_mask: ::std::option::Option<i64>,
    end_mask: ::std::option::Option<i64>,
    ellipsis_mask: ::std::option::Option<i64>,
    new_axis_mask: ::std::option::Option<i64>,
    shrink_axis_mask: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StridedSliceAssign {
    /// Creates a new `StridedSliceAssign`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Index` attribute.
    pub fn Index<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `begin_mask` attribute.
    pub fn begin_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.begin_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `end_mask` attribute.
    pub fn end_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.end_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ellipsis_mask` attribute.
    pub fn ellipsis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.ellipsis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `new_axis_mask` attribute.
    pub fn new_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.new_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shrink_axis_mask` attribute.
    pub fn shrink_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shrink_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StridedSliceAssign` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        ref_: O0,
        begin: O1,
        end: O2,
        strides: O3,
        value: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            ref_.into(),
            begin.into(),
            end.into(),
            strides.into(),
            value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        ref_: crate::Output,
        begin: crate::Output,
        end: crate::Output,
        strides: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StridedSliceAssign", |nd| {
            nd.add_input(ref_);
            nd.add_input(begin);
            nd.add_input(end);
            nd.add_input(strides);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Index {
                nd.set_attr_type("Index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.begin_mask {
                nd.set_attr_int("begin_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.end_mask {
                nd.set_attr_int("end_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ellipsis_mask {
                nd.set_attr_int("ellipsis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.new_axis_mask {
                nd.set_attr_int("new_axis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shrink_axis_mask {
                nd.set_attr_int("shrink_axis_mask", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StridedSliceAssign::new().build(ref_, begin, end, strides, value, scope)`.
pub fn strided_slice_assign<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    ref_: O0,
    begin: O1,
    end: O2,
    strides: O3,
    value: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StridedSliceAssign::new().build(ref_, begin, end, strides, value, scope)
}
/// Builder for the `StridedSliceGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StridedSliceGrad {
    T: ::std::option::Option<crate::DataType>,
    Index: ::std::option::Option<crate::DataType>,
    begin_mask: ::std::option::Option<i64>,
    end_mask: ::std::option::Option<i64>,
    ellipsis_mask: ::std::option::Option<i64>,
    new_axis_mask: ::std::option::Option<i64>,
    shrink_axis_mask: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StridedSliceGrad {
    /// Creates a new `StridedSliceGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Index` attribute.
    pub fn Index<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `begin_mask` attribute.
    pub fn begin_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.begin_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `end_mask` attribute.
    pub fn end_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.end_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ellipsis_mask` attribute.
    pub fn ellipsis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.ellipsis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `new_axis_mask` attribute.
    pub fn new_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.new_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shrink_axis_mask` attribute.
    pub fn shrink_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shrink_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StridedSliceGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        shape: O0,
        begin: O1,
        end: O2,
        strides: O3,
        dy: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            shape.into(),
            begin.into(),
            end.into(),
            strides.into(),
            dy.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        begin: crate::Output,
        end: crate::Output,
        strides: crate::Output,
        dy: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StridedSliceGrad", |nd| {
            nd.add_input(shape);
            nd.add_input(begin);
            nd.add_input(end);
            nd.add_input(strides);
            nd.add_input(dy);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Index {
                nd.set_attr_type("Index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.begin_mask {
                nd.set_attr_int("begin_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.end_mask {
                nd.set_attr_int("end_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ellipsis_mask {
                nd.set_attr_int("ellipsis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.new_axis_mask {
                nd.set_attr_int("new_axis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shrink_axis_mask {
                nd.set_attr_int("shrink_axis_mask", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StridedSliceGrad::new().build(shape, begin, end, strides, dy, scope)`.
pub fn strided_slice_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    shape: O0,
    begin: O1,
    end: O2,
    strides: O3,
    dy: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StridedSliceGrad::new().build(shape, begin, end, strides, dy, scope)
}
/// Builder for the `StringFormat` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringFormat {
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    template: ::std::option::Option<::std::string::String>,
    placeholder: ::std::option::Option<::std::string::String>,
    summarize: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringFormat {
    /// Creates a new `StringFormat`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `template` attribute.
    pub fn template<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.template = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `placeholder` attribute.
    pub fn placeholder<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.placeholder = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `summarize` attribute.
    pub fn summarize<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.summarize = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringFormat` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringFormat", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.template {
                nd.set_attr_string("template", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.placeholder {
                nd.set_attr_string("placeholder", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.summarize {
                nd.set_attr_int("summarize", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringFormat::new().build(inputs, scope)`.
pub fn string_format<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringFormat::new().build(inputs, scope)
}
/// Builder for the `StringJoin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringJoin {
    N: ::std::option::Option<i64>,
    separator: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringJoin {
    /// Creates a new `StringJoin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `separator` attribute.
    pub fn separator<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.separator = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringJoin` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringJoin", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.separator {
                nd.set_attr_string("separator", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringJoin::new().build(inputs, scope)`.
pub fn string_join<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringJoin::new().build(inputs, scope)
}
/// Builder for the `StringLength` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringLength {
    unit: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringLength {
    /// Creates a new `StringLength`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `unit` attribute.
    pub fn unit<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.unit = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringLength` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringLength", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.unit {
                nd.set_attr_string("unit", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringLength::new().build(input, scope)`.
pub fn string_length<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringLength::new().build(input, scope)
}
/// Builder for the `StringLower` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringLower {
    encoding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringLower {
    /// Creates a new `StringLower`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `encoding` attribute.
    pub fn encoding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.encoding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringLower` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringLower", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.encoding {
                nd.set_attr_string("encoding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringLower::new().build(input, scope)`.
pub fn string_lower<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringLower::new().build(input, scope)
}
/// Builder for the `StringNGrams` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringNGrams {
    separator: ::std::option::Option<::std::string::String>,
    ngram_widths: ::std::option::Option<::std::vec::Vec<i64>>,
    left_pad: ::std::option::Option<::std::string::String>,
    right_pad: ::std::option::Option<::std::string::String>,
    pad_width: ::std::option::Option<i64>,
    preserve_short_sequences: ::std::option::Option<bool>,
    Tsplits: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringNGrams {
    /// Creates a new `StringNGrams`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `separator` attribute.
    pub fn separator<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.separator = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ngram_widths` attribute.
    pub fn ngram_widths<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.ngram_widths = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `left_pad` attribute.
    pub fn left_pad<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.left_pad = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `right_pad` attribute.
    pub fn right_pad<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.right_pad = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `pad_width` attribute.
    pub fn pad_width<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.pad_width = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `preserve_short_sequences` attribute.
    pub fn preserve_short_sequences<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.preserve_short_sequences = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringNGrams` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        data_splits: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), data_splits.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        data_splits: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringNGrams", |nd| {
            nd.add_input(data);
            nd.add_input(data_splits);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.separator {
                nd.set_attr_string("separator", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ngram_widths {
                nd.set_attr_int_list("ngram_widths", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.left_pad {
                nd.set_attr_string("left_pad", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.right_pad {
                nd.set_attr_string("right_pad", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.pad_width {
                nd.set_attr_int("pad_width", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.preserve_short_sequences {
                nd.set_attr_bool("preserve_short_sequences", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringNGrams::new().build(data, data_splits, scope)`.
pub fn string_ngrams<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    data_splits: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringNGrams::new().build(data, data_splits, scope)
}
/// Builder for the `StringSplit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringSplit {
    skip_empty: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringSplit {
    /// Creates a new `StringSplit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `skip_empty` attribute.
    pub fn skip_empty<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.skip_empty = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringSplit` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        delimiter: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), delimiter.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        delimiter: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringSplit", |nd| {
            nd.add_input(input);
            nd.add_input(delimiter);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.skip_empty {
                nd.set_attr_bool("skip_empty", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringSplit::new().build(input, delimiter, scope)`.
pub fn string_split<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    delimiter: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringSplit::new().build(input, delimiter, scope)
}
/// Builder for the `StringSplitV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringSplitV2 {
    maxsplit: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringSplitV2 {
    /// Creates a new `StringSplitV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `maxsplit` attribute.
    pub fn maxsplit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.maxsplit = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringSplitV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        sep: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), sep.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        sep: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringSplitV2", |nd| {
            nd.add_input(input);
            nd.add_input(sep);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.maxsplit {
                nd.set_attr_int("maxsplit", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringSplitV2::new().build(input, sep, scope)`.
pub fn string_split_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    sep: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringSplitV2::new().build(input, sep, scope)
}
/// Builder for the `StringStrip` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringStrip {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringStrip {
    /// Creates a new `StringStrip`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringStrip` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringStrip", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringStrip::new().build(input, scope)`.
pub fn string_strip<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringStrip::new().build(input, scope)
}
/// Builder for the `StringToHashBucket` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringToHashBucket {
    num_buckets: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringToHashBucket {
    /// Creates a new `StringToHashBucket`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_buckets` attribute.
    pub fn num_buckets<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringToHashBucket` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        string_tensor: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(string_tensor.into(), scope)
    }

    fn build_impl(
        &self,
        string_tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringToHashBucket", |nd| {
            nd.add_input(string_tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_buckets {
                nd.set_attr_int("num_buckets", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringToHashBucket::new().build(string_tensor, scope)`.
pub fn string_to_hash_bucket<O0: ::std::convert::Into<crate::Output>>(
    string_tensor: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringToHashBucket::new().build(string_tensor, scope)
}
/// Builder for the `StringToHashBucketFast` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringToHashBucketFast {
    num_buckets: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringToHashBucketFast {
    /// Creates a new `StringToHashBucketFast`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_buckets` attribute.
    pub fn num_buckets<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringToHashBucketFast` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringToHashBucketFast", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_buckets {
                nd.set_attr_int("num_buckets", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringToHashBucketFast::new().build(input, scope)`.
pub fn string_to_hash_bucket_fast<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringToHashBucketFast::new().build(input, scope)
}
/// Builder for the `StringToHashBucketStrong` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringToHashBucketStrong {
    num_buckets: ::std::option::Option<i64>,
    key: ::std::option::Option<::std::vec::Vec<i64>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringToHashBucketStrong {
    /// Creates a new `StringToHashBucketStrong`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_buckets` attribute.
    pub fn num_buckets<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_buckets = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `key` attribute.
    pub fn key<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.key = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringToHashBucketStrong` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringToHashBucketStrong", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_buckets {
                nd.set_attr_int("num_buckets", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.key {
                nd.set_attr_int_list("key", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringToHashBucketStrong::new().build(input, scope)`.
pub fn string_to_hash_bucket_strong<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringToHashBucketStrong::new().build(input, scope)
}
/// Builder for the `StringToNumber` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringToNumber {
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringToNumber {
    /// Creates a new `StringToNumber`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringToNumber` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        string_tensor: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(string_tensor.into(), scope)
    }

    fn build_impl(
        &self,
        string_tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringToNumber", |nd| {
            nd.add_input(string_tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringToNumber::new().build(string_tensor, scope)`.
pub fn string_to_number<O0: ::std::convert::Into<crate::Output>>(
    string_tensor: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringToNumber::new().build(string_tensor, scope)
}
/// Builder for the `StringUpper` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct StringUpper {
    encoding: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl StringUpper {
    /// Creates a new `StringUpper`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `encoding` attribute.
    pub fn encoding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.encoding = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `StringUpper` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("StringUpper", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.encoding {
                nd.set_attr_string("encoding", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `StringUpper::new().build(input, scope)`.
pub fn string_upper<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    StringUpper::new().build(input, scope)
}
/// Builder for the `Sub` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sub {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Sub {
    /// Creates a new `Sub`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Sub` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Sub", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Sub::new().build(x, y, scope)`.
pub fn sub<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Sub::new().build(x, y, scope)
}
/// Builder for the `Substr` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Substr {
    T: ::std::option::Option<crate::DataType>,
    unit: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Substr {
    /// Creates a new `Substr`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `unit` attribute.
    pub fn unit<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.unit = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Substr` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        pos: O1,
        len: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), pos.into(), len.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        pos: crate::Output,
        len: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Substr", |nd| {
            nd.add_input(input);
            nd.add_input(pos);
            nd.add_input(len);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.unit {
                nd.set_attr_string("unit", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Substr::new().build(input, pos, len, scope)`.
pub fn substr<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    pos: O1,
    len: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Substr::new().build(input, pos, len, scope)
}
/// Builder for the `Sum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Sum {
    keep_dims: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Sum {
    /// Creates a new `Sum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `keep_dims` attribute.
    pub fn keep_dims<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.keep_dims = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Sum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        reduction_indices: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), reduction_indices.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        reduction_indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Sum", |nd| {
            nd.add_input(input);
            nd.add_input(reduction_indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.keep_dims {
                nd.set_attr_bool("keep_dims", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Sum::new().build(input, reduction_indices, scope)`.
pub fn sum<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    reduction_indices: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Sum::new().build(input, reduction_indices, scope)
}
/// Builder for the `SummaryWriter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SummaryWriter {
    shared_name: ::std::option::Option<::std::string::String>,
    container: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SummaryWriter {
    /// Creates a new `SummaryWriter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SummaryWriter` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("SummaryWriter", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SummaryWriter::new().build(scope)`.
pub fn summary_writer(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    SummaryWriter::new().build(scope)
}
/// Builder for the `Svd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Svd {
    compute_uv: ::std::option::Option<bool>,
    full_matrices: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Svd {
    /// Creates a new `Svd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `compute_uv` attribute.
    pub fn compute_uv<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.compute_uv = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `full_matrices` attribute.
    pub fn full_matrices<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.full_matrices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Svd` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Svd", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.compute_uv {
                nd.set_attr_bool("compute_uv", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.full_matrices {
                nd.set_attr_bool("full_matrices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Svd::new().build(input, scope)`.
pub fn svd<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Svd::new().build(input, scope)
}
/// Builder for the `Switch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Switch {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Switch {
    /// Creates a new `Switch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Switch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        pred: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), pred.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        pred: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Switch", |nd| {
            nd.add_input(data);
            nd.add_input(pred);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Switch::new().build(data, pred, scope)`.
pub fn switch<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    data: O0,
    pred: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Switch::new().build(data, pred, scope)
}
/// Builder for the `SymbolicGradient` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct SymbolicGradient {
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    f: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl SymbolicGradient {
    /// Creates a new `SymbolicGradient`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `SymbolicGradient` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("SymbolicGradient", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `SymbolicGradient::new().build(input, scope)`.
pub fn symbolic_gradient<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    SymbolicGradient::new().build(input, scope)
}
/// Builder for the `TFRecordDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TFRecordDataset {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TFRecordDataset {
    /// Creates a new `TFRecordDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TFRecordDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filenames: O0,
        compression_type: O1,
        buffer_size: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            filenames.into(),
            compression_type.into(),
            buffer_size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        filenames: crate::Output,
        compression_type: crate::Output,
        buffer_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TFRecordDataset", |nd| {
            nd.add_input(filenames);
            nd.add_input(compression_type);
            nd.add_input(buffer_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TFRecordDataset::new().build(filenames, compression_type, buffer_size, scope)`.
pub fn tfrecord_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    filenames: O0,
    compression_type: O1,
    buffer_size: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TFRecordDataset::new().build(filenames, compression_type, buffer_size, scope)
}
/// Builder for the `TFRecordReader` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TFRecordReader {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    compression_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TFRecordReader {
    /// Creates a new `TFRecordReader`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `compression_type` attribute.
    pub fn compression_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compression_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TFRecordReader` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TFRecordReader", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.compression_type {
                nd.set_attr_string("compression_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TFRecordReader::new().build(scope)`.
pub fn tfrecord_reader(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    TFRecordReader::new().build(scope)
}
/// Builder for the `TFRecordReaderV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TFRecordReaderV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    compression_type: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TFRecordReaderV2 {
    /// Creates a new `TFRecordReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `compression_type` attribute.
    pub fn compression_type<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.compression_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TFRecordReaderV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TFRecordReaderV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.compression_type {
                nd.set_attr_string("compression_type", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TFRecordReaderV2::new().build(scope)`.
pub fn tfrecord_reader_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    TFRecordReaderV2::new().build(scope)
}
/// Builder for the `TPUCompilationResult` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUCompilationResult {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TPUCompilationResult {
    /// Creates a new `TPUCompilationResult`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TPUCompilationResult` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TPUCompilationResult", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TPUCompilationResult::new().build(scope)`.
pub fn tpucompilation_result(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    TPUCompilationResult::new().build(scope)
}
/// Builder for the `TPUEmbeddingActivations` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUEmbeddingActivations {
    table_id: ::std::option::Option<i64>,
    lookup_id: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TPUEmbeddingActivations {
    /// Creates a new `TPUEmbeddingActivations`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `table_id` attribute.
    pub fn table_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.table_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `lookup_id` attribute.
    pub fn lookup_id<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.lookup_id = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TPUEmbeddingActivations` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        embedding_variable: O0,
        sliced_activations: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(embedding_variable.into(), sliced_activations.into(), scope)
    }

    fn build_impl(
        &self,
        embedding_variable: crate::Output,
        sliced_activations: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TPUEmbeddingActivations", |nd| {
            nd.add_input(embedding_variable);
            nd.add_input(sliced_activations);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.table_id {
                nd.set_attr_int("table_id", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.lookup_id {
                nd.set_attr_int("lookup_id", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TPUEmbeddingActivations::new().build(embedding_variable, sliced_activations, scope)`.
pub fn tpuembedding_activations<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    embedding_variable: O0,
    sliced_activations: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TPUEmbeddingActivations::new().build(embedding_variable, sliced_activations, scope)
}
/// Builder for the `TPUOrdinalSelector` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUOrdinalSelector {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TPUOrdinalSelector {
    /// Creates a new `TPUOrdinalSelector`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TPUOrdinalSelector` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TPUOrdinalSelector", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TPUOrdinalSelector::new().build(scope)`.
pub fn tpuordinal_selector(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    TPUOrdinalSelector::new().build(scope)
}
/// Builder for the `TPUPartitionedCall` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUPartitionedCall {
    Tin: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    Tout: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    f: ::std::option::Option<::std::string::String>,
    autotuner_thresh: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TPUPartitionedCall {
    /// Creates a new `TPUPartitionedCall`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tin` attribute.
    pub fn Tin<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tin = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tout` attribute.
    pub fn Tout<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tout = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `f` attribute.
    pub fn f<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.f = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `autotuner_thresh` attribute.
    pub fn autotuner_thresh<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.autotuner_thresh = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TPUPartitionedCall` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        args: O0,
        device_ordinal: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(args.into(), device_ordinal.into(), scope)
    }

    fn build_impl(
        &self,
        args: crate::Output,
        device_ordinal: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TPUPartitionedCall", |nd| {
            nd.add_input(args);
            nd.add_input(device_ordinal);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tin {
                nd.set_attr_type_list("Tin", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tout {
                nd.set_attr_type_list("Tout", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.f {
                nd.set_attr_string("f", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.autotuner_thresh {
                nd.set_attr_int("autotuner_thresh", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TPUPartitionedCall::new().build(args, device_ordinal, scope)`.
pub fn tpupartitioned_call<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    args: O0,
    device_ordinal: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TPUPartitionedCall::new().build(args, device_ordinal, scope)
}
/// Builder for the `TPUReplicateMetadata` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUReplicateMetadata {
    num_replicas: ::std::option::Option<i64>,
    num_cores_per_replica: ::std::option::Option<i64>,
    topology: ::std::option::Option<::std::string::String>,
    use_tpu: ::std::option::Option<bool>,
    device_assignment: ::std::option::Option<::std::vec::Vec<i64>>,
    computation_shape: ::std::option::Option<::std::vec::Vec<i64>>,
    host_compute_core: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    padding_map: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    step_marker_location: ::std::option::Option<::std::string::String>,
    allow_soft_placement: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TPUReplicateMetadata {
    /// Creates a new `TPUReplicateMetadata`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_replicas` attribute.
    pub fn num_replicas<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_replicas = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_cores_per_replica` attribute.
    pub fn num_cores_per_replica<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.num_cores_per_replica = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `topology` attribute.
    pub fn topology<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.topology = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `use_tpu` attribute.
    pub fn use_tpu<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.use_tpu = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `device_assignment` attribute.
    pub fn device_assignment<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.device_assignment = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `computation_shape` attribute.
    pub fn computation_shape<ArgType: ::std::convert::Into<::std::vec::Vec<i64>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.computation_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `host_compute_core` attribute.
    pub fn host_compute_core<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.host_compute_core = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `padding_map` attribute.
    pub fn padding_map<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.padding_map = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `step_marker_location` attribute.
    pub fn step_marker_location<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.step_marker_location = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `allow_soft_placement` attribute.
    pub fn allow_soft_placement<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.allow_soft_placement = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TPUReplicateMetadata` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TPUReplicateMetadata", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_replicas {
                nd.set_attr_int("num_replicas", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_cores_per_replica {
                nd.set_attr_int("num_cores_per_replica", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.topology {
                nd.set_attr_string("topology", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.use_tpu {
                nd.set_attr_bool("use_tpu", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.device_assignment {
                nd.set_attr_int_list("device_assignment", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.computation_shape {
                nd.set_attr_int_list("computation_shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.host_compute_core {
                nd.set_attr_string_list("host_compute_core", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.padding_map {
                nd.set_attr_string_list("padding_map", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.step_marker_location {
                nd.set_attr_string("step_marker_location", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.allow_soft_placement {
                nd.set_attr_bool("allow_soft_placement", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TPUReplicateMetadata::new().build(scope)`.
pub fn tpureplicate_metadata(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    TPUReplicateMetadata::new().build(scope)
}
/// Builder for the `TPUReplicatedInput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUReplicatedInput {
    N: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    is_mirrored_variable: ::std::option::Option<bool>,
    index: ::std::option::Option<i64>,
    is_packed: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TPUReplicatedInput {
    /// Creates a new `TPUReplicatedInput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_mirrored_variable` attribute.
    pub fn is_mirrored_variable<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.is_mirrored_variable = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `index` attribute.
    pub fn index<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `is_packed` attribute.
    pub fn is_packed<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.is_packed = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TPUReplicatedInput` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        inputs: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(inputs.into(), scope)
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TPUReplicatedInput", |nd| {
            nd.add_input(inputs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_mirrored_variable {
                nd.set_attr_bool("is_mirrored_variable", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.index {
                nd.set_attr_int("index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.is_packed {
                nd.set_attr_bool("is_packed", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TPUReplicatedInput::new().build(inputs, scope)`.
pub fn tpureplicated_input<O0: ::std::convert::Into<crate::Output>>(
    inputs: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TPUReplicatedInput::new().build(inputs, scope)
}
/// Builder for the `TPUReplicatedOutput` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TPUReplicatedOutput {
    num_replicas: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TPUReplicatedOutput {
    /// Creates a new `TPUReplicatedOutput`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_replicas` attribute.
    pub fn num_replicas<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_replicas = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TPUReplicatedOutput` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TPUReplicatedOutput", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_replicas {
                nd.set_attr_int("num_replicas", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TPUReplicatedOutput::new().build(input, scope)`.
pub fn tpureplicated_output<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TPUReplicatedOutput::new().build(input, scope)
}
/// Builder for the `TakeDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TakeDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TakeDataset {
    /// Creates a new `TakeDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TakeDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        count: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), count.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        count: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TakeDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(count);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TakeDataset::new().build(input_dataset, count, scope)`.
pub fn take_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    count: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TakeDataset::new().build(input_dataset, count, scope)
}
/// Builder for the `TakeManySparseFromTensorsMap` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TakeManySparseFromTensorsMap {
    dtype: ::std::option::Option<crate::DataType>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TakeManySparseFromTensorsMap {
    /// Creates a new `TakeManySparseFromTensorsMap`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TakeManySparseFromTensorsMap` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        sparse_handles: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(sparse_handles.into(), scope)
    }

    fn build_impl(
        &self,
        sparse_handles: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TakeManySparseFromTensorsMap", |nd| {
            nd.add_input(sparse_handles);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TakeManySparseFromTensorsMap::new().build(sparse_handles, scope)`.
pub fn take_many_sparse_from_tensors_map<O0: ::std::convert::Into<crate::Output>>(
    sparse_handles: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TakeManySparseFromTensorsMap::new().build(sparse_handles, scope)
}
/// Builder for the `TakeWhileDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TakeWhileDataset {
    predicate: ::std::option::Option<::std::string::String>,
    Targuments: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TakeWhileDataset {
    /// Creates a new `TakeWhileDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `predicate` attribute.
    pub fn predicate<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.predicate = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Targuments` attribute.
    pub fn Targuments<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Targuments = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TakeWhileDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        other_arguments: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), other_arguments.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        other_arguments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TakeWhileDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(other_arguments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.predicate {
                nd.set_attr_string("predicate", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Targuments {
                nd.set_attr_type_list("Targuments", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TakeWhileDataset::new().build(input_dataset, other_arguments, scope)`.
pub fn take_while_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    other_arguments: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TakeWhileDataset::new().build(input_dataset, other_arguments, scope)
}
/// Builder for the `Tan` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Tan {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Tan {
    /// Creates a new `Tan`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Tan` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Tan", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Tan::new().build(x, scope)`.
pub fn tan<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Tan::new().build(x, scope)
}
/// Builder for the `Tanh` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Tanh {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Tanh {
    /// Creates a new `Tanh`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Tanh` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Tanh", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Tanh::new().build(x, scope)`.
pub fn tanh<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Tanh::new().build(x, scope)
}
/// Builder for the `TanhGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TanhGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TanhGrad {
    /// Creates a new `TanhGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TanhGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        y: O0,
        dy: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(y.into(), dy.into(), scope)
    }

    fn build_impl(
        &self,
        y: crate::Output,
        dy: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TanhGrad", |nd| {
            nd.add_input(y);
            nd.add_input(dy);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TanhGrad::new().build(y, dy, scope)`.
pub fn tanh_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    y: O0,
    dy: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TanhGrad::new().build(y, dy, scope)
}
/// Builder for the `TemporaryVariable` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TemporaryVariable {
    shape: ::std::option::Option<crate::Shape>,
    dtype: ::std::option::Option<crate::DataType>,
    var_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TemporaryVariable {
    /// Creates a new `TemporaryVariable`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `var_name` attribute.
    pub fn var_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.var_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TemporaryVariable` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TemporaryVariable", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.var_name {
                nd.set_attr_string("var_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TemporaryVariable::new().build(scope)`.
pub fn temporary_variable(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    TemporaryVariable::new().build(scope)
}
/// Builder for the `TensorArray` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArray {
    dtype: ::std::option::Option<crate::DataType>,
    dynamic_size: ::std::option::Option<bool>,
    clear_after_read: ::std::option::Option<bool>,
    tensor_array_name: ::std::option::Option<::std::string::String>,
    element_shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArray {
    /// Creates a new `TensorArray`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dynamic_size` attribute.
    pub fn dynamic_size<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.dynamic_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `clear_after_read` attribute.
    pub fn clear_after_read<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.clear_after_read = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_array_name` attribute.
    pub fn tensor_array_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_array_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape` attribute.
    pub fn element_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArray` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        size: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(size.into(), scope)
    }

    fn build_impl(
        &self,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArray", |nd| {
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dynamic_size {
                nd.set_attr_bool("dynamic_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.clear_after_read {
                nd.set_attr_bool("clear_after_read", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_array_name {
                nd.set_attr_string("tensor_array_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape {
                nd.set_attr_shape("element_shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArray::new().build(size, scope)`.
pub fn tensor_array<O0: ::std::convert::Into<crate::Output>>(
    size: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArray::new().build(size, scope)
}
/// Builder for the `TensorArrayClose` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayClose {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayClose {
    /// Creates a new `TensorArrayClose`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayClose` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayClose", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayClose::new().build(handle, scope)`.
pub fn tensor_array_close<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayClose::new().build(handle, scope)
}
/// Builder for the `TensorArrayCloseV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayCloseV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayCloseV2 {
    /// Creates a new `TensorArrayCloseV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayCloseV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayCloseV2", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayCloseV2::new().build(handle, scope)`.
pub fn tensor_array_close_v2<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayCloseV2::new().build(handle, scope)
}
/// Builder for the `TensorArrayCloseV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayCloseV3 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayCloseV3 {
    /// Creates a new `TensorArrayCloseV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayCloseV3` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayCloseV3", |nd| {
            nd.add_input(handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayCloseV3::new().build(handle, scope)`.
pub fn tensor_array_close_v3<O0: ::std::convert::Into<crate::Output>>(
    handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayCloseV3::new().build(handle, scope)
}
/// Builder for the `TensorArrayConcat` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayConcat {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape_except0: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayConcat {
    /// Creates a new `TensorArrayConcat`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape_except0` attribute.
    pub fn element_shape_except0<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape_except0 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayConcat` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayConcat", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape_except0 {
                nd.set_attr_shape("element_shape_except0", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayConcat::new().build(handle, flow_in, scope)`.
pub fn tensor_array_concat<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayConcat::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArrayConcatV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayConcatV2 {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape_except0: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayConcatV2 {
    /// Creates a new `TensorArrayConcatV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape_except0` attribute.
    pub fn element_shape_except0<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape_except0 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayConcatV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayConcatV2", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape_except0 {
                nd.set_attr_shape("element_shape_except0", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayConcatV2::new().build(handle, flow_in, scope)`.
pub fn tensor_array_concat_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayConcatV2::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArrayConcatV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayConcatV3 {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape_except0: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayConcatV3 {
    /// Creates a new `TensorArrayConcatV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape_except0` attribute.
    pub fn element_shape_except0<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape_except0 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayConcatV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayConcatV3", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape_except0 {
                nd.set_attr_shape("element_shape_except0", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayConcatV3::new().build(handle, flow_in, scope)`.
pub fn tensor_array_concat_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayConcatV3::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArrayGather` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGather {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayGather {
    /// Creates a new `TensorArrayGather`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape` attribute.
    pub fn element_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayGather` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        indices: O1,
        flow_in: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), indices.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        indices: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayGather", |nd| {
            nd.add_input(handle);
            nd.add_input(indices);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape {
                nd.set_attr_shape("element_shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayGather::new().build(handle, indices, flow_in, scope)`.
pub fn tensor_array_gather<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    indices: O1,
    flow_in: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayGather::new().build(handle, indices, flow_in, scope)
}
/// Builder for the `TensorArrayGatherV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGatherV2 {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayGatherV2 {
    /// Creates a new `TensorArrayGatherV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape` attribute.
    pub fn element_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayGatherV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        indices: O1,
        flow_in: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), indices.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        indices: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayGatherV2", |nd| {
            nd.add_input(handle);
            nd.add_input(indices);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape {
                nd.set_attr_shape("element_shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayGatherV2::new().build(handle, indices, flow_in, scope)`.
pub fn tensor_array_gather_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    indices: O1,
    flow_in: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayGatherV2::new().build(handle, indices, flow_in, scope)
}
/// Builder for the `TensorArrayGatherV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGatherV3 {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayGatherV3 {
    /// Creates a new `TensorArrayGatherV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape` attribute.
    pub fn element_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayGatherV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        indices: O1,
        flow_in: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), indices.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        indices: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayGatherV3", |nd| {
            nd.add_input(handle);
            nd.add_input(indices);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape {
                nd.set_attr_shape("element_shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayGatherV3::new().build(handle, indices, flow_in, scope)`.
pub fn tensor_array_gather_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    indices: O1,
    flow_in: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayGatherV3::new().build(handle, indices, flow_in, scope)
}
/// Builder for the `TensorArrayGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGrad {
    source: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayGrad {
    /// Creates a new `TensorArrayGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `source` attribute.
    pub fn source<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.source = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayGrad", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.source {
                nd.set_attr_string("source", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayGrad::new().build(handle, flow_in, scope)`.
pub fn tensor_array_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayGrad::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArrayGradV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGradV2 {
    source: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayGradV2 {
    /// Creates a new `TensorArrayGradV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `source` attribute.
    pub fn source<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.source = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayGradV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayGradV2", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.source {
                nd.set_attr_string("source", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayGradV2::new().build(handle, flow_in, scope)`.
pub fn tensor_array_grad_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayGradV2::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArrayGradV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGradV3 {
    source: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayGradV3 {
    /// Creates a new `TensorArrayGradV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `source` attribute.
    pub fn source<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.source = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayGradV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayGradV3", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.source {
                nd.set_attr_string("source", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayGradV3::new().build(handle, flow_in, scope)`.
pub fn tensor_array_grad_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayGradV3::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArrayGradWithShape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayGradWithShape {
    source: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayGradWithShape {
    /// Creates a new `TensorArrayGradWithShape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `source` attribute.
    pub fn source<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.source = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayGradWithShape` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        shape_to_prepend: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            flow_in.into(),
            shape_to_prepend.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        shape_to_prepend: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayGradWithShape", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            nd.add_input(shape_to_prepend);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.source {
                nd.set_attr_string("source", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayGradWithShape::new().build(handle, flow_in, shape_to_prepend, scope)`.
pub fn tensor_array_grad_with_shape<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    shape_to_prepend: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayGradWithShape::new().build(handle, flow_in, shape_to_prepend, scope)
}
/// Builder for the `TensorArrayPack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayPack {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayPack {
    /// Creates a new `TensorArrayPack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape` attribute.
    pub fn element_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayPack` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayPack", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape {
                nd.set_attr_shape("element_shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayPack::new().build(handle, flow_in, scope)`.
pub fn tensor_array_pack<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayPack::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArrayRead` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayRead {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayRead {
    /// Creates a new `TensorArrayRead`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayRead` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        index: O1,
        flow_in: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), index.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        index: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayRead", |nd| {
            nd.add_input(handle);
            nd.add_input(index);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayRead::new().build(handle, index, flow_in, scope)`.
pub fn tensor_array_read<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    index: O1,
    flow_in: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayRead::new().build(handle, index, flow_in, scope)
}
/// Builder for the `TensorArrayReadV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayReadV2 {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayReadV2 {
    /// Creates a new `TensorArrayReadV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayReadV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        index: O1,
        flow_in: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), index.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        index: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayReadV2", |nd| {
            nd.add_input(handle);
            nd.add_input(index);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayReadV2::new().build(handle, index, flow_in, scope)`.
pub fn tensor_array_read_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    index: O1,
    flow_in: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayReadV2::new().build(handle, index, flow_in, scope)
}
/// Builder for the `TensorArrayReadV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayReadV3 {
    dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayReadV3 {
    /// Creates a new `TensorArrayReadV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayReadV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        index: O1,
        flow_in: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), index.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        index: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayReadV3", |nd| {
            nd.add_input(handle);
            nd.add_input(index);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayReadV3::new().build(handle, index, flow_in, scope)`.
pub fn tensor_array_read_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    index: O1,
    flow_in: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayReadV3::new().build(handle, index, flow_in, scope)
}
/// Builder for the `TensorArrayScatter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayScatter {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayScatter {
    /// Creates a new `TensorArrayScatter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayScatter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        indices: O1,
        value: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            indices.into(),
            value.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        indices: crate::Output,
        value: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayScatter", |nd| {
            nd.add_input(handle);
            nd.add_input(indices);
            nd.add_input(value);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayScatter::new().build(handle, indices, value, flow_in, scope)`.
pub fn tensor_array_scatter<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    indices: O1,
    value: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayScatter::new().build(handle, indices, value, flow_in, scope)
}
/// Builder for the `TensorArrayScatterV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayScatterV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayScatterV2 {
    /// Creates a new `TensorArrayScatterV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayScatterV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        indices: O1,
        value: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            indices.into(),
            value.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        indices: crate::Output,
        value: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayScatterV2", |nd| {
            nd.add_input(handle);
            nd.add_input(indices);
            nd.add_input(value);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayScatterV2::new().build(handle, indices, value, flow_in, scope)`.
pub fn tensor_array_scatter_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    indices: O1,
    value: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayScatterV2::new().build(handle, indices, value, flow_in, scope)
}
/// Builder for the `TensorArrayScatterV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayScatterV3 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayScatterV3 {
    /// Creates a new `TensorArrayScatterV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayScatterV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        indices: O1,
        value: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            indices.into(),
            value.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        indices: crate::Output,
        value: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayScatterV3", |nd| {
            nd.add_input(handle);
            nd.add_input(indices);
            nd.add_input(value);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayScatterV3::new().build(handle, indices, value, flow_in, scope)`.
pub fn tensor_array_scatter_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    indices: O1,
    value: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayScatterV3::new().build(handle, indices, value, flow_in, scope)
}
/// Builder for the `TensorArraySize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArraySize {
    /// Creates a new `TensorArraySize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArraySize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArraySize", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArraySize::new().build(handle, flow_in, scope)`.
pub fn tensor_array_size<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArraySize::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArraySizeV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySizeV2 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArraySizeV2 {
    /// Creates a new `TensorArraySizeV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArraySizeV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArraySizeV2", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArraySizeV2::new().build(handle, flow_in, scope)`.
pub fn tensor_array_size_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArraySizeV2::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArraySizeV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySizeV3 {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArraySizeV3 {
    /// Creates a new `TensorArraySizeV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArraySizeV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        flow_in: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArraySizeV3", |nd| {
            nd.add_input(handle);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArraySizeV3::new().build(handle, flow_in, scope)`.
pub fn tensor_array_size_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    flow_in: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArraySizeV3::new().build(handle, flow_in, scope)
}
/// Builder for the `TensorArraySplit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySplit {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArraySplit {
    /// Creates a new `TensorArraySplit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArraySplit` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        value: O1,
        lengths: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            value.into(),
            lengths.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        value: crate::Output,
        lengths: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArraySplit", |nd| {
            nd.add_input(handle);
            nd.add_input(value);
            nd.add_input(lengths);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArraySplit::new().build(handle, value, lengths, flow_in, scope)`.
pub fn tensor_array_split<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    value: O1,
    lengths: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArraySplit::new().build(handle, value, lengths, flow_in, scope)
}
/// Builder for the `TensorArraySplitV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySplitV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArraySplitV2 {
    /// Creates a new `TensorArraySplitV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArraySplitV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        value: O1,
        lengths: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            value.into(),
            lengths.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        value: crate::Output,
        lengths: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArraySplitV2", |nd| {
            nd.add_input(handle);
            nd.add_input(value);
            nd.add_input(lengths);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArraySplitV2::new().build(handle, value, lengths, flow_in, scope)`.
pub fn tensor_array_split_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    value: O1,
    lengths: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArraySplitV2::new().build(handle, value, lengths, flow_in, scope)
}
/// Builder for the `TensorArraySplitV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArraySplitV3 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArraySplitV3 {
    /// Creates a new `TensorArraySplitV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArraySplitV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        value: O1,
        lengths: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            value.into(),
            lengths.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        value: crate::Output,
        lengths: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArraySplitV3", |nd| {
            nd.add_input(handle);
            nd.add_input(value);
            nd.add_input(lengths);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArraySplitV3::new().build(handle, value, lengths, flow_in, scope)`.
pub fn tensor_array_split_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    value: O1,
    lengths: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArraySplitV3::new().build(handle, value, lengths, flow_in, scope)
}
/// Builder for the `TensorArrayUnpack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayUnpack {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayUnpack {
    /// Creates a new `TensorArrayUnpack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayUnpack` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        value: O1,
        flow_in: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(handle.into(), value.into(), flow_in.into(), scope)
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        value: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayUnpack", |nd| {
            nd.add_input(handle);
            nd.add_input(value);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayUnpack::new().build(handle, value, flow_in, scope)`.
pub fn tensor_array_unpack<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    value: O1,
    flow_in: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayUnpack::new().build(handle, value, flow_in, scope)
}
/// Builder for the `TensorArrayV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayV2 {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape: ::std::option::Option<crate::Shape>,
    dynamic_size: ::std::option::Option<bool>,
    clear_after_read: ::std::option::Option<bool>,
    tensor_array_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayV2 {
    /// Creates a new `TensorArrayV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape` attribute.
    pub fn element_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dynamic_size` attribute.
    pub fn dynamic_size<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.dynamic_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `clear_after_read` attribute.
    pub fn clear_after_read<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.clear_after_read = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_array_name` attribute.
    pub fn tensor_array_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_array_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayV2` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        size: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(size.into(), scope)
    }

    fn build_impl(
        &self,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayV2", |nd| {
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape {
                nd.set_attr_shape("element_shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dynamic_size {
                nd.set_attr_bool("dynamic_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.clear_after_read {
                nd.set_attr_bool("clear_after_read", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_array_name {
                nd.set_attr_string("tensor_array_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayV2::new().build(size, scope)`.
pub fn tensor_array_v2<O0: ::std::convert::Into<crate::Output>>(
    size: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayV2::new().build(size, scope)
}
/// Builder for the `TensorArrayV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayV3 {
    dtype: ::std::option::Option<crate::DataType>,
    element_shape: ::std::option::Option<crate::Shape>,
    dynamic_size: ::std::option::Option<bool>,
    clear_after_read: ::std::option::Option<bool>,
    identical_element_shapes: ::std::option::Option<bool>,
    tensor_array_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayV3 {
    /// Creates a new `TensorArrayV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape` attribute.
    pub fn element_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dynamic_size` attribute.
    pub fn dynamic_size<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.dynamic_size = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `clear_after_read` attribute.
    pub fn clear_after_read<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.clear_after_read = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `identical_element_shapes` attribute.
    pub fn identical_element_shapes<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.identical_element_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `tensor_array_name` attribute.
    pub fn tensor_array_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.tensor_array_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayV3` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        size: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(size.into(), scope)
    }

    fn build_impl(
        &self,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayV3", |nd| {
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape {
                nd.set_attr_shape("element_shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dynamic_size {
                nd.set_attr_bool("dynamic_size", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.clear_after_read {
                nd.set_attr_bool("clear_after_read", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.identical_element_shapes {
                nd.set_attr_bool("identical_element_shapes", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.tensor_array_name {
                nd.set_attr_string("tensor_array_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayV3::new().build(size, scope)`.
pub fn tensor_array_v3<O0: ::std::convert::Into<crate::Output>>(
    size: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayV3::new().build(size, scope)
}
/// Builder for the `TensorArrayWrite` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayWrite {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayWrite {
    /// Creates a new `TensorArrayWrite`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayWrite` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        index: O1,
        value: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            index.into(),
            value.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        index: crate::Output,
        value: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayWrite", |nd| {
            nd.add_input(handle);
            nd.add_input(index);
            nd.add_input(value);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayWrite::new().build(handle, index, value, flow_in, scope)`.
pub fn tensor_array_write<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    index: O1,
    value: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayWrite::new().build(handle, index, value, flow_in, scope)
}
/// Builder for the `TensorArrayWriteV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayWriteV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayWriteV2 {
    /// Creates a new `TensorArrayWriteV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayWriteV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        index: O1,
        value: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            index.into(),
            value.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        index: crate::Output,
        value: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayWriteV2", |nd| {
            nd.add_input(handle);
            nd.add_input(index);
            nd.add_input(value);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayWriteV2::new().build(handle, index, value, flow_in, scope)`.
pub fn tensor_array_write_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    index: O1,
    value: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayWriteV2::new().build(handle, index, value, flow_in, scope)
}
/// Builder for the `TensorArrayWriteV3` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorArrayWriteV3 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorArrayWriteV3 {
    /// Creates a new `TensorArrayWriteV3`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorArrayWriteV3` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        handle: O0,
        index: O1,
        value: O2,
        flow_in: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            handle.into(),
            index.into(),
            value.into(),
            flow_in.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        handle: crate::Output,
        index: crate::Output,
        value: crate::Output,
        flow_in: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorArrayWriteV3", |nd| {
            nd.add_input(handle);
            nd.add_input(index);
            nd.add_input(value);
            nd.add_input(flow_in);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorArrayWriteV3::new().build(handle, index, value, flow_in, scope)`.
pub fn tensor_array_write_v3<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    handle: O0,
    index: O1,
    value: O2,
    flow_in: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorArrayWriteV3::new().build(handle, index, value, flow_in, scope)
}
/// Builder for the `TensorDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorDataset {
    Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorDataset {
    /// Creates a new `TensorDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Toutput_types` attribute.
    pub fn Toutput_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        components: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(components.into(), scope)
    }

    fn build_impl(
        &self,
        components: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorDataset", |nd| {
            nd.add_input(components);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Toutput_types {
                nd.set_attr_type_list("Toutput_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorDataset::new().build(components, scope)`.
pub fn tensor_dataset<O0: ::std::convert::Into<crate::Output>>(
    components: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorDataset::new().build(components, scope)
}
/// Builder for the `TensorForestCreateTreeVariable` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorForestCreateTreeVariable {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorForestCreateTreeVariable {
    /// Creates a new `TensorForestCreateTreeVariable`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorForestCreateTreeVariable` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_handle: O0,
        tree_config: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_handle.into(), tree_config.into(), scope)
    }

    fn build_impl(
        &self,
        tree_handle: crate::Output,
        tree_config: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorForestCreateTreeVariable", |nd| {
            nd.add_input(tree_handle);
            nd.add_input(tree_config);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorForestCreateTreeVariable::new().build(tree_handle, tree_config, scope)`.
pub fn tensor_forest_create_tree_variable<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tree_handle: O0,
    tree_config: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorForestCreateTreeVariable::new().build(tree_handle, tree_config, scope)
}
/// Builder for the `TensorForestTreeDeserialize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorForestTreeDeserialize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorForestTreeDeserialize {
    /// Creates a new `TensorForestTreeDeserialize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorForestTreeDeserialize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_handle: O0,
        tree_config: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_handle.into(), tree_config.into(), scope)
    }

    fn build_impl(
        &self,
        tree_handle: crate::Output,
        tree_config: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorForestTreeDeserialize", |nd| {
            nd.add_input(tree_handle);
            nd.add_input(tree_config);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorForestTreeDeserialize::new().build(tree_handle, tree_config, scope)`.
pub fn tensor_forest_tree_deserialize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tree_handle: O0,
    tree_config: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorForestTreeDeserialize::new().build(tree_handle, tree_config, scope)
}
/// Builder for the `TensorForestTreeIsInitializedOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorForestTreeIsInitializedOp {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorForestTreeIsInitializedOp {
    /// Creates a new `TensorForestTreeIsInitializedOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorForestTreeIsInitializedOp` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tree_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_handle.into(), scope)
    }

    fn build_impl(
        &self,
        tree_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorForestTreeIsInitializedOp", |nd| {
            nd.add_input(tree_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorForestTreeIsInitializedOp::new().build(tree_handle, scope)`.
pub fn tensor_forest_tree_is_initialized_op<O0: ::std::convert::Into<crate::Output>>(
    tree_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorForestTreeIsInitializedOp::new().build(tree_handle, scope)
}
/// Builder for the `TensorForestTreePredict` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorForestTreePredict {
    logits_dimension: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorForestTreePredict {
    /// Creates a new `TensorForestTreePredict`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `logits_dimension` attribute.
    pub fn logits_dimension<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.logits_dimension = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorForestTreePredict` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tree_handle: O0,
        dense_features: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_handle.into(), dense_features.into(), scope)
    }

    fn build_impl(
        &self,
        tree_handle: crate::Output,
        dense_features: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorForestTreePredict", |nd| {
            nd.add_input(tree_handle);
            nd.add_input(dense_features);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.logits_dimension {
                nd.set_attr_int("logits_dimension", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorForestTreePredict::new().build(tree_handle, dense_features, scope)`.
pub fn tensor_forest_tree_predict<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tree_handle: O0,
    dense_features: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorForestTreePredict::new().build(tree_handle, dense_features, scope)
}
/// Builder for the `TensorForestTreeResourceHandleOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorForestTreeResourceHandleOp {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorForestTreeResourceHandleOp {
    /// Creates a new `TensorForestTreeResourceHandleOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorForestTreeResourceHandleOp` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorForestTreeResourceHandleOp", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorForestTreeResourceHandleOp::new().build(scope)`.
pub fn tensor_forest_tree_resource_handle_op(
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorForestTreeResourceHandleOp::new().build(scope)
}
/// Builder for the `TensorForestTreeSerialize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorForestTreeSerialize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorForestTreeSerialize {
    /// Creates a new `TensorForestTreeSerialize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorForestTreeSerialize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tree_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_handle.into(), scope)
    }

    fn build_impl(
        &self,
        tree_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorForestTreeSerialize", |nd| {
            nd.add_input(tree_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorForestTreeSerialize::new().build(tree_handle, scope)`.
pub fn tensor_forest_tree_serialize<O0: ::std::convert::Into<crate::Output>>(
    tree_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorForestTreeSerialize::new().build(tree_handle, scope)
}
/// Builder for the `TensorForestTreeSize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorForestTreeSize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorForestTreeSize {
    /// Creates a new `TensorForestTreeSize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorForestTreeSize` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tree_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tree_handle.into(), scope)
    }

    fn build_impl(
        &self,
        tree_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorForestTreeSize", |nd| {
            nd.add_input(tree_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorForestTreeSize::new().build(tree_handle, scope)`.
pub fn tensor_forest_tree_size<O0: ::std::convert::Into<crate::Output>>(
    tree_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorForestTreeSize::new().build(tree_handle, scope)
}
/// Builder for the `TensorListConcat` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListConcat {
    element_dtype: ::std::option::Option<crate::DataType>,
    element_shape: ::std::option::Option<crate::Shape>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListConcat {
    /// Creates a new `TensorListConcat`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `element_shape` attribute.
    pub fn element_shape<ArgType: ::std::convert::Into<crate::Shape>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListConcat` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListConcat", |nd| {
            nd.add_input(input_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.element_shape {
                nd.set_attr_shape("element_shape", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListConcat::new().build(input_handle, scope)`.
pub fn tensor_list_concat<O0: ::std::convert::Into<crate::Output>>(
    input_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListConcat::new().build(input_handle, scope)
}
/// Builder for the `TensorListConcatLists` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListConcatLists {
    element_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListConcatLists {
    /// Creates a new `TensorListConcatLists`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListConcatLists` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_a: O0,
        input_b: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_a.into(), input_b.into(), scope)
    }

    fn build_impl(
        &self,
        input_a: crate::Output,
        input_b: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListConcatLists", |nd| {
            nd.add_input(input_a);
            nd.add_input(input_b);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListConcatLists::new().build(input_a, input_b, scope)`.
pub fn tensor_list_concat_lists<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_a: O0,
    input_b: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListConcatLists::new().build(input_a, input_b, scope)
}
/// Builder for the `TensorListConcatV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListConcatV2 {
    element_dtype: ::std::option::Option<crate::DataType>,
    shape_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListConcatV2 {
    /// Creates a new `TensorListConcatV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_type` attribute.
    pub fn shape_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListConcatV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        element_shape: O1,
        leading_dims: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_handle.into(),
            element_shape.into(),
            leading_dims.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        element_shape: crate::Output,
        leading_dims: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListConcatV2", |nd| {
            nd.add_input(input_handle);
            nd.add_input(element_shape);
            nd.add_input(leading_dims);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_type {
                nd.set_attr_type("shape_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListConcatV2::new().build(input_handle, element_shape, leading_dims, scope)`.
pub fn tensor_list_concat_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    element_shape: O1,
    leading_dims: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListConcatV2::new().build(input_handle, element_shape, leading_dims, scope)
}
/// Builder for the `TensorListElementShape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListElementShape {
    shape_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListElementShape {
    /// Creates a new `TensorListElementShape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `shape_type` attribute.
    pub fn shape_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListElementShape` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListElementShape", |nd| {
            nd.add_input(input_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.shape_type {
                nd.set_attr_type("shape_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListElementShape::new().build(input_handle, scope)`.
pub fn tensor_list_element_shape<O0: ::std::convert::Into<crate::Output>>(
    input_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListElementShape::new().build(input_handle, scope)
}
/// Builder for the `TensorListFromTensor` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListFromTensor {
    element_dtype: ::std::option::Option<crate::DataType>,
    shape_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListFromTensor {
    /// Creates a new `TensorListFromTensor`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_type` attribute.
    pub fn shape_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListFromTensor` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        element_shape: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), element_shape.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        element_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListFromTensor", |nd| {
            nd.add_input(tensor);
            nd.add_input(element_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_type {
                nd.set_attr_type("shape_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListFromTensor::new().build(tensor, element_shape, scope)`.
pub fn tensor_list_from_tensor<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    element_shape: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListFromTensor::new().build(tensor, element_shape, scope)
}
/// Builder for the `TensorListGather` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListGather {
    element_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListGather {
    /// Creates a new `TensorListGather`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListGather` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        indices: O1,
        element_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_handle.into(),
            indices.into(),
            element_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        indices: crate::Output,
        element_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListGather", |nd| {
            nd.add_input(input_handle);
            nd.add_input(indices);
            nd.add_input(element_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListGather::new().build(input_handle, indices, element_shape, scope)`.
pub fn tensor_list_gather<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    indices: O1,
    element_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListGather::new().build(input_handle, indices, element_shape, scope)
}
/// Builder for the `TensorListGetItem` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListGetItem {
    element_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListGetItem {
    /// Creates a new `TensorListGetItem`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListGetItem` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        index: O1,
        element_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_handle.into(),
            index.into(),
            element_shape.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        index: crate::Output,
        element_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListGetItem", |nd| {
            nd.add_input(input_handle);
            nd.add_input(index);
            nd.add_input(element_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListGetItem::new().build(input_handle, index, element_shape, scope)`.
pub fn tensor_list_get_item<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    index: O1,
    element_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListGetItem::new().build(input_handle, index, element_shape, scope)
}
/// Builder for the `TensorListLength` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListLength {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListLength {
    /// Creates a new `TensorListLength`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListLength` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListLength", |nd| {
            nd.add_input(input_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListLength::new().build(input_handle, scope)`.
pub fn tensor_list_length<O0: ::std::convert::Into<crate::Output>>(
    input_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListLength::new().build(input_handle, scope)
}
/// Builder for the `TensorListPopBack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListPopBack {
    element_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListPopBack {
    /// Creates a new `TensorListPopBack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListPopBack` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        element_shape: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), element_shape.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        element_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListPopBack", |nd| {
            nd.add_input(input_handle);
            nd.add_input(element_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListPopBack::new().build(input_handle, element_shape, scope)`.
pub fn tensor_list_pop_back<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    element_shape: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListPopBack::new().build(input_handle, element_shape, scope)
}
/// Builder for the `TensorListPushBack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListPushBack {
    element_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListPushBack {
    /// Creates a new `TensorListPushBack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListPushBack` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        tensor: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), tensor.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListPushBack", |nd| {
            nd.add_input(input_handle);
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListPushBack::new().build(input_handle, tensor, scope)`.
pub fn tensor_list_push_back<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    tensor: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListPushBack::new().build(input_handle, tensor, scope)
}
/// Builder for the `TensorListPushBackBatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListPushBackBatch {
    element_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListPushBackBatch {
    /// Creates a new `TensorListPushBackBatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListPushBackBatch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handles: O0,
        tensor: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handles.into(), tensor.into(), scope)
    }

    fn build_impl(
        &self,
        input_handles: crate::Output,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListPushBackBatch", |nd| {
            nd.add_input(input_handles);
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListPushBackBatch::new().build(input_handles, tensor, scope)`.
pub fn tensor_list_push_back_batch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_handles: O0,
    tensor: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListPushBackBatch::new().build(input_handles, tensor, scope)
}
/// Builder for the `TensorListReserve` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListReserve {
    element_dtype: ::std::option::Option<crate::DataType>,
    shape_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListReserve {
    /// Creates a new `TensorListReserve`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_type` attribute.
    pub fn shape_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListReserve` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        element_shape: O0,
        num_elements: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(element_shape.into(), num_elements.into(), scope)
    }

    fn build_impl(
        &self,
        element_shape: crate::Output,
        num_elements: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListReserve", |nd| {
            nd.add_input(element_shape);
            nd.add_input(num_elements);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_type {
                nd.set_attr_type("shape_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListReserve::new().build(element_shape, num_elements, scope)`.
pub fn tensor_list_reserve<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    element_shape: O0,
    num_elements: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListReserve::new().build(element_shape, num_elements, scope)
}
/// Builder for the `TensorListResize` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListResize {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListResize {
    /// Creates a new `TensorListResize`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListResize` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        size: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), size.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListResize", |nd| {
            nd.add_input(input_handle);
            nd.add_input(size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListResize::new().build(input_handle, size, scope)`.
pub fn tensor_list_resize<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    size: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListResize::new().build(input_handle, size, scope)
}
/// Builder for the `TensorListScatter` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListScatter {
    element_dtype: ::std::option::Option<crate::DataType>,
    shape_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListScatter {
    /// Creates a new `TensorListScatter`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_type` attribute.
    pub fn shape_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListScatter` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        indices: O1,
        element_shape: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), indices.into(), element_shape.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        indices: crate::Output,
        element_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListScatter", |nd| {
            nd.add_input(tensor);
            nd.add_input(indices);
            nd.add_input(element_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_type {
                nd.set_attr_type("shape_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListScatter::new().build(tensor, indices, element_shape, scope)`.
pub fn tensor_list_scatter<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    indices: O1,
    element_shape: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListScatter::new().build(tensor, indices, element_shape, scope)
}
/// Builder for the `TensorListScatterIntoExistingList` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListScatterIntoExistingList {
    element_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListScatterIntoExistingList {
    /// Creates a new `TensorListScatterIntoExistingList`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListScatterIntoExistingList` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        tensor: O1,
        indices: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), tensor.into(), indices.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        tensor: crate::Output,
        indices: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListScatterIntoExistingList", |nd| {
            nd.add_input(input_handle);
            nd.add_input(tensor);
            nd.add_input(indices);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListScatterIntoExistingList::new().build(input_handle, tensor, indices, scope)`.
pub fn tensor_list_scatter_into_existing_list<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    tensor: O1,
    indices: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListScatterIntoExistingList::new().build(input_handle, tensor, indices, scope)
}
/// Builder for the `TensorListScatterV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListScatterV2 {
    element_dtype: ::std::option::Option<crate::DataType>,
    shape_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListScatterV2 {
    /// Creates a new `TensorListScatterV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_type` attribute.
    pub fn shape_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListScatterV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        indices: O1,
        element_shape: O2,
        num_elements: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tensor.into(),
            indices.into(),
            element_shape.into(),
            num_elements.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        indices: crate::Output,
        element_shape: crate::Output,
        num_elements: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListScatterV2", |nd| {
            nd.add_input(tensor);
            nd.add_input(indices);
            nd.add_input(element_shape);
            nd.add_input(num_elements);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_type {
                nd.set_attr_type("shape_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListScatterV2::new().build(tensor, indices, element_shape, num_elements, scope)`.
pub fn tensor_list_scatter_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    indices: O1,
    element_shape: O2,
    num_elements: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListScatterV2::new().build(tensor, indices, element_shape, num_elements, scope)
}
/// Builder for the `TensorListSetItem` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListSetItem {
    element_dtype: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListSetItem {
    /// Creates a new `TensorListSetItem`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListSetItem` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        index: O1,
        item: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), index.into(), item.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        index: crate::Output,
        item: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListSetItem", |nd| {
            nd.add_input(input_handle);
            nd.add_input(index);
            nd.add_input(item);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListSetItem::new().build(input_handle, index, item, scope)`.
pub fn tensor_list_set_item<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    index: O1,
    item: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListSetItem::new().build(input_handle, index, item, scope)
}
/// Builder for the `TensorListSplit` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListSplit {
    element_dtype: ::std::option::Option<crate::DataType>,
    shape_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListSplit {
    /// Creates a new `TensorListSplit`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape_type` attribute.
    pub fn shape_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shape_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListSplit` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        element_shape: O1,
        lengths: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), element_shape.into(), lengths.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        element_shape: crate::Output,
        lengths: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListSplit", |nd| {
            nd.add_input(tensor);
            nd.add_input(element_shape);
            nd.add_input(lengths);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape_type {
                nd.set_attr_type("shape_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListSplit::new().build(tensor, element_shape, lengths, scope)`.
pub fn tensor_list_split<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    element_shape: O1,
    lengths: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListSplit::new().build(tensor, element_shape, lengths, scope)
}
/// Builder for the `TensorListStack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorListStack {
    element_dtype: ::std::option::Option<crate::DataType>,
    num_elements: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorListStack {
    /// Creates a new `TensorListStack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `element_dtype` attribute.
    pub fn element_dtype<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.element_dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_elements` attribute.
    pub fn num_elements<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_elements = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorListStack` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_handle: O0,
        element_shape: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), element_shape.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        element_shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorListStack", |nd| {
            nd.add_input(input_handle);
            nd.add_input(element_shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.element_dtype {
                nd.set_attr_type("element_dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_elements {
                nd.set_attr_int("num_elements", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorListStack::new().build(input_handle, element_shape, scope)`.
pub fn tensor_list_stack<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_handle: O0,
    element_shape: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorListStack::new().build(input_handle, element_shape, scope)
}
/// Builder for the `TensorScatterAdd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterAdd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorScatterAdd {
    /// Creates a new `TensorScatterAdd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorScatterAdd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorScatterAdd", |nd| {
            nd.add_input(tensor);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorScatterAdd::new().build(tensor, indices, updates, scope)`.
pub fn tensor_scatter_add<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorScatterAdd::new().build(tensor, indices, updates, scope)
}
/// Builder for the `TensorScatterMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterMax {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorScatterMax {
    /// Creates a new `TensorScatterMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorScatterMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorScatterMax", |nd| {
            nd.add_input(tensor);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorScatterMax::new().build(tensor, indices, updates, scope)`.
pub fn tensor_scatter_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorScatterMax::new().build(tensor, indices, updates, scope)
}
/// Builder for the `TensorScatterMin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterMin {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorScatterMin {
    /// Creates a new `TensorScatterMin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorScatterMin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorScatterMin", |nd| {
            nd.add_input(tensor);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorScatterMin::new().build(tensor, indices, updates, scope)`.
pub fn tensor_scatter_min<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorScatterMin::new().build(tensor, indices, updates, scope)
}
/// Builder for the `TensorScatterSub` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterSub {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorScatterSub {
    /// Creates a new `TensorScatterSub`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorScatterSub` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorScatterSub", |nd| {
            nd.add_input(tensor);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorScatterSub::new().build(tensor, indices, updates, scope)`.
pub fn tensor_scatter_sub<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorScatterSub::new().build(tensor, indices, updates, scope)
}
/// Builder for the `TensorScatterUpdate` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorScatterUpdate {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorScatterUpdate {
    /// Creates a new `TensorScatterUpdate`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorScatterUpdate` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tensor: O0,
        indices: O1,
        updates: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), indices.into(), updates.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        indices: crate::Output,
        updates: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorScatterUpdate", |nd| {
            nd.add_input(tensor);
            nd.add_input(indices);
            nd.add_input(updates);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorScatterUpdate::new().build(tensor, indices, updates, scope)`.
pub fn tensor_scatter_update<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tensor: O0,
    indices: O1,
    updates: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorScatterUpdate::new().build(tensor, indices, updates, scope)
}
/// Builder for the `TensorSliceDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorSliceDataset {
    Toutput_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorSliceDataset {
    /// Creates a new `TensorSliceDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Toutput_types` attribute.
    pub fn Toutput_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Toutput_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorSliceDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        components: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(components.into(), scope)
    }

    fn build_impl(
        &self,
        components: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorSliceDataset", |nd| {
            nd.add_input(components);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Toutput_types {
                nd.set_attr_type_list("Toutput_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorSliceDataset::new().build(components, scope)`.
pub fn tensor_slice_dataset<O0: ::std::convert::Into<crate::Output>>(
    components: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorSliceDataset::new().build(components, scope)
}
/// Builder for the `TensorStridedSliceUpdate` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorStridedSliceUpdate {
    T: ::std::option::Option<crate::DataType>,
    Index: ::std::option::Option<crate::DataType>,
    begin_mask: ::std::option::Option<i64>,
    end_mask: ::std::option::Option<i64>,
    ellipsis_mask: ::std::option::Option<i64>,
    new_axis_mask: ::std::option::Option<i64>,
    shrink_axis_mask: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorStridedSliceUpdate {
    /// Creates a new `TensorStridedSliceUpdate`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Index` attribute.
    pub fn Index<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Index = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `begin_mask` attribute.
    pub fn begin_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.begin_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `end_mask` attribute.
    pub fn end_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.end_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `ellipsis_mask` attribute.
    pub fn ellipsis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.ellipsis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `new_axis_mask` attribute.
    pub fn new_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.new_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shrink_axis_mask` attribute.
    pub fn shrink_axis_mask<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.shrink_axis_mask = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorStridedSliceUpdate` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        begin: O1,
        end: O2,
        strides: O3,
        value: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input.into(),
            begin.into(),
            end.into(),
            strides.into(),
            value.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input: crate::Output,
        begin: crate::Output,
        end: crate::Output,
        strides: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorStridedSliceUpdate", |nd| {
            nd.add_input(input);
            nd.add_input(begin);
            nd.add_input(end);
            nd.add_input(strides);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Index {
                nd.set_attr_type("Index", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.begin_mask {
                nd.set_attr_int("begin_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.end_mask {
                nd.set_attr_int("end_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.ellipsis_mask {
                nd.set_attr_int("ellipsis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.new_axis_mask {
                nd.set_attr_int("new_axis_mask", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shrink_axis_mask {
                nd.set_attr_int("shrink_axis_mask", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorStridedSliceUpdate::new().build(input, begin, end, strides, value, scope)`.
pub fn tensor_strided_slice_update<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    begin: O1,
    end: O2,
    strides: O3,
    value: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorStridedSliceUpdate::new().build(input, begin, end, strides, value, scope)
}
/// Builder for the `TensorSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorSummary {
    T: ::std::option::Option<crate::DataType>,
    description: ::std::option::Option<::std::string::String>,
    labels: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    display_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorSummary {
    /// Creates a new `TensorSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `description` attribute.
    pub fn description<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.description = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `labels` attribute.
    pub fn labels<ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.labels = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `display_name` attribute.
    pub fn display_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.display_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorSummary` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        tensor: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(tensor.into(), scope)
    }

    fn build_impl(
        &self,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorSummary", |nd| {
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.description {
                nd.set_attr_string("description", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.labels {
                nd.set_attr_string_list("labels", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.display_name {
                nd.set_attr_string("display_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorSummary::new().build(tensor, scope)`.
pub fn tensor_summary<O0: ::std::convert::Into<crate::Output>>(
    tensor: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorSummary::new().build(tensor, scope)
}
/// Builder for the `TensorSummaryV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TensorSummaryV2 {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TensorSummaryV2 {
    /// Creates a new `TensorSummaryV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TensorSummaryV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        tag: O0,
        tensor: O1,
        serialized_summary_metadata: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            tag.into(),
            tensor.into(),
            serialized_summary_metadata.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        tag: crate::Output,
        tensor: crate::Output,
        serialized_summary_metadata: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TensorSummaryV2", |nd| {
            nd.add_input(tag);
            nd.add_input(tensor);
            nd.add_input(serialized_summary_metadata);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TensorSummaryV2::new().build(tag, tensor, serialized_summary_metadata, scope)`.
pub fn tensor_summary_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    tag: O0,
    tensor: O1,
    serialized_summary_metadata: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TensorSummaryV2::new().build(tag, tensor, serialized_summary_metadata, scope)
}
/// Builder for the `TextLineDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TextLineDataset {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TextLineDataset {
    /// Creates a new `TextLineDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TextLineDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filenames: O0,
        compression_type: O1,
        buffer_size: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            filenames.into(),
            compression_type.into(),
            buffer_size.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        filenames: crate::Output,
        compression_type: crate::Output,
        buffer_size: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TextLineDataset", |nd| {
            nd.add_input(filenames);
            nd.add_input(compression_type);
            nd.add_input(buffer_size);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TextLineDataset::new().build(filenames, compression_type, buffer_size, scope)`.
pub fn text_line_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    filenames: O0,
    compression_type: O1,
    buffer_size: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TextLineDataset::new().build(filenames, compression_type, buffer_size, scope)
}
/// Builder for the `TextLineReader` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TextLineReader {
    skip_header_lines: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TextLineReader {
    /// Creates a new `TextLineReader`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `skip_header_lines` attribute.
    pub fn skip_header_lines<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.skip_header_lines = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TextLineReader` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TextLineReader", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.skip_header_lines {
                nd.set_attr_int("skip_header_lines", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TextLineReader::new().build(scope)`.
pub fn text_line_reader(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    TextLineReader::new().build(scope)
}
/// Builder for the `TextLineReaderV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TextLineReaderV2 {
    skip_header_lines: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TextLineReaderV2 {
    /// Creates a new `TextLineReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `skip_header_lines` attribute.
    pub fn skip_header_lines<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.skip_header_lines = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TextLineReaderV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("TextLineReaderV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.skip_header_lines {
                nd.set_attr_int("skip_header_lines", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TextLineReaderV2::new().build(scope)`.
pub fn text_line_reader_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    TextLineReaderV2::new().build(scope)
}
/// Builder for the `ThreadPoolDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ThreadPoolDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ThreadPoolDataset {
    /// Creates a new `ThreadPoolDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ThreadPoolDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        thread_pool: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), thread_pool.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        thread_pool: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ThreadPoolDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(thread_pool);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ThreadPoolDataset::new().build(input_dataset, thread_pool, scope)`.
pub fn thread_pool_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    thread_pool: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ThreadPoolDataset::new().build(input_dataset, thread_pool, scope)
}
/// Builder for the `ThreadPoolHandle` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ThreadPoolHandle {
    num_threads: ::std::option::Option<i64>,
    max_intra_op_parallelism: ::std::option::Option<i64>,
    display_name: ::std::option::Option<::std::string::String>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ThreadPoolHandle {
    /// Creates a new `ThreadPoolHandle`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_threads` attribute.
    pub fn num_threads<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_threads = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `max_intra_op_parallelism` attribute.
    pub fn max_intra_op_parallelism<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.max_intra_op_parallelism = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `display_name` attribute.
    pub fn display_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.display_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ThreadPoolHandle` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("ThreadPoolHandle", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_threads {
                nd.set_attr_int("num_threads", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.max_intra_op_parallelism {
                nd.set_attr_int("max_intra_op_parallelism", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.display_name {
                nd.set_attr_string("display_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ThreadPoolHandle::new().build(scope)`.
pub fn thread_pool_handle(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    ThreadPoolHandle::new().build(scope)
}
/// Builder for the `ThreadUnsafeUnigramCandidateSampler` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ThreadUnsafeUnigramCandidateSampler {
    num_true: ::std::option::Option<i64>,
    num_sampled: ::std::option::Option<i64>,
    unique: ::std::option::Option<bool>,
    range_max: ::std::option::Option<i64>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ThreadUnsafeUnigramCandidateSampler {
    /// Creates a new `ThreadUnsafeUnigramCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_true` attribute.
    pub fn num_true<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_true = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sampled` attribute.
    pub fn num_sampled<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_sampled = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `unique` attribute.
    pub fn unique<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.unique = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `range_max` attribute.
    pub fn range_max<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.range_max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ThreadUnsafeUnigramCandidateSampler` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        true_classes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(true_classes.into(), scope)
    }

    fn build_impl(
        &self,
        true_classes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ThreadUnsafeUnigramCandidateSampler", |nd| {
            nd.add_input(true_classes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_true {
                nd.set_attr_int("num_true", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sampled {
                nd.set_attr_int("num_sampled", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.unique {
                nd.set_attr_bool("unique", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.range_max {
                nd.set_attr_int("range_max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ThreadUnsafeUnigramCandidateSampler::new().build(true_classes, scope)`.
pub fn thread_unsafe_unigram_candidate_sampler<O0: ::std::convert::Into<crate::Output>>(
    true_classes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ThreadUnsafeUnigramCandidateSampler::new().build(true_classes, scope)
}
/// Builder for the `Tile` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Tile {
    T: ::std::option::Option<crate::DataType>,
    Tmultiples: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Tile {
    /// Creates a new `Tile`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tmultiples` attribute.
    pub fn Tmultiples<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tmultiples = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Tile` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        multiples: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), multiples.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        multiples: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Tile", |nd| {
            nd.add_input(input);
            nd.add_input(multiples);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tmultiples {
                nd.set_attr_type("Tmultiples", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Tile::new().build(input, multiples, scope)`.
pub fn tile<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    multiples: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Tile::new().build(input, multiples, scope)
}
/// Builder for the `TileGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TileGrad {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TileGrad {
    /// Creates a new `TileGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TileGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        multiples: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), multiples.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        multiples: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TileGrad", |nd| {
            nd.add_input(input);
            nd.add_input(multiples);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TileGrad::new().build(input, multiples, scope)`.
pub fn tile_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input: O0,
    multiples: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TileGrad::new().build(input, multiples, scope)
}
/// Builder for the `Timestamp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Timestamp {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Timestamp {
    /// Creates a new `Timestamp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Timestamp` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Timestamp", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Timestamp::new().build(scope)`.
pub fn timestamp(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Timestamp::new().build(scope)
}
/// Builder for the `ToBool` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ToBool {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ToBool {
    /// Creates a new `ToBool`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ToBool` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ToBool", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ToBool::new().build(input, scope)`.
pub fn to_bool<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ToBool::new().build(input, scope)
}
/// Builder for the `TopK` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TopK {
    k: ::std::option::Option<i64>,
    sorted: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TopK {
    /// Creates a new `TopK`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `k` attribute.
    pub fn k<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.k = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `sorted` attribute.
    pub fn sorted<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.sorted = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TopK` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TopK", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.k {
                nd.set_attr_int("k", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.sorted {
                nd.set_attr_bool("sorted", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TopK::new().build(input, scope)`.
pub fn top_k<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TopK::new().build(input, scope)
}
/// Builder for the `TopKV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TopKV2 {
    sorted: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TopKV2 {
    /// Creates a new `TopKV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `sorted` attribute.
    pub fn sorted<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.sorted = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TopKV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input: O0,
        k: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), k.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        k: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TopKV2", |nd| {
            nd.add_input(input);
            nd.add_input(k);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.sorted {
                nd.set_attr_bool("sorted", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TopKV2::new().build(input, k, scope)`.
pub fn top_kv2<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    input: O0,
    k: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TopKV2::new().build(input, k, scope)
}
/// Builder for the `Transpose` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Transpose {
    T: ::std::option::Option<crate::DataType>,
    Tperm: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Transpose {
    /// Creates a new `Transpose`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tperm` attribute.
    pub fn Tperm<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tperm = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Transpose` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        perm: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), perm.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        perm: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Transpose", |nd| {
            nd.add_input(x);
            nd.add_input(perm);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tperm {
                nd.set_attr_type("Tperm", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Transpose::new().build(x, perm, scope)`.
pub fn transpose<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    perm: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Transpose::new().build(x, perm, scope)
}
/// Builder for the `TridiagonalMatMul` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TridiagonalMatMul {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TridiagonalMatMul {
    /// Creates a new `TridiagonalMatMul`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TridiagonalMatMul` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        superdiag: O0,
        maindiag: O1,
        subdiag: O2,
        rhs: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            superdiag.into(),
            maindiag.into(),
            subdiag.into(),
            rhs.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        superdiag: crate::Output,
        maindiag: crate::Output,
        subdiag: crate::Output,
        rhs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TridiagonalMatMul", |nd| {
            nd.add_input(superdiag);
            nd.add_input(maindiag);
            nd.add_input(subdiag);
            nd.add_input(rhs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TridiagonalMatMul::new().build(superdiag, maindiag, subdiag, rhs, scope)`.
pub fn tridiagonal_mat_mul<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    superdiag: O0,
    maindiag: O1,
    subdiag: O2,
    rhs: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TridiagonalMatMul::new().build(superdiag, maindiag, subdiag, rhs, scope)
}
/// Builder for the `TridiagonalSolve` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TridiagonalSolve {
    partial_pivoting: ::std::option::Option<bool>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TridiagonalSolve {
    /// Creates a new `TridiagonalSolve`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `partial_pivoting` attribute.
    pub fn partial_pivoting<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.partial_pivoting = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TridiagonalSolve` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        diagonals: O0,
        rhs: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(diagonals.into(), rhs.into(), scope)
    }

    fn build_impl(
        &self,
        diagonals: crate::Output,
        rhs: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TridiagonalSolve", |nd| {
            nd.add_input(diagonals);
            nd.add_input(rhs);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.partial_pivoting {
                nd.set_attr_bool("partial_pivoting", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TridiagonalSolve::new().build(diagonals, rhs, scope)`.
pub fn tridiagonal_solve<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    diagonals: O0,
    rhs: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TridiagonalSolve::new().build(diagonals, rhs, scope)
}
/// Builder for the `TruncateDiv` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TruncateDiv {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TruncateDiv {
    /// Creates a new `TruncateDiv`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TruncateDiv` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TruncateDiv", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TruncateDiv::new().build(x, y, scope)`.
pub fn truncate_div<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TruncateDiv::new().build(x, y, scope)
}
/// Builder for the `TruncateMod` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TruncateMod {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TruncateMod {
    /// Creates a new `TruncateMod`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TruncateMod` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TruncateMod", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TruncateMod::new().build(x, y, scope)`.
pub fn truncate_mod<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TruncateMod::new().build(x, y, scope)
}
/// Builder for the `TruncatedNormal` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TruncatedNormal {
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    dtype: ::std::option::Option<crate::DataType>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TruncatedNormal {
    /// Creates a new `TruncatedNormal`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TruncatedNormal` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        shape: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(shape.into(), scope)
    }

    fn build_impl(
        &self,
        shape: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TruncatedNormal", |nd| {
            nd.add_input(shape);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TruncatedNormal::new().build(shape, scope)`.
pub fn truncated_normal<O0: ::std::convert::Into<crate::Output>>(
    shape: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TruncatedNormal::new().build(shape, scope)
}
/// Builder for the `TryRpc` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct TryRpc {
    protocol: ::std::option::Option<::std::string::String>,
    fail_fast: ::std::option::Option<bool>,
    timeout_in_ms: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl TryRpc {
    /// Creates a new `TryRpc`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `protocol` attribute.
    pub fn protocol<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.protocol = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `fail_fast` attribute.
    pub fn fail_fast<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.fail_fast = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `timeout_in_ms` attribute.
    pub fn timeout_in_ms<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_in_ms = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `TryRpc` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        address: O0,
        method: O1,
        request: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(address.into(), method.into(), request.into(), scope)
    }

    fn build_impl(
        &self,
        address: crate::Output,
        method: crate::Output,
        request: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("TryRpc", |nd| {
            nd.add_input(address);
            nd.add_input(method);
            nd.add_input(request);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.protocol {
                nd.set_attr_string("protocol", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.fail_fast {
                nd.set_attr_bool("fail_fast", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.timeout_in_ms {
                nd.set_attr_int("timeout_in_ms", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `TryRpc::new().build(address, method, request, scope)`.
pub fn try_rpc<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    address: O0,
    method: O1,
    request: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    TryRpc::new().build(address, method, request, scope)
}
/// Builder for the `Unbatch` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Unbatch {
    timeout_micros: ::std::option::Option<i64>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Unbatch {
    /// Creates a new `Unbatch`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `timeout_micros` attribute.
    pub fn timeout_micros<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.timeout_micros = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Unbatch` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        batched_tensor: O0,
        batch_index: O1,
        id: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(batched_tensor.into(), batch_index.into(), id.into(), scope)
    }

    fn build_impl(
        &self,
        batched_tensor: crate::Output,
        batch_index: crate::Output,
        id: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Unbatch", |nd| {
            nd.add_input(batched_tensor);
            nd.add_input(batch_index);
            nd.add_input(id);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.timeout_micros {
                nd.set_attr_int("timeout_micros", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Unbatch::new().build(batched_tensor, batch_index, id, scope)`.
pub fn unbatch<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    batched_tensor: O0,
    batch_index: O1,
    id: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Unbatch::new().build(batched_tensor, batch_index, id, scope)
}
/// Builder for the `UnbatchDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnbatchDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnbatchDataset {
    /// Creates a new `UnbatchDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnbatchDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnbatchDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnbatchDataset::new().build(input_dataset, scope)`.
pub fn unbatch_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnbatchDataset::new().build(input_dataset, scope)
}
/// Builder for the `UnbatchGrad` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnbatchGrad {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnbatchGrad {
    /// Creates a new `UnbatchGrad`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnbatchGrad` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        original_input: O0,
        batch_index: O1,
        grad: O2,
        id: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            original_input.into(),
            batch_index.into(),
            grad.into(),
            id.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        original_input: crate::Output,
        batch_index: crate::Output,
        grad: crate::Output,
        id: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnbatchGrad", |nd| {
            nd.add_input(original_input);
            nd.add_input(batch_index);
            nd.add_input(grad);
            nd.add_input(id);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnbatchGrad::new().build(original_input, batch_index, grad, id, scope)`.
pub fn unbatch_grad<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    original_input: O0,
    batch_index: O1,
    grad: O2,
    id: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnbatchGrad::new().build(original_input, batch_index, grad, id, scope)
}
/// Builder for the `UncompressElement` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UncompressElement {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UncompressElement {
    /// Creates a new `UncompressElement`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UncompressElement` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        compressed: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(compressed.into(), scope)
    }

    fn build_impl(
        &self,
        compressed: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UncompressElement", |nd| {
            nd.add_input(compressed);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UncompressElement::new().build(compressed, scope)`.
pub fn uncompress_element<O0: ::std::convert::Into<crate::Output>>(
    compressed: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UncompressElement::new().build(compressed, scope)
}
/// Builder for the `UnicodeDecode` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeDecode {
    input_encoding: ::std::option::Option<::std::string::String>,
    errors: ::std::option::Option<::std::string::String>,
    replacement_char: ::std::option::Option<i64>,
    replace_control_characters: ::std::option::Option<bool>,
    Tsplits: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnicodeDecode {
    /// Creates a new `UnicodeDecode`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `input_encoding` attribute.
    pub fn input_encoding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_encoding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `errors` attribute.
    pub fn errors<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.errors = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `replacement_char` attribute.
    pub fn replacement_char<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.replacement_char = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `replace_control_characters` attribute.
    pub fn replace_control_characters<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.replace_control_characters = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnicodeDecode` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnicodeDecode", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.input_encoding {
                nd.set_attr_string("input_encoding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.errors {
                nd.set_attr_string("errors", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.replacement_char {
                nd.set_attr_int("replacement_char", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.replace_control_characters {
                nd.set_attr_bool("replace_control_characters", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnicodeDecode::new().build(input, scope)`.
pub fn unicode_decode<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnicodeDecode::new().build(input, scope)
}
/// Builder for the `UnicodeDecodeWithOffsets` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeDecodeWithOffsets {
    input_encoding: ::std::option::Option<::std::string::String>,
    errors: ::std::option::Option<::std::string::String>,
    replacement_char: ::std::option::Option<i64>,
    replace_control_characters: ::std::option::Option<bool>,
    Tsplits: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnicodeDecodeWithOffsets {
    /// Creates a new `UnicodeDecodeWithOffsets`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `input_encoding` attribute.
    pub fn input_encoding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_encoding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `errors` attribute.
    pub fn errors<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.errors = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `replacement_char` attribute.
    pub fn replacement_char<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.replacement_char = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `replace_control_characters` attribute.
    pub fn replace_control_characters<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.replace_control_characters = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnicodeDecodeWithOffsets` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnicodeDecodeWithOffsets", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.input_encoding {
                nd.set_attr_string("input_encoding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.errors {
                nd.set_attr_string("errors", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.replacement_char {
                nd.set_attr_int("replacement_char", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.replace_control_characters {
                nd.set_attr_bool("replace_control_characters", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnicodeDecodeWithOffsets::new().build(input, scope)`.
pub fn unicode_decode_with_offsets<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnicodeDecodeWithOffsets::new().build(input, scope)
}
/// Builder for the `UnicodeEncode` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeEncode {
    errors: ::std::option::Option<::std::string::String>,
    output_encoding: ::std::option::Option<::std::string::String>,
    replacement_char: ::std::option::Option<i64>,
    Tsplits: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnicodeEncode {
    /// Creates a new `UnicodeEncode`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `errors` attribute.
    pub fn errors<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.errors = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_encoding` attribute.
    pub fn output_encoding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_encoding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `replacement_char` attribute.
    pub fn replacement_char<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.replacement_char = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tsplits` attribute.
    pub fn Tsplits<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tsplits = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnicodeEncode` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_values: O0,
        input_splits: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_values.into(), input_splits.into(), scope)
    }

    fn build_impl(
        &self,
        input_values: crate::Output,
        input_splits: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnicodeEncode", |nd| {
            nd.add_input(input_values);
            nd.add_input(input_splits);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.errors {
                nd.set_attr_string("errors", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_encoding {
                nd.set_attr_string("output_encoding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.replacement_char {
                nd.set_attr_int("replacement_char", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tsplits {
                nd.set_attr_type("Tsplits", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnicodeEncode::new().build(input_values, input_splits, scope)`.
pub fn unicode_encode<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    input_values: O0,
    input_splits: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnicodeEncode::new().build(input_values, input_splits, scope)
}
/// Builder for the `UnicodeScript` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeScript {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnicodeScript {
    /// Creates a new `UnicodeScript`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnicodeScript` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnicodeScript", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnicodeScript::new().build(input, scope)`.
pub fn unicode_script<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnicodeScript::new().build(input, scope)
}
/// Builder for the `UnicodeTranscode` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnicodeTranscode {
    input_encoding: ::std::option::Option<::std::string::String>,
    output_encoding: ::std::option::Option<::std::string::String>,
    errors: ::std::option::Option<::std::string::String>,
    replacement_char: ::std::option::Option<i64>,
    replace_control_characters: ::std::option::Option<bool>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnicodeTranscode {
    /// Creates a new `UnicodeTranscode`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `input_encoding` attribute.
    pub fn input_encoding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.input_encoding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_encoding` attribute.
    pub fn output_encoding<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_encoding = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `errors` attribute.
    pub fn errors<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.errors = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `replacement_char` attribute.
    pub fn replacement_char<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.replacement_char = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `replace_control_characters` attribute.
    pub fn replace_control_characters<ArgType: ::std::convert::Into<bool>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.replace_control_characters = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnicodeTranscode` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnicodeTranscode", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.input_encoding {
                nd.set_attr_string("input_encoding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_encoding {
                nd.set_attr_string("output_encoding", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.errors {
                nd.set_attr_string("errors", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.replacement_char {
                nd.set_attr_int("replacement_char", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.replace_control_characters {
                nd.set_attr_bool("replace_control_characters", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnicodeTranscode::new().build(input, scope)`.
pub fn unicode_transcode<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnicodeTranscode::new().build(input, scope)
}
/// Builder for the `UniformCandidateSampler` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniformCandidateSampler {
    num_true: ::std::option::Option<i64>,
    num_sampled: ::std::option::Option<i64>,
    unique: ::std::option::Option<bool>,
    range_max: ::std::option::Option<i64>,
    seed: ::std::option::Option<i64>,
    seed2: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UniformCandidateSampler {
    /// Creates a new `UniformCandidateSampler`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num_true` attribute.
    pub fn num_true<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_true = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `num_sampled` attribute.
    pub fn num_sampled<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num_sampled = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `unique` attribute.
    pub fn unique<ArgType: ::std::convert::Into<bool>>(mut self, value: ArgType) -> Self {
        self.unique = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `range_max` attribute.
    pub fn range_max<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.range_max = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed` attribute.
    pub fn seed<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `seed2` attribute.
    pub fn seed2<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.seed2 = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UniformCandidateSampler` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        true_classes: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(true_classes.into(), scope)
    }

    fn build_impl(
        &self,
        true_classes: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UniformCandidateSampler", |nd| {
            nd.add_input(true_classes);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num_true {
                nd.set_attr_int("num_true", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.num_sampled {
                nd.set_attr_int("num_sampled", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.unique {
                nd.set_attr_bool("unique", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.range_max {
                nd.set_attr_int("range_max", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed {
                nd.set_attr_int("seed", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.seed2 {
                nd.set_attr_int("seed2", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UniformCandidateSampler::new().build(true_classes, scope)`.
pub fn uniform_candidate_sampler<O0: ::std::convert::Into<crate::Output>>(
    true_classes: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UniformCandidateSampler::new().build(true_classes, scope)
}
/// Builder for the `Unique` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Unique {
    T: ::std::option::Option<crate::DataType>,
    out_idx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Unique {
    /// Creates a new `Unique`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_idx` attribute.
    pub fn out_idx<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_idx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Unique` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Unique", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_idx {
                nd.set_attr_type("out_idx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Unique::new().build(x, scope)`.
pub fn unique<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Unique::new().build(x, scope)
}
/// Builder for the `UniqueDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniqueDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UniqueDataset {
    /// Creates a new `UniqueDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UniqueDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_dataset: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_dataset.into(), scope)
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UniqueDataset", |nd| {
            nd.add_input(input_dataset);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UniqueDataset::new().build(input_dataset, scope)`.
pub fn unique_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_dataset: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UniqueDataset::new().build(input_dataset, scope)
}
/// Builder for the `UniqueV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniqueV2 {
    T: ::std::option::Option<crate::DataType>,
    Taxis: ::std::option::Option<crate::DataType>,
    out_idx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UniqueV2 {
    /// Creates a new `UniqueV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Taxis` attribute.
    pub fn Taxis<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Taxis = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_idx` attribute.
    pub fn out_idx<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_idx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UniqueV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        axis: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UniqueV2", |nd| {
            nd.add_input(x);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Taxis {
                nd.set_attr_type("Taxis", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_idx {
                nd.set_attr_type("out_idx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UniqueV2::new().build(x, axis, scope)`.
pub fn unique_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    axis: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UniqueV2::new().build(x, axis, scope)
}
/// Builder for the `UniqueWithCounts` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniqueWithCounts {
    T: ::std::option::Option<crate::DataType>,
    out_idx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UniqueWithCounts {
    /// Creates a new `UniqueWithCounts`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_idx` attribute.
    pub fn out_idx<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_idx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UniqueWithCounts` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UniqueWithCounts", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_idx {
                nd.set_attr_type("out_idx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UniqueWithCounts::new().build(x, scope)`.
pub fn unique_with_counts<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UniqueWithCounts::new().build(x, scope)
}
/// Builder for the `UniqueWithCountsV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UniqueWithCountsV2 {
    T: ::std::option::Option<crate::DataType>,
    Taxis: ::std::option::Option<crate::DataType>,
    out_idx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UniqueWithCountsV2 {
    /// Creates a new `UniqueWithCountsV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Taxis` attribute.
    pub fn Taxis<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Taxis = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_idx` attribute.
    pub fn out_idx<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_idx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UniqueWithCountsV2` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        axis: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), axis.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        axis: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UniqueWithCountsV2", |nd| {
            nd.add_input(x);
            nd.add_input(axis);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Taxis {
                nd.set_attr_type("Taxis", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_idx {
                nd.set_attr_type("out_idx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UniqueWithCountsV2::new().build(x, axis, scope)`.
pub fn unique_with_counts_v2<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    x: O0,
    axis: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UniqueWithCountsV2::new().build(x, axis, scope)
}
/// Builder for the `Unpack` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Unpack {
    num: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    axis: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Unpack {
    /// Creates a new `Unpack`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `num` attribute.
    pub fn num<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.num = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `axis` attribute.
    pub fn axis<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.axis = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Unpack` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        value: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(value.into(), scope)
    }

    fn build_impl(
        &self,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Unpack", |nd| {
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.num {
                nd.set_attr_int("num", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.axis {
                nd.set_attr_int("axis", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Unpack::new().build(value, scope)`.
pub fn unpack<O0: ::std::convert::Into<crate::Output>>(
    value: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Unpack::new().build(value, scope)
}
/// Builder for the `UnravelIndex` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnravelIndex {
    Tidx: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnravelIndex {
    /// Creates a new `UnravelIndex`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `Tidx` attribute.
    pub fn Tidx<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.Tidx = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnravelIndex` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        indices: O0,
        dims: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(indices.into(), dims.into(), scope)
    }

    fn build_impl(
        &self,
        indices: crate::Output,
        dims: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnravelIndex", |nd| {
            nd.add_input(indices);
            nd.add_input(dims);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.Tidx {
                nd.set_attr_type("Tidx", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnravelIndex::new().build(indices, dims, scope)`.
pub fn unravel_index<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    indices: O0,
    dims: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnravelIndex::new().build(indices, dims, scope)
}
/// Builder for the `UnsortedSegmentJoin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentJoin {
    separator: ::std::option::Option<::std::string::String>,
    Tindices: ::std::option::Option<crate::DataType>,
    Tnumsegments: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnsortedSegmentJoin {
    /// Creates a new `UnsortedSegmentJoin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `separator` attribute.
    pub fn separator<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.separator = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnumsegments` attribute.
    pub fn Tnumsegments<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnumsegments = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnsortedSegmentJoin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        inputs: O0,
        segment_ids: O1,
        num_segments: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            inputs.into(),
            segment_ids.into(),
            num_segments.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        inputs: crate::Output,
        segment_ids: crate::Output,
        num_segments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnsortedSegmentJoin", |nd| {
            nd.add_input(inputs);
            nd.add_input(segment_ids);
            nd.add_input(num_segments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.separator {
                nd.set_attr_string("separator", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnumsegments {
                nd.set_attr_type("Tnumsegments", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnsortedSegmentJoin::new().build(inputs, segment_ids, num_segments, scope)`.
pub fn unsorted_segment_join<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    inputs: O0,
    segment_ids: O1,
    num_segments: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnsortedSegmentJoin::new().build(inputs, segment_ids, num_segments, scope)
}
/// Builder for the `UnsortedSegmentMax` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentMax {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    Tnumsegments: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnsortedSegmentMax {
    /// Creates a new `UnsortedSegmentMax`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnumsegments` attribute.
    pub fn Tnumsegments<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnumsegments = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnsortedSegmentMax` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        num_segments: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), num_segments.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        num_segments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnsortedSegmentMax", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            nd.add_input(num_segments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnumsegments {
                nd.set_attr_type("Tnumsegments", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnsortedSegmentMax::new().build(data, segment_ids, num_segments, scope)`.
pub fn unsorted_segment_max<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    num_segments: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnsortedSegmentMax::new().build(data, segment_ids, num_segments, scope)
}
/// Builder for the `UnsortedSegmentMin` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentMin {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    Tnumsegments: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnsortedSegmentMin {
    /// Creates a new `UnsortedSegmentMin`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnumsegments` attribute.
    pub fn Tnumsegments<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnumsegments = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnsortedSegmentMin` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        num_segments: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), num_segments.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        num_segments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnsortedSegmentMin", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            nd.add_input(num_segments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnumsegments {
                nd.set_attr_type("Tnumsegments", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnsortedSegmentMin::new().build(data, segment_ids, num_segments, scope)`.
pub fn unsorted_segment_min<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    num_segments: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnsortedSegmentMin::new().build(data, segment_ids, num_segments, scope)
}
/// Builder for the `UnsortedSegmentProd` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentProd {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    Tnumsegments: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnsortedSegmentProd {
    /// Creates a new `UnsortedSegmentProd`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnumsegments` attribute.
    pub fn Tnumsegments<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnumsegments = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnsortedSegmentProd` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        num_segments: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), num_segments.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        num_segments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnsortedSegmentProd", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            nd.add_input(num_segments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnumsegments {
                nd.set_attr_type("Tnumsegments", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnsortedSegmentProd::new().build(data, segment_ids, num_segments, scope)`.
pub fn unsorted_segment_prod<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    num_segments: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnsortedSegmentProd::new().build(data, segment_ids, num_segments, scope)
}
/// Builder for the `UnsortedSegmentSum` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnsortedSegmentSum {
    T: ::std::option::Option<crate::DataType>,
    Tindices: ::std::option::Option<crate::DataType>,
    Tnumsegments: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnsortedSegmentSum {
    /// Creates a new `UnsortedSegmentSum`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tindices` attribute.
    pub fn Tindices<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tindices = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `Tnumsegments` attribute.
    pub fn Tnumsegments<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.Tnumsegments = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnsortedSegmentSum` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        data: O0,
        segment_ids: O1,
        num_segments: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(data.into(), segment_ids.into(), num_segments.into(), scope)
    }

    fn build_impl(
        &self,
        data: crate::Output,
        segment_ids: crate::Output,
        num_segments: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnsortedSegmentSum", |nd| {
            nd.add_input(data);
            nd.add_input(segment_ids);
            nd.add_input(num_segments);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tindices {
                nd.set_attr_type("Tindices", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.Tnumsegments {
                nd.set_attr_type("Tnumsegments", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnsortedSegmentSum::new().build(data, segment_ids, num_segments, scope)`.
pub fn unsorted_segment_sum<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    data: O0,
    segment_ids: O1,
    num_segments: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnsortedSegmentSum::new().build(data, segment_ids, num_segments, scope)
}
/// Builder for the `Unstage` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Unstage {
    capacity: ::std::option::Option<i64>,
    memory_limit: ::std::option::Option<i64>,
    dtypes: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Unstage {
    /// Creates a new `Unstage`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `capacity` attribute.
    pub fn capacity<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.capacity = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `memory_limit` attribute.
    pub fn memory_limit<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.memory_limit = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtypes` attribute.
    pub fn dtypes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.dtypes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Unstage` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Unstage", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.capacity {
                nd.set_attr_int("capacity", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.memory_limit {
                nd.set_attr_int("memory_limit", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtypes {
                nd.set_attr_type_list("dtypes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Unstage::new().build(scope)`.
pub fn unstage(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Unstage::new().build(scope)
}
/// Builder for the `UnwrapDatasetVariant` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UnwrapDatasetVariant {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UnwrapDatasetVariant {
    /// Creates a new `UnwrapDatasetVariant`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UnwrapDatasetVariant` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UnwrapDatasetVariant", |nd| {
            nd.add_input(input_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UnwrapDatasetVariant::new().build(input_handle, scope)`.
pub fn unwrap_dataset_variant<O0: ::std::convert::Into<crate::Output>>(
    input_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UnwrapDatasetVariant::new().build(input_handle, scope)
}
/// Builder for the `UpperBound` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct UpperBound {
    T: ::std::option::Option<crate::DataType>,
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl UpperBound {
    /// Creates a new `UpperBound`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `UpperBound` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        sorted_inputs: O0,
        values: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(sorted_inputs.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        sorted_inputs: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("UpperBound", |nd| {
            nd.add_input(sorted_inputs);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `UpperBound::new().build(sorted_inputs, values, scope)`.
pub fn upper_bound<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    sorted_inputs: O0,
    values: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    UpperBound::new().build(sorted_inputs, values, scope)
}
/// Builder for the `VarHandleOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct VarHandleOp {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    dtype: ::std::option::Option<crate::DataType>,
    shape: ::std::option::Option<crate::Shape>,
    allowed_devices: ::std::option::Option<::std::vec::Vec<::std::string::String>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl VarHandleOp {
    /// Creates a new `VarHandleOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `allowed_devices` attribute.
    pub fn allowed_devices<
        ArgType: ::std::convert::Into<::std::vec::Vec<::std::string::String>>,
    >(
        mut self,
        value: ArgType,
    ) -> Self {
        self.allowed_devices = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `VarHandleOp` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("VarHandleOp", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.allowed_devices {
                nd.set_attr_string_list("allowed_devices", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `VarHandleOp::new().build(scope)`.
pub fn var_handle_op(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    VarHandleOp::new().build(scope)
}
/// Builder for the `VarIsInitializedOp` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct VarIsInitializedOp {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl VarIsInitializedOp {
    /// Creates a new `VarIsInitializedOp`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `VarIsInitializedOp` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        resource: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(resource.into(), scope)
    }

    fn build_impl(
        &self,
        resource: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("VarIsInitializedOp", |nd| {
            nd.add_input(resource);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `VarIsInitializedOp::new().build(resource, scope)`.
pub fn var_is_initialized_op<O0: ::std::convert::Into<crate::Output>>(
    resource: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    VarIsInitializedOp::new().build(resource, scope)
}
/// Builder for the `Variable` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Variable {
    shape: ::std::option::Option<crate::Shape>,
    dtype: ::std::option::Option<crate::DataType>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Variable {
    /// Creates a new `Variable`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Variable` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("Variable", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Variable::new().build(scope)`.
pub fn variable(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    Variable::new().build(scope)
}
/// Builder for the `VariableShape` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct VariableShape {
    out_type: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl VariableShape {
    /// Creates a new `VariableShape`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `out_type` attribute.
    pub fn out_type<ArgType: ::std::convert::Into<crate::DataType>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.out_type = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `VariableShape` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("VariableShape", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.out_type {
                nd.set_attr_type("out_type", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `VariableShape::new().build(input, scope)`.
pub fn variable_shape<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    VariableShape::new().build(input, scope)
}
/// Builder for the `VariableV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct VariableV2 {
    shape: ::std::option::Option<crate::Shape>,
    dtype: ::std::option::Option<crate::DataType>,
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl VariableV2 {
    /// Creates a new `VariableV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `shape` attribute.
    pub fn shape<ArgType: ::std::convert::Into<crate::Shape>>(mut self, value: ArgType) -> Self {
        self.shape = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `dtype` attribute.
    pub fn dtype<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.dtype = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `VariableV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("VariableV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.shape {
                nd.set_attr_shape("shape", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.dtype {
                nd.set_attr_type("dtype", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `VariableV2::new().build(scope)`.
pub fn variable_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    VariableV2::new().build(scope)
}
/// Builder for the `Where` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Where {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Where {
    /// Creates a new `Where`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Where` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Where", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Where::new().build(input, scope)`.
pub fn where_<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Where::new().build(input, scope)
}
/// Builder for the `While` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct While {
    T: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    cond: ::std::option::Option<::std::string::String>,
    body: ::std::option::Option<::std::string::String>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    parallel_iterations: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl While {
    /// Creates a new `While`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `cond` attribute.
    pub fn cond<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.cond = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `body` attribute.
    pub fn body<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.body = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `parallel_iterations` attribute.
    pub fn parallel_iterations<ArgType: ::std::convert::Into<i64>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.parallel_iterations = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `While` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input.into(), scope)
    }

    fn build_impl(
        &self,
        input: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("While", |nd| {
            nd.add_input(input);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type_list("T", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.cond {
                nd.set_attr_string("cond", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.body {
                nd.set_attr_string("body", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.parallel_iterations {
                nd.set_attr_int("parallel_iterations", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `While::new().build(input, scope)`.
pub fn while_<O0: ::std::convert::Into<crate::Output>>(
    input: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    While::new().build(input, scope)
}
/// Builder for the `WholeFileReader` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WholeFileReader {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WholeFileReader {
    /// Creates a new `WholeFileReader`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WholeFileReader` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("WholeFileReader", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WholeFileReader::new().build(scope)`.
pub fn whole_file_reader(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    WholeFileReader::new().build(scope)
}
/// Builder for the `WholeFileReaderV2` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WholeFileReaderV2 {
    container: ::std::option::Option<::std::string::String>,
    shared_name: ::std::option::Option<::std::string::String>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WholeFileReaderV2 {
    /// Creates a new `WholeFileReaderV2`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `container` attribute.
    pub fn container<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.container = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `shared_name` attribute.
    pub fn shared_name<ArgType: ::std::convert::Into<::std::string::String>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.shared_name = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WholeFileReaderV2` operation.
    pub fn build(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        self.build_impl(scope)
    }

    fn build_impl(&self, scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
        scope.new_operation("WholeFileReaderV2", |nd| {
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.container {
                nd.set_attr_string("container", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.shared_name {
                nd.set_attr_string("shared_name", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WholeFileReaderV2::new().build(scope)`.
pub fn whole_file_reader_v2(scope: &mut crate::Scope) -> crate::Result<crate::Operation> {
    WholeFileReaderV2::new().build(scope)
}
/// Builder for the `WindowDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WindowDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WindowDataset {
    /// Creates a new `WindowDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WindowDataset` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        input_dataset: O0,
        size: O1,
        shift: O2,
        stride: O3,
        drop_remainder: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            input_dataset.into(),
            size.into(),
            shift.into(),
            stride.into(),
            drop_remainder.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        input_dataset: crate::Output,
        size: crate::Output,
        shift: crate::Output,
        stride: crate::Output,
        drop_remainder: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WindowDataset", |nd| {
            nd.add_input(input_dataset);
            nd.add_input(size);
            nd.add_input(shift);
            nd.add_input(stride);
            nd.add_input(drop_remainder);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WindowDataset::new().build(input_dataset, size, shift, stride, drop_remainder, scope)`.
pub fn window_dataset<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    input_dataset: O0,
    size: O1,
    shift: O2,
    stride: O3,
    drop_remainder: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WindowDataset::new().build(input_dataset, size, shift, stride, drop_remainder, scope)
}
/// Builder for the `WorkerHeartbeat` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WorkerHeartbeat {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WorkerHeartbeat {
    /// Creates a new `WorkerHeartbeat`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WorkerHeartbeat` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        request: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(request.into(), scope)
    }

    fn build_impl(
        &self,
        request: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WorkerHeartbeat", |nd| {
            nd.add_input(request);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WorkerHeartbeat::new().build(request, scope)`.
pub fn worker_heartbeat<O0: ::std::convert::Into<crate::Output>>(
    request: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WorkerHeartbeat::new().build(request, scope)
}
/// Builder for the `WrapDatasetVariant` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WrapDatasetVariant {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WrapDatasetVariant {
    /// Creates a new `WrapDatasetVariant`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WrapDatasetVariant` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_handle: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_handle.into(), scope)
    }

    fn build_impl(
        &self,
        input_handle: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WrapDatasetVariant", |nd| {
            nd.add_input(input_handle);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WrapDatasetVariant::new().build(input_handle, scope)`.
pub fn wrap_dataset_variant<O0: ::std::convert::Into<crate::Output>>(
    input_handle: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WrapDatasetVariant::new().build(input_handle, scope)
}
/// Builder for the `WriteAudioSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteAudioSummary {
    max_outputs: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WriteAudioSummary {
    /// Creates a new `WriteAudioSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_outputs` attribute.
    pub fn max_outputs<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_outputs = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WriteAudioSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        step: O1,
        tag: O2,
        tensor: O3,
        sample_rate: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            writer.into(),
            step.into(),
            tag.into(),
            tensor.into(),
            sample_rate.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        step: crate::Output,
        tag: crate::Output,
        tensor: crate::Output,
        sample_rate: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WriteAudioSummary", |nd| {
            nd.add_input(writer);
            nd.add_input(step);
            nd.add_input(tag);
            nd.add_input(tensor);
            nd.add_input(sample_rate);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_outputs {
                nd.set_attr_int("max_outputs", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WriteAudioSummary::new().build(writer, step, tag, tensor, sample_rate, scope)`.
pub fn write_audio_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    step: O1,
    tag: O2,
    tensor: O3,
    sample_rate: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WriteAudioSummary::new().build(writer, step, tag, tensor, sample_rate, scope)
}
/// Builder for the `WriteFile` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteFile {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WriteFile {
    /// Creates a new `WriteFile`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WriteFile` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        filename: O0,
        contents: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(filename.into(), contents.into(), scope)
    }

    fn build_impl(
        &self,
        filename: crate::Output,
        contents: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WriteFile", |nd| {
            nd.add_input(filename);
            nd.add_input(contents);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WriteFile::new().build(filename, contents, scope)`.
pub fn write_file<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
>(
    filename: O0,
    contents: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WriteFile::new().build(filename, contents, scope)
}
/// Builder for the `WriteGraphSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteGraphSummary {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WriteGraphSummary {
    /// Creates a new `WriteGraphSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WriteGraphSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        step: O1,
        tensor: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(writer.into(), step.into(), tensor.into(), scope)
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        step: crate::Output,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WriteGraphSummary", |nd| {
            nd.add_input(writer);
            nd.add_input(step);
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WriteGraphSummary::new().build(writer, step, tensor, scope)`.
pub fn write_graph_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    step: O1,
    tensor: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WriteGraphSummary::new().build(writer, step, tensor, scope)
}
/// Builder for the `WriteHistogramSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteHistogramSummary {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WriteHistogramSummary {
    /// Creates a new `WriteHistogramSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WriteHistogramSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        step: O1,
        tag: O2,
        values: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(writer.into(), step.into(), tag.into(), values.into(), scope)
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        step: crate::Output,
        tag: crate::Output,
        values: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WriteHistogramSummary", |nd| {
            nd.add_input(writer);
            nd.add_input(step);
            nd.add_input(tag);
            nd.add_input(values);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WriteHistogramSummary::new().build(writer, step, tag, values, scope)`.
pub fn write_histogram_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    step: O1,
    tag: O2,
    values: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WriteHistogramSummary::new().build(writer, step, tag, values, scope)
}
/// Builder for the `WriteImageSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteImageSummary {
    max_images: ::std::option::Option<i64>,
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WriteImageSummary {
    /// Creates a new `WriteImageSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `max_images` attribute.
    pub fn max_images<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.max_images = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WriteImageSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        step: O1,
        tag: O2,
        tensor: O3,
        bad_color: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            writer.into(),
            step.into(),
            tag.into(),
            tensor.into(),
            bad_color.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        step: crate::Output,
        tag: crate::Output,
        tensor: crate::Output,
        bad_color: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WriteImageSummary", |nd| {
            nd.add_input(writer);
            nd.add_input(step);
            nd.add_input(tag);
            nd.add_input(tensor);
            nd.add_input(bad_color);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.max_images {
                nd.set_attr_int("max_images", *value)?;
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WriteImageSummary::new().build(writer, step, tag, tensor, bad_color, scope)`.
pub fn write_image_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    step: O1,
    tag: O2,
    tensor: O3,
    bad_color: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WriteImageSummary::new().build(writer, step, tag, tensor, bad_color, scope)
}
/// Builder for the `WriteRawProtoSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteRawProtoSummary {
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WriteRawProtoSummary {
    /// Creates a new `WriteRawProtoSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WriteRawProtoSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        step: O1,
        tensor: O2,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(writer.into(), step.into(), tensor.into(), scope)
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        step: crate::Output,
        tensor: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WriteRawProtoSummary", |nd| {
            nd.add_input(writer);
            nd.add_input(step);
            nd.add_input(tensor);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WriteRawProtoSummary::new().build(writer, step, tensor, scope)`.
pub fn write_raw_proto_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    step: O1,
    tensor: O2,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WriteRawProtoSummary::new().build(writer, step, tensor, scope)
}
/// Builder for the `WriteScalarSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteScalarSummary {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WriteScalarSummary {
    /// Creates a new `WriteScalarSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WriteScalarSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        step: O1,
        tag: O2,
        value: O3,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(writer.into(), step.into(), tag.into(), value.into(), scope)
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        step: crate::Output,
        tag: crate::Output,
        value: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WriteScalarSummary", |nd| {
            nd.add_input(writer);
            nd.add_input(step);
            nd.add_input(tag);
            nd.add_input(value);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WriteScalarSummary::new().build(writer, step, tag, value, scope)`.
pub fn write_scalar_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    step: O1,
    tag: O2,
    value: O3,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WriteScalarSummary::new().build(writer, step, tag, value, scope)
}
/// Builder for the `WriteSummary` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct WriteSummary {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl WriteSummary {
    /// Creates a new `WriteSummary`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `WriteSummary` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
        O2: ::std::convert::Into<crate::Output>,
        O3: ::std::convert::Into<crate::Output>,
        O4: ::std::convert::Into<crate::Output>,
    >(
        &self,
        writer: O0,
        step: O1,
        tensor: O2,
        tag: O3,
        summary_metadata: O4,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(
            writer.into(),
            step.into(),
            tensor.into(),
            tag.into(),
            summary_metadata.into(),
            scope,
        )
    }

    fn build_impl(
        &self,
        writer: crate::Output,
        step: crate::Output,
        tensor: crate::Output,
        tag: crate::Output,
        summary_metadata: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("WriteSummary", |nd| {
            nd.add_input(writer);
            nd.add_input(step);
            nd.add_input(tensor);
            nd.add_input(tag);
            nd.add_input(summary_metadata);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `WriteSummary::new().build(writer, step, tensor, tag, summary_metadata, scope)`.
pub fn write_summary<
    O0: ::std::convert::Into<crate::Output>,
    O1: ::std::convert::Into<crate::Output>,
    O2: ::std::convert::Into<crate::Output>,
    O3: ::std::convert::Into<crate::Output>,
    O4: ::std::convert::Into<crate::Output>,
>(
    writer: O0,
    step: O1,
    tensor: O2,
    tag: O3,
    summary_metadata: O4,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    WriteSummary::new().build(writer, step, tensor, tag, summary_metadata, scope)
}
/// Builder for the `Xdivy` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Xdivy {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Xdivy {
    /// Creates a new `Xdivy`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Xdivy` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Xdivy", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Xdivy::new().build(x, y, scope)`.
pub fn xdivy<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Xdivy::new().build(x, y, scope)
}
/// Builder for the `Xlog1py` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Xlog1py {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Xlog1py {
    /// Creates a new `Xlog1py`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Xlog1py` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Xlog1py", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Xlog1py::new().build(x, y, scope)`.
pub fn xlog1py<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Xlog1py::new().build(x, y, scope)
}
/// Builder for the `Xlogy` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Xlogy {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Xlogy {
    /// Creates a new `Xlogy`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Xlogy` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        y: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), y.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        y: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Xlogy", |nd| {
            nd.add_input(x);
            nd.add_input(y);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Xlogy::new().build(x, y, scope)`.
pub fn xlogy<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    y: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Xlogy::new().build(x, y, scope)
}
/// Builder for the `ZerosLike` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ZerosLike {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ZerosLike {
    /// Creates a new `ZerosLike`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ZerosLike` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        x: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ZerosLike", |nd| {
            nd.add_input(x);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ZerosLike::new().build(x, scope)`.
pub fn zeros_like<O0: ::std::convert::Into<crate::Output>>(
    x: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ZerosLike::new().build(x, scope)
}
/// Builder for the `Zeta` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct Zeta {
    T: ::std::option::Option<crate::DataType>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl Zeta {
    /// Creates a new `Zeta`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `T` attribute.
    pub fn T<ArgType: ::std::convert::Into<crate::DataType>>(mut self, value: ArgType) -> Self {
        self.T = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `Zeta` operation.
    pub fn build<
        O0: ::std::convert::Into<crate::Output>,
        O1: ::std::convert::Into<crate::Output>,
    >(
        &self,
        x: O0,
        q: O1,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(x.into(), q.into(), scope)
    }

    fn build_impl(
        &self,
        x: crate::Output,
        q: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("Zeta", |nd| {
            nd.add_input(x);
            nd.add_input(q);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.T {
                nd.set_attr_type("T", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `Zeta::new().build(x, q, scope)`.
pub fn zeta<O0: ::std::convert::Into<crate::Output>, O1: ::std::convert::Into<crate::Output>>(
    x: O0,
    q: O1,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    Zeta::new().build(x, q, scope)
}
/// Builder for the `ZipDataset` operation.
#[derive(::std::fmt::Debug, ::std::default::Default)]
pub struct ZipDataset {
    output_types: ::std::option::Option<::std::vec::Vec<crate::DataType>>,
    output_shapes: ::std::option::Option<::std::vec::Vec<crate::Shape>>,
    N: ::std::option::Option<i64>,
    control_inputs: ::std::vec::Vec<crate::Operation>,
}

impl ZipDataset {
    /// Creates a new `ZipDataset`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Sets the `output_types` attribute.
    pub fn output_types<ArgType: ::std::convert::Into<::std::vec::Vec<crate::DataType>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_types = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `output_shapes` attribute.
    pub fn output_shapes<ArgType: ::std::convert::Into<::std::vec::Vec<crate::Shape>>>(
        mut self,
        value: ArgType,
    ) -> Self {
        self.output_shapes = ::std::option::Option::Some(value.into());
        self
    }

    /// Sets the `N` attribute.
    pub fn N<ArgType: ::std::convert::Into<i64>>(mut self, value: ArgType) -> Self {
        self.N = ::std::option::Option::Some(value.into());
        self
    }

    /// Adds a control input.
    pub fn add_control_input(mut self, op: crate::Operation) -> Self {
        self.control_inputs.push(op);
        self
    }

    /// Builds the `ZipDataset` operation.
    pub fn build<O0: ::std::convert::Into<crate::Output>>(
        &self,
        input_datasets: O0,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        self.build_impl(input_datasets.into(), scope)
    }

    fn build_impl(
        &self,
        input_datasets: crate::Output,
        scope: &mut crate::Scope,
    ) -> crate::Result<crate::Operation> {
        scope.new_operation("ZipDataset", |nd| {
            nd.add_input(input_datasets);
            for op in &self.control_inputs {
                nd.add_control_input(op);
            }
            if let ::std::option::Option::Some(value) = &self.output_types {
                nd.set_attr_type_list("output_types", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.output_shapes {
                nd.set_attr_shape_list("output_shapes", value)?;
            }
            if let ::std::option::Option::Some(value) = &self.N {
                nd.set_attr_int("N", *value)?;
            }
            ::std::result::Result::Ok(())
        })
    }
}

/// Shorthand for `ZipDataset::new().build(input_datasets, scope)`.
pub fn zip_dataset<O0: ::std::convert::Into<crate::Output>>(
    input_datasets: O0,
    scope: &mut crate::Scope,
) -> crate::Result<crate::Operation> {
    ZipDataset::new().build(input_datasets, scope)
}
